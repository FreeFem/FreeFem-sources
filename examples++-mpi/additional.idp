macro plotMPI(Th, u, legend, Pk, def, d, w)
    if(mpirank == 0) {
        meshN ThCurrent = Th;
        meshN[int] meshTab(mpisize);
        fespace Xh(ThCurrent, Pk);
        Xh<real>[int] def(uTab)(mpisize);
        uTab[0][] = u;
        meshTab[0] = Th;
        mpiRequest[int] rq(mpisize - 1);
        for(i = 1; i < mpisize; ++i)
            Irecv(processor(i, mpiCommWorld, rq[i - 1]), meshTab[i]);
        for(i = 1; i < mpisize; ++i)
            mpiWaitAny(rq);
        for(i = 1; i < mpisize; ++i) {
            ThCurrent = meshTab[i];
            Irecv(processor(i, mpiCommWorld, rq[i - 1]), uTab[i][]);
        }
        for(i = 1; i < mpisize; ++i)
            mpiWaitAny(rq);
        plot(uTab, wait = w, nbiso = 40, fill = 1, value = 1, dim = d, cmm = legend);
    }
    else {
        mpiRequest[int] rq(2);
        Isend(processor(0, rq[0]), Th);
        Isend(processor(0, rq[1]), u);
        mpiWait(rq[0]);
        mpiWait(rq[1]);
    }// EOM
func bool AddLayersFF(meshN & Th, real[int] &ssd,int n,real[int] &unssd)
{
  //  build a continuous function  uussd (P1) and modifies ssd :
  //  IN: ssd in the caracteristics function on the input sub domain.
  //  OUT: ssd and unssd
  //  such that : 
  //   ssd is a boolean function 
  //   unssd is a smooth function
  //   ssd = 1 when   unssd >0;
  //   add n layer of element (size of the overlap)
  //   and unssd = 0 ouside of this layer ...
  // ---------------------------------
  fespace Vh(Th,P1);
  fespace Ph(Th,P0);
  Ph s;
  // assert(ssd.n==Ph.ndof);
  // assert(unssd.n==Vh.ndof);
  unssd=0;
  s[]= ssd;
  Vh u;
  varf vM(uuuu,v)=intN(Th,qforder=1)(uuuu*v/measureN);
  matrix M=vM(Ph,Vh);
  
  for(int i=0;i<n;++i)
    {
      u[]= M*s[];
      u = u>.1; 
      unssd+= u[];
      s[]= M'*u[];
      s = s >0.1;
    }
  return true;
}

macro AddLayersMacro(M, Ph, Vh, ssd, n, unssd)
    unssd = 0;
    Vh u;
    for(j = 0; j < n; ++j) {
        u[] = M * ssd[];
        u = u > .1;
        unssd += u[];
        ssd[] = M' * u[];
        ssd = ssd > 0.1;
    }
    unssd /= n;// EOM

macro partition(meshName, borderName, overlapName, s, D, Vh, P, comm)
        meshName = trunc(overlapName, abs(part - mpiRank(comm)) < 0.1, label = 10);
        mpiBarrier(comm);
        real timerPartition = mpiWtime();
        {
            fespace PhLocal(meshName, P0);
            PhLocal overshoot = hTriangle;
            real max = 2. * overlap * overshoot[].max;
            bbN(meshName, max, overlapName)
        }
        fespace VhGlobal(overlapName, P1);
        PhGlobal supp = abs(part - mpiRank(comm)) < 0.1;
        VhGlobal suppSmooth;
        AddLayersFF(overlapName, supp[], overlap * 2, suppSmooth[]);
        {
            meshN neighbors = trunc(overlapName, suppSmooth > 0.001 && (suppSmooth < 2 * overlap - 0.001));
            fespace Oh(neighbors, P0);
            Oh partOverlap = part;
            findDiff(partOverlap[], arrayIntersection);
        }
        fespace Vh(meshName, P1);
        Vh[int] partitionIntersection(arrayIntersection.n);
        if(s > 1) {
            overlapName = trunc(overlapName, suppSmooth > 0.001, split = s);
            supp = abs(part - mpiRank(comm)) < 0.1;
            suppSmooth = 0;
            AddLayersFF(overlapName, supp[], overlap * 2, suppSmooth[]);
        }
        overlapName = trunc(overlapName, suppSmooth > overlap - 0.999);
        supp = supp;
        suppSmooth = suppSmooth;
        meshName = trunc(overlapName, suppSmooth > overlap + 0.001, label = 10);
        borderName = trunc(overlapName, (suppSmooth > overlap - 0.999) && (suppSmooth < overlap + 0.001), label = 20);
        Vh khi = max(suppSmooth - overlap, 0.) / overlap;
        Vh sum = khi;
        VhGlobal phi = 0;
        varf vM(u, v) = intN(overlapName, qforder = 1)(u * v / measureN);
        matrix M = vM(PhGlobal, VhGlobal);
        for(i = 0; i < arrayIntersection.n; ++i) {
            PhGlobal suppPartition = abs(arrayIntersection[i] - part) < 0.1;
            AddLayersMacro(M, PhGlobal, VhGlobal, suppPartition, overlap, phi[])
            partitionIntersection[numberIntersection] = phi;
            sum[] += partitionIntersection[numberIntersection][];
            arrayIntersection[numberIntersection++] = arrayIntersection[i];
        }

        khi[] = khi[] ./= sum[];
        if(solver != 3 && solver != 5)
            overlapName = minimalMesh;
        else
            overlapName = trunc(meshName, khi < 0.99);
        if(numberIntersection != arrayIntersection.n)
            arrayIntersection.resize(numberIntersection);
        Wh def(func2vec) = init(khi);
        D.resize(Wh.ndof);
        D = func2vec[];
        restrictionIntersection.resize(numberIntersection);
        for(i = 0; i < numberIntersection; ++i) {
            meshN meshIntersection = trunc(meshName, partitionIntersection[i] > 1e-6);
            fespace WhIntersection(meshIntersection, P);
            matrix R = interpolate(WhIntersection, Wh);
            real[int] C;
            int[int] I;
            [I, restrictionIntersection[i], C] = R;
            restrictionIntersection[i].resize(R.nbcoef);
        }
// EOM

macro build(globalTh, Th, ThBorder, ThOverlap, s, D, numberIntersection, arrayIntersection, restrictionIntersection, Wh, P, comm)
meshN ThOverlap, ThBorder;

/*# partition #*/
int[int] arrayIntersection;
int[int][int] restrictionIntersection(0);
real[int] D;

int numberIntersection = 0;
real timing;
{
    timing = mpiWtime();
    if(mpisize > 1) {
        globalTh(ThOverlap);
        fespace PhGlobal(ThOverlap, P0);
        PhGlobal part;
        int[int] balancing(ThOverlap.nt);
        balancing = 0;
        if(mpiRank(comm) == 0) {
            cout.scientific << " --- global mesh of " << ThOverlap.nt << " elements (prior to refinement) generated (in " << mpiWtime() - timing << ") and partitioned with ";
            timing = mpiWtime();
            metisdual(balancing, ThOverlap, mpiSize(comm));
            cout << "Metis";
            cout.scientific << " (in " << mpiWtime() - timing << ")" << endl;
        }
        timing = mpiWtime();
        broadcast(processor(0, comm), balancing);
        fast(part[], balancing);
        partition(Th, ThBorder, ThOverlap, s, D, Vh, P, comm)
    }
    else if(mpisize == 1) {
        globalTh(Th);
        D.resize(Wh.ndof);
        D = 1.;
    }
    mpiBarrier(mpiCommWorld);
    if(mpirank == 0) cout.scientific << " --- partition of unity built (in " << mpiWtime() - timing << ")" << endl;
}
/*# partitionEnd #*/
// EOM

macro assemble(mat, rhs, Wh, Th, ThBorder, Varf)
real[int] rhs;
matrix<real> mat;
{ /* all memory of objects defined between this set of curly brackets
     will be freed when the closing bracket is reached */
    meshN ThAugmented = Th + ThBorder; /* ⠶$\Omega^{\delta + 1}_k = \Omega^\delta_k \cup \left(\Omega^{\delta + 1}_k \setminus \Omega^{\delta}_k\right)$⠶ */
    ThBorder = minimalMesh;
    Varf(vPb, ThAugmented, PhAugmented)
    fespace WhAugmented(ThAugmented, Pk);
    mat = vPb(WhAugmented, WhAugmented/*, solver = CG*/);
    real[int] rhsFull = vPb(0, WhAugmented);
    matrix R = interpolate(Wh, WhAugmented);

    removeDOF(mat, R, rhsFull, rhs);
}
// EOM

macro assembleUnsym(mat, rhs, Wh, Th, ThBorder, Varf)
{
    Varf(vPb, Th, Ph)
    mat = vPb(Wh, Wh);
}
// EOM
