 // other
load "msh3"
load "medit"
load "./real_SuperLU_DIST_FreeFem.dylib"



real ttgv=-1;
string ssparams="nprow=1, npcol="+mpisize; 


int nn=20;
mesh Th2D=square(nn,nn);
int[int] refm=[1,1,2,2,3,3,4,4];
int[int] refu=[0,1];
mesh3 Th=buildlayers(Th2D,nn,zbound=[0.,1.],labelmid=refm,labelup=refu,labeldown=refu);

// to slip integral on each processor 
// set a region number of a processor number 
real ccc = mpisize/real(Th.nt) ;
Th=change(Th,fregion= min(mpisize-1,int(nuTriangle* ccc+1e-10)));
//  end of trick

fespace Vh(Th,P2) ; // P1 FE space
Vh uh,vh,u1=0 ; // unkown and test function.
func f=1 ; // right hand side function
func g=0 ; // boundary condition function
real dt=0.01 ;

real temps=clock();

real time1,time2,time6;
time1=clock();

// compute only on region number = processor number 
varf vlaplace(uh,vh) = // definition de problem
   int3d(Th,mpirank)( uh*vh+ dt*(dx(uh)*dx(vh) + dy(uh)*dy(vh)+ dz(uh)*dz(vh)) ) // bil. form
    + int3d(Th,mpirank)( dt*vh*f) + on(1,2,3,4,uh=g) ;
varf von1(uh,vh) = on(1,2,3,4,uh=1) ;
matrix AA = vlaplace(Vh,Vh,tgv=ttgv) ;
time1=clock()-time1;
// reduce the matrice to get the full matrice 
// warning the tgv number is now mpisize*tgv for B.C.
matrix A; 
time6=clock();
mpiAllReduce(AA,A,mpiCommWorld,mpiSUM);
time6 = clock()-time6;
time2=clock();
set(A,solver=sparsesolver,tgv=ttgv,sparams=ssparams) ; // factorisation
time2=clock()-time2;

real time3=clock();
varf vmasse(u,v) = int3d(Th,mpirank)(u*v);
matrix M = vmasse(Vh,Vh);
time3=clock()-time3;

real [int] b(A.n),bb(A.n) ;
real[int] bcl(A.n) ;
bcl = vlaplace(0,Vh) ; // les termes CL + second membre
real[int] in = von1(0,Vh); in = in ? 0. : 1. ; // un tableau : 1 si interne 0 si frontiere


real time4=0,time5=0;
int imax=10;
for(int i=0 ;i<imax;i++)
{
	if(mpirank==0)
        cout << "  -- time " << (i+1)*dt << endl;

real time4tmp=clock();
bb = M*uh[];
bb = b.*in ; // mise a zero des noeud frontiere
bb += bcl ; // ajout des terme de CL + second membre



time4=time4+(clock()-time4tmp);
real time6tmp=clock();
mpiAllReduce(bb,b,mpiCommWorld,mpiSUM);
time6=time6+(clock()-time6tmp);
real time5tmp=clock();
uh[] = A^-1*b ; // resolution
time5=time5+(clock()-time5tmp);

}
savesol("Heat-Time-"+imax+"-nn-"+nn+"-superludist.sol",Th,uh);
savemesh(Th,"Heat-Time-"+imax+"-nn-"+nn+"-superludist.mesh");
cout << "Time resolution " << clock()-temps << endl;
if( mpirank==0) medit("Heat",Th,uh);
cout << "======================================" << endl;
cout << " CPU TIME :                  " << endl;
cout << " matrix A                    " << time1 << endl;
cout << " factorization               " << time2 << endl;
cout << " mass matrix                 " << time3 << endl;
cout << " RHS  (Matrix vector Product with mass matrix)  " << endl;
cout << "                             " << time4/imax << endl;
cout << " solving                     " << time5/imax  << endl;
cout << " MpiReduce                   " << time6  << endl;
cout << " all                         " << clock()-temps << endl;
cout << "======================================" << endl;




