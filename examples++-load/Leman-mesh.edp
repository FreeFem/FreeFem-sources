load "ppm2rnm"
load "isoline"
bool wait=false;
string leman="lg.pgm";
real AreaLac =  580.03; // Km^2
int nbsmooth = 200; 
int hsize= 1; 
real[int] xx(1),yy(1);
int[int] be(1);
int nc;
{ // build the curve file xy.txt ... 
real[int,int] ff1(leman); // read  image and set to an rect. array 
//  remark (0,0) is the upper, left corner.
int nx = ff1.n, ny=ff1.m; 
// build a cartesain mesh such that the origne is qt the right place.
mesh Th=square(nx-1,ny-1,[(nx-1)*(x),(ny-1)*(1-y)]); 
mesh Tf=Th;
// warning  the numbering is of the vertices (x,y) is 
// given by $  i = x/nx + nx* y/ny $
fespace Vh(Th,P1);
fespace Vf(Th,P1);
Vh f1,f2;
Vh fu,fv;
f1[]=ff1; //  transforme array in finite element function.

f2= min(f1, 0.25);
verbosity=3;
/*
 Usage of isoline
 the named parameter :
 iso=0.25   // value of iso 
 close=1, //   to force to have closing curve ... 
 beginend=be, // begin  and end of curve
 smoothing=.01, //   nb of smoothing process = size^ratio * 0.01 
 where  size is the size of the curve ...  
 ratio=0.5
 file="filename"
 
 ouptut:
  xx, yy  the array of point of the iso value 

a closed curve  number n is

in fortran notation the point of the curve are: 
(xx[i],yy[i], i = i0, i1) 
with :  i0=be[2*n],  i1=be[2*n+1];

*/
nc=isoline(Th,f1,iso=0.25,close=1,xx,yy,beginend=be,smoothing=.01,ratio=0.5); 
verbosity=1; 
}

int bcurve=0,ecurve=0;
for( int i=0;i < be.n;i)
{
int i0=be[i++];
int i1=be[i++]-1; // remove the closure of the curve ... 
if( ecurve -bcurve < i1-i0)
{
  bcurve = i0;
  ecurve = i1;
}
}

real[int,int] Curve(2,ecurve-bcurve);
   Curve(0,:) = xx(bcurve:ecurve-1);
   Curve(1,:) = yy(bcurve:ecurve-1);


//  Smoothing the curve  
if(0)
{
  real[int,int] CurveO(Curve);
  int nC=Curve.m;
  // lissage 
  real[int,int] P(Curve),PP(Curve);
  real c1=1, c0=4, ct=2*c1+c0;
  c1/=ct;
  c0/=ct;
  for(int step=0;step<nbsmooth ;++step)
    {
      for(int j=0;j<nC;++j)
      {	
	int j0= (j+ nC-1)%nC;
	int j1= (j+ 1)%nC;
	P(0,j) = c0*PP(0,j) +c1*PP(0,j0) +c1*PP(0,j1);
	P(1,j) = c0*PP(1,j) +c1*PP(1,j0) +c1*PP(1,j1);
      }
      PP=P;
    }
  Curve=PP;
  plot([Curve(0,:),Curve(1,:)],[CurveO(0,:),CurveO(1,:)], wait=1);
}
// end smoothing the curve ....

border G(t=0,Curve.m) 
{    
  int n= Curve.m;
  int i=int(t), i1= (i+1)%n;
  real t1=t-i, t0=1-t1;
  i = i%n; 
  assert(t1>=0 && t1<1.);
  assert(i>=0 && i < n ) ;
  assert(i1>=0 && i1 < n ) ;

  x = Curve(0,i)*t0 + Curve(0,i1)*t1;   
  y = Curve(1,i)*t0 + Curve(1,i1)*t1;  
  label=1; 
} 

plot(G(100),wait=1); 
mesh Th=buildmesh(G(-500));
plot(Th,wait=1);

real scale = sqrt(AreaLac/Th.area);
Th=movemesh(Th,[x*scale,y*scale]);
cout << " Th.area = " << Th.area << " Km^2 " << " == " << AreaLac <<  "   Km^2 " << endl ;
int Thnbvx=AreaLac/(hsize*hsize/5.)+1000;

Th=adaptmesh(Th,hsize,IsMetric=1,nbvx=Thnbvx,errg=5);
Th=adaptmesh(Th,hsize,IsMetric=1,nbvx=Thnbvx,errg=5);
Th=adaptmesh(Th,hsize,IsMetric=1,nbvx=Thnbvx,errg=5);
Th=adaptmesh(Th,hsize,IsMetric=1,nbvx=Thnbvx,errg=5);
 // end of build 2d mesh 

plot(Th,wait=1);
