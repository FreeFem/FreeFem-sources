// (Inspired to V. Dolean, 16 January 2014)

/*# debutVarProb #*/

load "medit"
load "tetgen"
load "iovtk"
load "Element_Mixte3d"
/*# debutMeshData #*/
// Mesh data
int nloc = 4;        // local number of dof in one direction
real a = 0.00254, b = 0.00127, c = 0.01;    // dimensions of the parallelipiped
//real a = 0.00254, b = 0.00127, c = 0.005;    // dimensions of the parallelipiped
int mx, my, mz;      // servono per decidere il numero di punti nelle 3 dimensioni
mx = a/min(a,b);
my = b/min(a,b);
mz = c/min(a,b);

// Build the mesh
include "cube.idp"
int[int] NN = [mx*nloc, my*nloc, mz*nloc];
int guide = 1, in = 2, out = 3;             // labels for the waveguide
real [int,int] BB = [[0,a],[0,b],[0,c]];    // bounding box
int [int,int] L = [[guide,guide],[guide,guide],[in,out]];  // labels of the faces
mesh3 Th = Cube(NN,BB,L);                   // build the mesh of the parallelipiped
//medit("mesh", Th);                        // draw the mesh
/*# finMeshData #*/


/*# debutSolData #*/
real f = 94*10^9;                  // frequence (penso che omega=2*pi*f)
real er = 1;                       // dielectric constant
real c0 = 299792458;               // speed of light
real k = 2*pi*f*sqrt(er)/c0;       // e' il numero d'onda se mu_r=1 //(?)
int m = 1, n = 0;
real beta = sqrt(k^2-(m*pi/a)^2-(n*pi/b)^2);      // viene dalla dispersion relation
real Z = sqrt(er)*120*pi;                         /*??*/
real fc = sqrt((m/a)^2+(n/b)^2)*c0/(2*sqrt(er));  
// fc: a parte il 2, e' la frequenza di coupure -> l'onda si propaga per f>fc 
// (vedi MEDIMAX_14_11_13_guide_onde.pdf, cmq non usata)

real ukb = 1/(k^2-beta^2);
func expbz = exp(-1i*beta*z);
func ExTE = (1i*k*Z)*ukb*(n*pi)/b*cos(m*pi*x/a)*sin(n*pi*y/b)*expbz;  // ricorda k*Z = mu*omega
func EyTE = -(1i*k*Z)*ukb*(m*pi)/a*sin(m*pi*x/a)*cos(n*pi*y/b)*expbz;
// For the incident condition:
func Gix = -2*1i*beta*ExTE; // perche' - ??                       
func Giy = -2*1i*beta*EyTE; // perche' - ??    
func Giz = 0;
// (vedi WaveguideEvidenziato.pdf, soprattutto paragrafo 2.3, li' sol esatta vuole Gi con + !)
/*# finSolData #*/


/*# debutFEspace #*/
// Finite element space

fespace Nh(Th, Edge13d);              // Edge13d: my edge finite elements of degree 2
Nh<complex> [Ex,Ey,Ez], [vx,vy,vz];   // define the vector field and the test function

//  Macros: Curl and cross product by the normal
macro Curl(ux,uy,uz) [dy(uz)-dz(uy),dz(ux)-dx(uz),dx(uy)-dy(ux)] // EOM
macro Nvec(ux,uy,uz) [uy*N.z-uz*N.y,uz*N.x-ux*N.z,ux*N.y-uy*N.x] // EOM
macro Curlabs(ux,uy,uz) [abs(dy(uz)-dz(uy)),abs(dz(ux)-dx(uz)),abs(dx(uy)-dy(ux))] //
/*# finFEspace #*/


// To use the sparsesolver of MUMPS (because with the one of UMFPACK out of memory): 
//load "MUMPS_FreeFem" // ho copiato MUMPS_FreeFemError.dylib nella cartella (altrimenti error load ?)
/* MA
//*** The MPI_Comm_rank() function was called before MPI_INIT was invoked.
//*** This is disallowed by the MPI standard.
//*** Your MPI job will now abort. 
Leggere meglio manuale
*/ 

// Definition of the problem to solve
// (sigma = 0, here k is the wavenumber) 
//  -k^2*E + curl(curl E) = 0     in Omega
//  E x n = 0                   on x = 0, x = a, y = 0, y = b
//  Curl(E) x n + i*beta n x (E x n) = Ginc    on z = 0
//  Curl(E) x n + i*beta n x (E x n) = 0       on z = c

//savevtk("meshCube.vtk", Th);

problem waveguide([Ex,Ey,Ez], [vx,vy,vz], solver=sparsesolver) =
                  int3d(Th)(Curl(Ex,Ey,Ez)'*Curl(vx,vy,vz))
                - int3d(Th)(k^2*[Ex,Ey,Ez]'*[vx,vy,vz])
                + int2d(Th,in,out)(1i*beta*Nvec(Ex,Ey,Ez)'*Nvec(vx,vy,vz))
                + int2d(Th,in)([Gix,Giy,Giz]'*[vx,vy,vz])   
                + on(guide,Ex=0,Ey=0,Ez=0);
// Sembra con tutte e 3 le scritture qui sotto dia stesso risultato!? (anno scorso domanda 2d?)                
//+ int2d(Th,in)([Gix,Giy,Giz]'*[vx,vy,vz])  
//+ int2d(Th,in)([vx,vy,vz]'*[Gix,Giy,Giz]) 
//+ int2d(Th,in)(Gix*vx + Giy*vy + Giz*vz)            
waveguide;  // solve the problem
/*# finVarProb #*/

/*# debutCompErr #*/
Nh<complex> [Errx,Erry,Errz];
Nh<complex> [Eex,Eey,Eez] = [ExTE,EyTE,0]; // Sol. Esatta
[Errx,Erry,Errz] = [Eex,Eey,Eez]-[Ex,Ey,Ez];

// Norm of the exact solution
real Hcurlerrsqex, Hcurlerrex, L2errsqex, L2errex;
L2errsqex = int3d(Th)(abs(Eex)^2+abs(Eey)^2+abs(Eez)^2);
Hcurlerrsqex = int3d(Th)(Curlabs(Eex,Eey,Eez)'*Curlabs(Eex,Eey,Eez))+L2errsqex;
Hcurlerrex = sqrt(Hcurlerrsqex) ;
L2errex = sqrt(L2errsqex) ;
cout << "Norme della sol Esatta" << endl;
cout << "Hcurl = " << Hcurlerrex << endl;
cout << "L2 = " << L2errex << endl;

// Norm of the error
real Hcurlerrsq, Hcurlerr, L2errsq, L2err;
L2errsq = int3d(Th)(abs(Errx)^2+abs(Erry)^2+abs(Errz)^2);
Hcurlerrsq = int3d(Th)(Curlabs(Errx,Erry,Errz)'*Curlabs(Errx,Erry,Errz))+L2errsq;
Hcurlerr = sqrt(Hcurlerrsq) ;
L2err = sqrt(L2errsq) ;
cout << "Norme dell'errore" << endl;
cout << "Hcurl = " << Hcurlerr << endl;
cout << "L2 = " << L2err << endl;

// Relative errors
cout << "Error-L2 relative norm  = "<< L2err/L2errex <<" Error-Hcurl relative norm  = "<< Hcurlerr/Hcurlerrex<<endl;
/*# finCompErr #*/

/*# debutVtk #*/
int[int] ffordervel = [0]; // 0 save a cell value, 1 save point value ??
savevtk("Enum.vtk",Th,[real(Ex),real(Ey),real(Ez)],order=ffordervel, dataname="Solution");
savevtk("Eexact.vtk",Th,[real(Eex),real(Eey),real(Eez)],order=ffordervel, dataname="Exact sol");
/*# finVtk #*/



