/*
time convention exp(-iwt).
solving EFIE for Maxwell with a incoming plane wave.

The polarization is such that:
\vec{k} = ( 0, 0, -k_z)^t (the wave vector), E_{inc}  =( E_x, 0, 0)^t \quad \mathtt{and}  \quad  H_{inc}=( 0, H_y, 0)^t

mpirun -np 2 ../../src/mpi/FreeFem++-mpi Maxwell_EFIE_sphere.edp -wg -frequency 6e8
*/

//load "msh3"
load "bem"
load "PETSc-complex"
include "getARGV.idp"


real c0= 299792458;
real f = getARGV("-frequency",6.e+8);
complex k = 2*pi*f/c0;
real mu0 = 4*pi*1.e-7;
real epsilon0 = 1./(c0*c0*mu0);
real Z0 = 119.9169832*pi;
real lambda = c0/f;

cout << "wave number   = " <<lambda << endl;
cout << "vacuum impedance = " <<Z0 << endl;
cout << "frequency = " << f << endl;

// definition of the surface mesh 
include "MeshSurface.idp"
real radius = 1;
int nlambda = 4;                // nuimber of wave lenght 
real hs = lambda/(1.0*nlambda); // mesh size on the sphere
meshS ThS =Sphere(radius,hs,7,1); 

// definition of the mesh for the potentiel view

meshS ThOut; 
{
    real Rin = radius*1.05;
    real Rout = radius*1.5;

    int Nin = 120;
    int Nout = Nin*int(Rout/Rin+1);

    border circleS(t=0, 2*pi){x=Rin*cos(t); y=Rin*sin(t); z=0;}
    border circleOut(t=0, 2*pi){x=Rout*cos(t); y=Rout*sin(t); z=0;}
    mesh Thtmp = buildmesh( circleS(-Nin) + circleOut(Nout) );

    ThOut = movemesh23(Thtmp, transfo=[x,y,0]);
}

// macro div(ux,uy,uz) ( dx(ux)+dy(uy)+dz(uz) ) // EOM

// definition of the wave plane

// case dir =-z
real theta = -pi; 
real phi   = pi;

real[int] dir(3), u(3);
dir[0] = sin(theta)*cos(phi);  u[0] =  cos(theta)*cos(phi);
dir[1] = sin(theta)*sin(phi);  u[1] =  cos(theta)*sin(phi);
dir[2] = cos(theta);           u[2] = -sin(theta);

// ========
//   E_inc = \vec{u}*exp(i*\vec{k}.\vec{x})
//
//   where \vec{k} =  k*\vec{dir}
// ========

func uinc = exp(1i*k*(x*dir[0]+y*dir[1]+z*dir[2]));
func fincx = u[0]*uinc;
func fincy = u[1]*uinc;
func fincz = u[2]*uinc;
// ================================

// def of fespace
fespace Uh3(ThS,RT0S);

Uh3<complex> [Fincx,Fincy,Fincz] = [uinc*u[0],uinc*u[1],uinc*u[2]]; // wave plane discretization
Uh3<complex> [ucx,ucy,ucz];  // magnetic current
Uh3<complex> [rhsx,rhsy,rhsz]; // rhs


// construction of BEM H-matrix for EFIE operator

varf vk([u1,u2,u3],[v1,v2,v3])=int2dx2d(ThS)(ThS)(BEM(BemKernel("MA_SL",k=k),[u1,u2,u3],[v1,v2,v3])); //-int2d(ThS)( [v1,v2,v3]'*[Fincx,Fincy,Fincz] );   
HMatrix<complex> H = vk(Uh3,Uh3,eta=10,eps=1e-2,minclustersize=10,maxblocksize=1000000,nbiter=4000);

if (mpirank == 0) cout << H.infos << endl;
display(H);



// computation of rhs of EFIE 

varf vrhs([u1,u2,u3],[v1,v2,v3]) = -int2d(ThS)( [v1,v2,v3]'*[Fincx,Fincy,Fincz] );
rhsx[] = vrhs(0,Uh3);

// solving magnetic current
ucx[] = H^-1*rhsx[];


fespace UhOutV(ThOut,[P1,P1,P1]);
fespace UhOut(ThOut,P1);

cout << "Uh3.ndof    =" << Uh3.ndof << endl;
cout << "UhOutV.ndof =" << UhOutV.ndof << endl;
cout << "ThOut.nv   =" << ThOut.nv << endl;

varf vpMa1([u1,u2,u3],[v1,v2,v3])=int2d(ThS)(POT(BemPotential("MA_SL",k=k),[u1,u2,u3],[v1,v2,v3]));
HMatrix<complex> B0 = vpMa1(Uh3,UhOutV,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);

if (mpirank == 0) cout << B0.infos << endl;
display(B0);


// definition of the scattered field E
UhOutV<complex> [Ex, Ey, Ez];

// compute the scattered electromagnetic field
Ex[]  = B0*ucx[];

// save the real part of scattered electromagnetic field
UhOut rExScat = real(Ex);

// compute the real part of total electromagnetic field
UhOut vr = sqrt(real(Ex)^2 + real(Ey)^2 + real(Ez)^2 );

plot(vr, dim=2, fill=1, value=1, nbiso=20, cmm="|E-real|_L2");

// compute the real part of total electromagnetic field
UhOut rEx = real(Ex)+real(fincx);
UhOut rEy = real(Ey)+real(fincy);
UhOut rEz = real(Ez)+real(fincz);

plot(rEx, dim=2, fill=1, value=1, nbiso=20, cmm="real(Ex) total");
plot(rExScat, dim=2, fill=1, value=1, nbiso=20, cmm="real(ExScat)");
plot(rEy, dim=2, fill=1, value=1, nbiso=20, cmm="real(Ey) total");
plot(rEz, dim=2, fill=1, value=1, nbiso=20, cmm="real(Ez) total");

