/*
solving stokes problem in 2 dimension:
-Delta u + Grad(p) = (f1,f2) in \Omega 
 div(u) = 0    in \Omega
 u = (g1,g2)   on \gamma 
*/
load "bem"
load "MUMPS"

macro grad(u) [dx(u),dy(u)]//
macro Grad(u1,u2) [ grad(u1), grad(u2)]//
macro div(u1,u2) (dx(u1)+dy(u2))//

// definition of the boundary condition 
func g1 = sin(x)*cos(y);
func g2 = -cos(x)*sin(y);

// defintion of the right hand side
func f1 = 0;
func f2 = -4*cos(x)*sin(y);

int nn = 40; // number of edge in each direction
mesh Th=square(nn,nn,[2*pi*x,2*pi*y],flags=3);
mesh ThP=Th;                    // Pressure mesh
mesh ThU=trunc(ThP,1,split=2);  // Velocity mesh

fespace Uh(ThU,[P1,P1]);
fespace Ph(ThP,P1);

Uh [u1,u2],[v1,v2];
Ph p,q;

// definition of varf for the matrix
varf vA11( [u1,u2], [v1,v2] ) = int2d(ThU)( (Grad(u1,u2):Grad(v1,v2)) ) 
+ on(1,2,3,4,u1=g1,u2=g2);
varf vA12( [u1,u2],     [q] ) = int2d(ThU)( - div(u1,u2)*q );
varf vA21( [p], [v1,v2] ) = int2d(ThU)( - div(v1,v2)*p );
varf vA22( [p],     [q] ) = int2d(ThP)( -1e-10*p*q );

matrix A11 = vA11( Uh, Uh );
matrix A21 = vA12( Uh, Ph ); 
matrix A12 = vA21( Ph, Uh ); 
matrix A22 = vA22( Ph, Ph ); 

matrix A = [[A11, A12],[A21, A22]];
set(A,solver=sparsesolver);

// definition of the rhs
varf rhs1( [u1,u2], [v1,v2] ) = int2d(ThU)( [f1,f2]'*[v1,v2] ) 
+ on(1,2,3,4,u1=g1,u2=g2);
real[int] b1= rhs1( 0, Uh );
real[int] b2(Ph.ndof); b2=0;
real[int] rhs(Uh.ndof+Ph.ndof);
rhs = [ b1, b2];

real[int] sol = A^(-1)*rhs;
[u1[],p[]]=sol; // dispatch the solution

plot( u1, cmm="u1" );
plot( u2, cmm="u2");
plot( p,  cmm="p" );