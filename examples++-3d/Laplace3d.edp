// build de mesh of a Sphere
// -------------------------- 
load "msh3"
load "medit"
int nn=8;
mesh Th2=square(nn,nn);
fespace Vh2(Th2,P2);
Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
real zmin=0,zmax=1;
mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],
  reffacemid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);


fespace Vh(Th,P23d);

func ue =   2*x*x + 3*y*y + 4*z*z + 5*x*y+6*x*z+1;
func uex=   4*x+  5*y+6*z;
func uey=   6*y + 5*x;
func uez=   8*z +6*x;
func f= -18. ;
Vh uhe = ue; // bug ..

cout << " uhe min:  " << uhe[].min << " max:" << uhe[].max << endl;

Vh u,v;

macro Grad3(u) [dx(u),dy(u),dz(u)]  // EOM

problem Lap3d(u,v,solver=CG)
  =
  int3d(Th)(Grad3(v)' *Grad3(u)) 
   +int2d(Th)(u*v)
  - int3d(Th)(f*v) 

//  + int2d(Th,2) (ue + uez*v ) //(uex*N.x +uey*N.y +uez*N.z)*v )
  + int2d(Th,2) ( ue*v+ (uex*N.x +uey*N.y +uez*N.z)*v )
  + on(1,2,u=ue);
Lap3d;
cout << " u min::   " << u[]. min << "  max: " << u[].max << endl;
real err= int3d(Th)( square(u-ue) );
cout << int3d(Th)(1.) << " = " << Th.mesure << endl;
Vh d= ue-u;
cout <<  " err = " << err <<  " diff l^\intfy = " << d[].linfty << endl;
assert(err < 1e-9);
medit(" Sol ", Th, u ,order=1);//  to see the sol in P1 
