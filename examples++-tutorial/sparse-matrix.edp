//  sparse matrix test  ---
// example of the new matrix feature in version 1.40
// -------------------------------------------------
mesh  TH = square(3,4);
mesh  th = square(2,3);
mesh  Th = square(4,4);


fespace VH(TH,P1);
fespace Vh(th,P1);
fespace Wh(Th,P1);

matrix B= interplotematrix(VH,Vh);  // build interpolation matrix Vh->Vh 
matrix BB= interplotematrix(Wh,Vh);  // build interpolation matrix
varf vA(u,v) = int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v))+ int1d(Th)(u*v); 
matrix A=vA(Wh,Wh);
Vh ml=0;
varf vML(u,v) = int2d(th)(1*v);
ml[]=vML(0,Vh); // build the P1 mass lump of P1
cout << ml[] << endl;
matrix ML(ml[]); // matrix diagonal
cout << "ML="<<ML << endl;
cout << "B="<<B << endl;
matrix BML=B*ML;
matrix tB=B';        // transpose 
cout << "tB=" << tB << endl;
matrix MLtB=ML'*B'; // 

cout << "BML="<<BML << endl;
cout << "MLtB=" << MLtB << endl;

// WARNING if UMFPACK is not install
// the UMFPACK solver is replace by LU 
//  but LU need skyline matrix 
if(HaveUMFPACK)
  set(A,solver=UMFPACK); // set a solver 
else 
  set(A,solver=GMRES); // set a solver 
  VH uH=0;
  Vh uh=x+y;
  uH[]= B*uh[];
  plot(uH,wait=1);
  matrix BtA = BB'*A;
  matrix BtAB = BtA*BB;
if(HaveUMFPACK)  
  set(BtAB,solver=UMFPACK);  
else 
  set(BtAB,solver=GMRES);  
  Vh ff=1;
  Vh xx;
  cout << " ------ " << endl;
  
  xx[]=BtAB^-1*ff[];
  cout << " ------ " << endl;
  xx[]=BtAB^-1*ff[];
  cout << " ------ " << endl;
  plot(xx, wait=1);

{
  int N=10;
  real [int,int] A(N,N);
  real [int] a(N),b(N);
  A =0;
  for (int i=0;i<N;i++)
    {
      A(i,i)=1+i;
      if(i+1 < N)    A(i,i+1)=-i;
      a[i]=i;
    }
  b=A*b;
  cout << "xxxx\n"; 
  matrix sparseA=A;
  cout << sparseA << endl;
  sparseA = 2*sparseA+sparseA;
  sparseA = 4*sparseA+sparseA*5; //  * 27
  matrix sparseB=sparseA+sparseA+sparseA; ;
  cout << sparseA << endl;
  cout << sparseB << endl; // *81 
  cout << "sparseB = " << sparseB(0,0) << endl;
}
