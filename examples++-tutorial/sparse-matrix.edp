//  sparse matrix test  ---
// example of the new matrix feature in version 1.40
// -------------------------------------------------
mesh  TH = square(3,4);
mesh  th = square(2,3);
mesh  Th = square(4,4);


fespace VH(TH,P1);
fespace Vh(th,P1);
fespace Wh(Th,P1);

matrix B= interpolate(VH,Vh);  // build interpolation matrix Vh->Vh 
matrix BB= interpolate(Wh,Vh);  // build interpolation matrix
varf vA(u,v) = int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v))+ int1d(Th)(u*v); 
matrix A=vA(Wh,Wh);
Vh ml=0;
varf vML(u,v) = int2d(th)(1*v);
ml[]=vML(0,Vh); // build the P1 mass lump of P1
cout << ml[] << endl;
matrix ML(ml[]); // matrix diagonal
cout << "ML="<<ML << endl;
cout << "B="<<B << endl;
matrix BML=B*ML;
matrix tB=B';        // transpose 
cout << "tB=" << tB << endl;
matrix MLtB=ML'*B'; // 

cout << "BML="<<BML << endl;
cout << "MLtB=" << MLtB << endl;

// WARNING if UMFPACK is not install
// the UMFPACK solver is replace by LU 
//  but LU need skyline matrix 
if(HaveUMFPACK)
  set(A,solver=UMFPACK); // set a solver 
else 
  set(A,solver=GMRES); // set a solver 
  VH uH=0;
  Vh uh=x+y;
  uH[]= B*uh[];
  plot(uH,wait=1);
  matrix BtA = BB'*A;
  matrix BtAB = BtA*BB;
if(HaveUMFPACK)  
  set(BtAB,solver=UMFPACK);  
else 
  set(BtAB,solver=GMRES);  
  Vh ff=1;
  Vh xx;
  cout << " ------ " << endl;
  
  xx[]=BtAB^-1*ff[];
  cout << " ------ " << endl;
  xx[]=BtAB^-1*ff[];
  cout << " ------ " << endl;
  plot(xx, wait=1);

{
  int N=10;
  real [int,int] A(N,N);
  real [int] a(N),b(N),c(N);
  A =0;
  for (int i=0;i<N;i++)
    {
      A(i,i)=1+i;
      if(i+1 < N)    A(i,i+1)=-i;
      a[i]=i;
    }
  b=A*a;
  c=-9;
  cout << "xxxx\n"; 
  matrix sparseA=A;
  cout << sparseA << endl;
  sparseA = 2*sparseA+sparseA;
  sparseA = 4*sparseA+sparseA*5; //  * 27
  matrix sparseB=sparseA+sparseA+sparseA; ;
  cout << sparseA << endl;
  cout << sparseB << endl; // *81 
  cout << "sparseB = " << sparseB(0,0) << endl;
  cout << " -------- block matrix \n " << endl;
  matrix B = [ [sparseA, 0 , sparseA ], [ 0, sparseA , 0 ] , [0, 0, sparseB' ]];
  real[int] x([a,b,c]); //  construct the block vector x form a,b,c,
  //  where the size is  sum of size of a,b,c, 
  x=[a,b,c]; // set x to to the block vector (the vector x is  resize if it necessary
  cout << " abc =" << a[2] << " " << b[3] << " "<< c[4] << endl;
  cout << " xxx =" << x[2] << " " << x[3+N] << " "<< x[4+N*2] << endl;
  x = x*10;
  [a,b,c]=x; // set the block vector a,b,c  from concecutive part of  x;
  cout << " abc*10 == "  << a[2] << " " << b[3] << " "<< c[4] << endl;


 // remark  the size of sum of size must be equal to the size of x.  
  cout << " B = " << B << endl; 
  cout << B(8,29) << " ===  " <<  sparseA(8,9) << endl;
  cout << B(28,27)
<< " ===  " <<  sparseB(7,8) << endl;

  cout << " -------- block matrix \n " << endl;
}
//  build FE  matrice with differente meshes (here 3) 
varf vM(u,v)=int1d(Th,qforder=1)(u*v);
matrix MM=vM(Vh,VH);
cout << MM << endl;
Vh unVh=0,wVh=0;
VH unVH=0,wVH=0;
unVh[]=1;
unVH[]=1;
wVh[] = MM' * unVH[] ; 
wVH[] = MM * unVh[] ; 

cout << "wWh : " << wVh[] << endl;
cout <<" wVH : " << wVH[] << endl;