int err=0;
mesh Th=square(50,50,[3*x-1.5,3*y-1.5]);
func r = sqrt(x*x +y*y);
// wrong ...
real lc ;
verbosity=10;
lc = int1d(Th,levelset=r-1.)(1.) ; 
cout << " len of the level set = " <<  lc  << " =  2pi " << 2*pi ;
cout << ", Ok = " << (abs(lc-2*pi) < 1e-1) << endl; 
if( abs(lc-2*pi) > 1e-1) err++;
fespace Vh(Th,P1);
// test linear and bilinear ... 
varf vl(u,v) = int1d(Th,levelset=r-1.)(v) + int1d(Th,levelset=r-1.)(u*v);
real[int] vv=vl(0,Vh);

cout << " len of the level set (varf linear ) = " <<  (lc=vv.sum)  << "=  2pi " << 2*pi ;
cout  << ", Ok = " << (abs(lc-2*pi) < 1e-1) << endl;
if( abs(lc-2*pi) > 1e-1) err++; 
real[int]  one(Vh.ndof); 
one=1.;
matrix VV=vl(Vh,Vh); // no build of matrix with levelset
vv = VV*one;
cout << " len of the level set (varf bilinear ) = " <<  (lc=vv.sum)  << "=  2pi " << 2*pi;
cout << ", Ok = " << (abs(lc-2*pi) < 1e-1) << endl;; 
if( abs(lc-2*pi) > 1e-1) err++;

if(0) 
{// test on diff mesh  not wet implemented (FH  frev 2014)
mesh Th1=square(10,10,[3*x-1.5,3*y-1.5]);
mesh Th2=square(20,20,[3*x-1.5,3*y-1.5]);
fespace Vh1(Th1,P1);
fespace Vh2(Th2,P1);

varf vl(u,v) = int1d(Th,levelset=r-1.)(v) + int1d(Th,levelset=r-1.)(u*v);
real[int] vv=vl(0,Vh);

cout << " len of the level set (varf linear ) = " <<  (lc=vv.sum)  << "=  2pi " << 2*pi ;
cout  << ", Ok = " << (abs(lc-2*pi) < 1e-1) << endl;
if( abs(lc-2*pi) > 1e-1) err++; 
real[int]  one(Vh1.ndof); 
one=1.;
// sorry not implemented to day ... FH 
matrix VV=vl(Vh1,Vh2); // no build of matrix with levelset 
vv = VV*one;
cout << " len of the level set (varf bilinear ) = " <<  (lc=vv.sum)  << "=  2pi " << 2*pi;
cout << ", Ok = " << (abs(lc-2*pi) < 1e-1) << endl;; 
if( abs(lc-2*pi) > 1e-1) err++;

}
cout << " Nb err " << err << endl;
assert(err==0);

