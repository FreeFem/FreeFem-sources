\documentclass[twoside]{book}
\newif\ifpdf
\ifx\pdfoutput\undefined
\pdffalse % we are not running PDFLaTeX
\else
\pdfoutput=1 % we are running PDFLaTeX
\pdftrue
\fi
%\usepackage{times}
%\usepackage{amsmath}
\usepackage{calc}
\usepackage[latin1]{inputenc}
\usepackage{FFF}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{FFF}
\usepackage{makeidx}
\usepackage{color}
\usepackage{multicol}
\usepackage{graphicx}
%\usepackage{dessin}
\topmargin -1.54cm
\oddsidemargin 0cm   %marge a 2 cm
\evensidemargin 0cm  %marge a 2 cm
\newcommand{\indente}{\hbox to \parindent {\hss}}
\parindent 0cm
\headsep 0.5cm
\topskip .5cm
\footskip 1cm
\headheight 1.0cm
\textwidth  16.5cm
%  \parindent 0cm
\textheight 24cm
\def\freefempp{\texttt{freefem++ }}
\def\textRed{\color{red}}
\def\textBlack{\color{black}}
\def\Blue#1{\textcolor{blue}{#1}}
\def\Black#1{\textcolor{black}{#1}}
\def\Red#1{\textcolor{red}{#1}}
\def\Magenta#1{\textcolor{magenta}{#1}}
\def\hin{\hbox{ in }}
\def\hon{\hbox{ on }}
\def\Cpp{\texttt{C++~}}
\def\R{\mathrm{I\!R}}
\def\example{\textbf{Example:}}
\def\eq#1{\Blue{\[#1\]}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\itemtt[#1]{ \item[\texttt{#1}]}
\def\plot[#1]#2#3{\begin{figure}[hbt]
\begin{center}
    \includegraphics*[#1]{#2}
\end{center}
\caption{\label{#2} #3}
\end{figure}
}
\def\Ostream{\texttt{ostream}}
\def\Istream{\texttt{istream}}
\def\Bool{\texttt{bool}}
\def\Real{\texttt{real}}
\def\Int{\texttt{int}}
\def\vecttwo#1#2{\left|\begin{smallmatrix} #1 \\ #2 \end{smallmatrix}\right.}
\def\vdeux(#1,#2){\left|\begin{smallmatrix} #1 \\ #2 \end{smallmatrix}\right.}
\def\HLINE#1{\hbox to \hsize {#1}}
\def\twoplot[#1]#2#3#4#5{
\begin{figure}[hbt]
\begin{multicols}{2}
\begin{center}
    \includegraphics*[#1]{#2}
    \caption{\label{#2} #4}
\end{center}
\begin{center}
    \includegraphics*[#1]{#3}
    \caption{\label{#3} #5}
\end{center}
\end{multicols}
\end{figure}
}% end twoplot macro
\newtheorem{remark}{\textbf{Remark}}
\newtheorem{bug}{\textbf{Bug:}}
\newtheorem{proposition}{\textbf{Proposition}}
\newtheorem{algorithm}{\textbf{Algorithm}}
\newenvironment{ttlist}
   {\begin{list}{}{\renewcommand{\makelabel}[1]{\texttt{##1}\hfil}%
        \setlength{\labelwidth}{3cm}
        \setlength{\leftmargin}{\labelwidth+\labelsep}
    }}%
   {\end{list}}


\begin{document}
\graphicspath{{./}{plots/}}
\ifpdf
\DeclareGraphicsExtensions{.pdf, .jpg, .tif}
\else
\DeclareGraphicsExtensions{.eps,.ps, .jpg}
\fi

\let\subsubsection\subsection
\let\subsection\section
\let\section\chapter

A first test of parallisation of \texttt{FreeFem++} is make under mpi.
We add three word in the language:
\begin{description}
\itemtt[mpisize] The total number of  processes\index{mpisize}
\itemtt[mpirank]  the number of my current process in $\{0,..., mpisize-1\}$.\index{mpirank}
\itemtt [processor] a function to set the possessor to send or receive data 
\itemtt [broadcast] a function to broadcast from a processor to all other a data \index{broadcast}\index{processor}
\bFF
    processor(10) << a ; // send to the process 10 the data a;
    processor(10) >> a ; // receive from the process 10 the data a;

\eFF
\end{description}
\subsection{Schwarz in parallel}
If exemple is just the rewritting of exemple \texttt{schwarz-overlap} 
in section \ref{schwarz-overlap}.\index{schwarz}\index{broadcast}\index{processor}
\index{array!mesh}

How to use 
\bFF
[examples++-mpi] hecht%lamboot

LAM 6.5.9/MPI 2 C++/ROMIO - Indiana University


[examples++-mpi] hecht% mpirun -np 2 FreeFem++-mpi schwarz-c.edp
\eFF

\bFF
//  a new coding verion c,   methode de schwarz in parallele \hfilll
// with 2 proc. \hfilll
//  ------------------------------- \hfilll
// F.Hecht december 2003 \hfilll
// ---------------------------------- \hfilll
//  to test the broadcast instruction \hfilll
//  and array of mesh  \hfilll
//  add add the stop test \hfilll
//  --------------------------------- \hfilll

@if ( mpisize != 2 ) {
  @cout << " sorry number of processeur !=2 " << endl;
  exit(1);}
@verbosity=3;
@real pi=4*atan(1);
@int inside = 2;
@int outside = 1;
@border a(t=1,2){x=t;y=0;label=outside;};
@border b(t=0,1){x=2;y=t;label=outside;};
@border c(t=2,0){x=t ;y=1;label=outside;};
@border d(t=1,0){x = 1-t; y = t;label=inside;};
@border e(t=0, pi/2){ x= cos(t); y = sin(t);label=inside;};
@border e1(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=outside;}; 
@int n=4;
@mesh[int]  Th(mpisize);
@if (mpirank == 0) 
 Th[0] = buildmesh( a(5*n) + b(5*n) + c(10*n) + d(5*n));
@else
 Th[1] = buildmesh ( e(5*n) + e1(25*n) );

@broadcast(@processor(0),Th[0]);
@broadcast(@processor(1),Th[1]);

@fespace Vh(Th[mpirank],P1);
@fespace Vhother(Th[1-mpirank],P1);

Vh u=0,v;
Vhother U=0;
@int i=0;

@problem pb(u,v,init=i,solver=Cholesky) = 
    @int2d(Th[mpirank])( dx(u)*dx(v)+dy(u)*dy(v) )
  - @int2d(Th[mpirank])( v) 
  + @on(inside,u = U)  +  @on(outside,u= U ) ;

@for ( i=0 ;i< 20; i++) 
{ 
  @cout << mpirank << " looP " << i << endl;
   pb; 
   //  send u  to the other proc, receive in U
   @processor(1-mpirank) << u[];   @processor(1-mpirank) >> U[];
   @real err0,err1;
   err0 = int1d(Th[mpirank],inside)(square(U-u)) ;
   // send err0  to the other proc, receive in err1
   @processor(1-mpirank)<<err0;   @processor(1-mpirank)>>err1;
   @real err= sqrt(err0+err1);
   @cout <<" err = " << err << " err0 = " << err0 << ", err1 = " << err1 << endl;
   @if(err<1e-3) @break;
};
@if (mpirank==0)  
    @plot(u,U,ps="uU.eps");

\eFF

\include{docGUI}

\section{ Mesh Files}
 \def\Chars#1{{\tt (C*)}  #1}
 \def\Char#1{{\tt (C)}  #1}
 \def\Int#1{ {\tt(I)} #1}
 \def\Real#1{{\tt(R)} #1}
 \def\Bool#1{{\tt(B)} #1}
 \def\Vertex#1{{{\tt @@Vertex}#1}}
 \def\Edge#1{{{\tt @@Edge}#1}}
 \def\Triangle#1{{{\tt @@Tria}#1}}
 \def\Quadrangle#1{{{\tt @@Quad}#1}}
 \def\Tetrahedron#1{{{\tt @@Tetra}#1}}
 \def\Hexahedron#1{{{\tt @@Hexa}#1}}
 \def\Pentahedron#1{{{\tt @@Penta}#1}}
 \def\Loop#1#2{{\bf\Large(}\,#1\,{\bf\Large{,\,\,}}\,#2\,{\bf\Large)}}
 \def\requis{\hfill {\it  requis}}
 \def\facultatif{\quad\quad facultatif}
 \def\need#1{\hfill{\it  requiert le champ\,:\,#1}}

\subsection{File mesh data structure}
\index{file!data base}\index{file!bamg}
The mesh data structure, output of a mesh generation algorithm, 
refers to the geometric data structure and in some case to another
mesh data structure.

In this case, the fields are

\small
\begin{itemize}
\item {\tt MeshVersionFormatted 0}
\end{itemize}
\normalsize

\small
\begin{itemize}
\item {\tt Dimension} 
  \Int{dim} 

\item {\tt Vertices} 
  \Int{NbOfVertices}\\
  \Loop{\,\,\Loop{\Real{x$_i^j$}}{j=1,dim}\,\,,\,\Int{$Ref \phi_i^v$}}{i=1\,,\,NbOfVertices}

\item {\tt Edges} 
  \Int{NbOfEdges} \\
  \Loop{\Vertex{$^1_i$}\,,\,\Vertex{$^2_i$}\,,\,\Int{$Ref \phi_i^e$}}{i=1\,,\,NbOfEdges}

\item {\tt Triangles} 
  \Int{NbOfTriangles} \\
    \Loop{\Loop{\Vertex{$_i^j$}}{j=1,3}\,,\,\Int{$Ref \phi_i^t$} }{ i=1\,,\,NbOfTriangles}

\item {\tt Quadrilaterals} 
  \Int{NbOfQuadrilaterals} \\
    \Loop{\Loop{\Vertex{$_i^j$}}{j=1,4}\,,\,\Int{$Ref \phi_i^t$} }{ i=1\,,\,NbOfQuadrilaterals}

\item {\tt Geometry} \\
\Chars{FileNameOfGeometricSupport} \\

\begin{itemize}
\item {\tt VertexOnGeometricVertex} \\
   \Int{NbOfVertexOnGeometricVertex}\\
\Loop{\Vertex{$_i$}\,,\,\Vertex{$_i^{geo}$}}{i=1,NbOfVertexOnGeometricVertex}

\item {\tt EdgeOnGeometricEdge} \\
   \Int{NbOfEdgeOnGeometricEdge}\\
\Loop{\Edge{$_i$}\,,\,\Edge{$_i^{geo}$}}{i=1,NbOfEdgeOnGeometricEdge}
\end{itemize}

\item {\tt CrackedEdges} 
  \Int{NbOfCrackedEdges}\\
  \Loop{\Edge{$_i^1$}\,,\,\Edge{$_i^2$}}{i=1\,,\,{NbOfCrackedEdges}}

\end{itemize}
\normalsize

When the current mesh refers to a previous mesh, we have in addition

\small
\begin{itemize}
\item {\tt MeshSupportOfVertices} \\
\Chars{FileNameOfMeshSupport} \\
\begin{itemize}

\item {\tt VertexOnSupportVertex} \\
   \Int{NbOfVertexOnSupportVertex}\\
\Loop{\Vertex{$_i$}\,,\,\Vertex{$_i^{supp}$}}{i=1,NbOfVertexOnSupportVertex}

\item {\tt VertexOnSupportEdge} \\
   \Int{NbOfVertexOnSupportEdge}\\
\Loop{\Vertex{$_i$}\,,\,\Edge{$_i^{supp}$}\,,\,  \mbox{\Real{$u_i^{supp}$}}  }{i=1,NbOfVertexOnSupportEdge}

\item {\tt VertexOnSupportTriangle} \\
   \Int{NbOfVertexOnSupportTriangle}\\
\Loop{\Vertex{$_i$}\,,\,\Triangle{$_i^{supp}$}\,,\,
  \mbox{\Real{$u_i^{supp}$}}\,,\,  \mbox{\Real{$v_i^{supp}$}}  }
{\\ \hbox to 3cm {} i=1\,,\,{NbOfVertexOnSupportTriangle}}


\item {\tt VertexOnSupportQuadrilaterals} \\
   \Int{NbOfVertexOnSupportQuadrilaterals}\\
\Loop{\Vertex{$_i$}\,,\,\Quadrangle{$_i^{supp}$}\,,\,
  \mbox{\Real{$u_i^{supp}$}}\,,\,  \mbox{\Real{$v_i^{supp}$}}  }
{\\ \hbox to 3cm {} i=1\,,\,{NbOfVertexOnSupportQuadrilaterals}}


\end{itemize}

\end{itemize}
\normalsize

\end{document}