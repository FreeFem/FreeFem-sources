%&LaTeX  
\documentclass[a4paper,twoside,12pt]{book}
\usepackage{styles}
\def\key#1{\emph{#1}\index{#1}}
\def\vec#1{\mbox{\boldmath $#1$}}
\def\C{\mathbb{C}}
\def\Z{\mathbb{Z}}
\def\N{\mathbb{N}}

\def\setS#1{#1\label{sec:#1}}
\def\refSec#1{Section \ref{sec:#1}}
\def\refChap#1{Chapter \ref{sec:#1}}
\def\borderarray#1#2#3#4#5#6{%
\setbox0\hbox{$\begin{array}{#5}#6\end{array}$}
\setlength{\dimen1}{\wd0}\addtolength{\dimen1}{-#3}\addtolength{\dimen1}{-\arraycolsep}
\setlength{\dimen2}{\ht0}\addtolength{\dimen2}{-#4}
\setbox1\hbox{$\left#1\rule{\dimen1}{0pt}\rule{0pt}{\dimen2}\right#2$}
\setbox0\hbox{\raisebox{\dp0}{\box0}\kern-\dimen1\kern-5pt\raisebox{\dp1}{\box1}}
\vcenter{\box0}
}

\title{
%\DeclareFixedFont{\TitreFont}{\encodingdefault}{pnc}{r}{\shapedefault}{70pt}
 {\Blue{ \TitreFont FreeFem++ \\ \vglue 1cm  Manual}} \\ \vglue 3cm  ~ \\  
      \normalsize  { version 1.46-0  \Red{(Under construction)} }
 \\ \vglue 0.7cm
 \large \url{http://www.freefem.org} \\
\url{http://www.ann.jussieu.fr/\string~hecht/freefem++.htm} 
}
\author{F. Hecht \thanks{\url{mailto:hecht@ann.jussieu.fr}},
 O. Pironneau \thanks{\url{mailto:pironneau@ann.jussieu.fr}},   
\\ Universit\'{e} Pierre et Marie Curie,
\\  Laboratoire Jacques-Louis Lions, 
\\175 rue du Chevaleret ,PARIS XIII
\\ ~ \\  K. Ohtsuka  \thanks{\url{mailto:ohtsuka@barnard.cs.hkg.ac.jp}}, \\
Hiroshima Kokusai Gakuin University, Hiroshima, Japan
}
\makeindex
\begin{document}
\graphicspath{{./}{plots/}{figures/}}
\ifpdf 
\DeclareGraphicsExtensions{.pdf ,.jpg , .tif}
\else
\DeclareGraphicsExtensions{.eps ,.ps ,.jpg}
\fi

\maketitle

\tableofcontents
\let\subsubsection\subsection
\let\subsection\section
\let\section\chapter
\section{Introduction}
A partial differential equation is a relation between a function
of several variables and its (partial) derivatives.
 Many problems in physics, engineering, mathematics and even banking
are modeled by one or several partial differential equations.
\\\\

\texttt{Freefem} is a software to solve these equations numerically.
As its name says, it is a free software (see copyright for full detail) 
based  on the Finite
Element Method. This software runs on all unix OS (with g++ 2.95.2 or
better and X11R6) , on Window95, 98, 2000, NT, XP,  on MacOS 9 and
X.  \\\\
Many phenomena involve several different fields.  Fluid-structure
interactions, Lorenz forces in liquid aluminium and ocean-atmosphere
problems are three such systems. These require approximations of
different degrees, possibly on different meshes.  Some algorithms such
as Schwarz' domain decomposition method also require data
interpolation on different meshes within one
program. \texttt{freefem++} can handle these difficulties, i.e. {\it
arbitrary finite element spaces on arbitrary unstructured and adapted
meshes}.  \\\\

The characteristics of \freefempp are:
\begin{itemize}
\item A large variety of finites elements : linear and quadratic
 Lagrangian elements, discontinuous P1 and Raviart-Thomas elements,
 elements of a non-scalar type, mini-element, ...
\item  Automatic interpolation of data on different meshes to an over mesh, store the interpolation matrix.
%
\item Linear problems description (real or complex) thanks to a formal variational form, 
with access to the vectors and the matrix if needed.
%
\item Includes tools to define discontinuous Galerkin formulations
(please refer to the following keywords: ``jump'', ``average'',
``intalledges'').
%
\item Analytic description of boundaries. When two boundaries
intersect, the user must specify the intersection points.
%
\item Automatic mesh generator, based on the Delaunay-Vorono\"{i}
algorithm. Inner points density is proportional to the density of
points on the boundary \cite{George}.
%
\item Metric-based anisotropic mesh adaptation. The metric can be
computed automatically from the Hessien of a solution \cite{bamg}.
%
%\item Every variable is typed. For instance \texttt{f} is a function, specified
%by the keyword \texttt{func}.
%
\item Solvers : LU, Cholesky, Crout, CG, GMRES, UMFPACK linear solver,
eigenvalue and eigenvector computation.
%
\item Online graphics, C++-like syntax.
%
\item Many examples: Navier-Stokes, elasticity, Fluid structure,
Schwarz's domain decomposition method, Eigen value problem, residual
error indicator, ...
%
\item Parallel version using \texttt{mpi}
\end{itemize}


\subsection{History}

The project has evolved from \texttt{MacFem, PCfem}, written in
Pascal. The first C version was \texttt{freefem 3.4}; it offered mesh
adaptation on a single mesh.  A thorough rewriting in C++ led to
\texttt{freefem+ 1.2.10}, which also included interpolation over
multiple meshes (functions defined on one mesh can be used on any
other mesh).  Implementing the interpolation from one unstructured
mesh to another was not easy because it had to be fast and
non-diffusive; for each point, one had to find the containing
triangle. This is one of the basic problems of computational geometry
(see Preparata \& Shamos\cite{Preparata} for example). Doing it in a
minimum number of operations was a challenge.  Our implementation was
$O(n\log n)$ and based on a quadtree.  \\\\

We are now introducing \freefempp, an entirely new program written
in C++ and based on \texttt{bison} for a more adaptable
freefem language.
\\\\

The freefem language allows for a quick specification of any partial
differential system of equations.  The language syntax of \freefempp
is the result of a new design which makes use of the STL \cite{cpp},
templates and \texttt{bison} for its implementation.  The outcome is a
versatile software in which any new finite element can be included in
a few hours; but a recompilation is then necessary.  The library of
finite elements available in \freefempp will therefore grow with the
version number.  So far we have linear and quadratic Lagrangian
elements, discontinuous P1 and Raviart-Thomas elements.

\subsection{Getting Started}
\label{sec:example}

We explain how \freefempp solve the problem \textbf{Poisson}; 
For a given function $f(x,y)$, find a function $u(x,y)$ satisfying 
\begin{eqnarray}
\label{eqn:Poisson}
-\Delta u(x,y) &=& f(x,y)\quad \mbox{if $(x,y)$ is in }\Omega,
\qquad \Delta u = \partial^2 u/\partial x^2 + \partial^2 u/\partial y^2,\\
\label{eqn:Dirichlet}
u(x,y) &=& 0\quad \mbox{if $(x,y)$ is on }\partial\Omega
\end{eqnarray}
The following example shows \freefempp program solving $u$ when 
$f(x,y)=xy$ (see 5th line) and $\Omega$ is the unit disk. The boundary $C=\partial\Omega$ is
$$
C=\{(x,y)|\; x=\cos(t),\, y=\sin(t),\, 0\le t\le 2\pi\}
\quad \textrm{(see 1st line)}
$$
The domain will 
be on the left side of the oriented boundary by the parameter $t$.
As illustrated in Fig. \ref{firstU}, we can see the isovalue of $u$ by using \ttCC{@plot} (see 13th line).
\twoplot[height=5cm]{firstTh}{firstU}{mesh \ttCC{Th} by \ttCC{build(C(50))}}{isovalue by \ttCC{plot(u)}}

\begin{example}\label{exm:first}~
\bFF
 1: @border C(t=0,2*@pi){@x=cos(t); @y=sin(t);label=1;}
 2: @mesh Th = @buildmesh (C(50));
 3; @fespace Vh(Th,@P2);
 4: Vh u,v;
 5: @func f= x*y;
 6: @problem Poisson(u,v,@solver=LU) =
 7:    @int2d(Th)(@dx(u)*@dx(v) + @dy(u)*@dy(v))   //  bilinear part
 8:    - @int2d(Th)( f*v)          // right hand side 
 9:    + @on(1,u=0)  ;  // Dirichlet boundary condition
10:
11: @real cpu=clock();
12: Poisson; // SOLVE THE PDE
13: @plot(u);
14: @cout << " CPU time = " << clock()-cpu << @endl;
\eFF
\end{example}

\subsubsection{FEM by \freefempp}
The example shows \freefempp covers  easily all standard step in FEM (finite element method).
We explain how they are done by \freefempp in a step-by-step manner.\\

\textbf{Step1: Mesh Generation}\\

\textbf{1st line:} the boundary $\Gamma$ are described analytically (by opposition to CSG)
as stated before.
In the case $\Gamma=\sum_{j=0}^J \Gamma_j$ with curves $\Gamma_j$, then 
the user must specify the
intersection points in case two boundaries intersect.
By the use of the keyword ``label'' such as
\bT
@border Gamma1(t=a1,b1) { x=$\cdots$; y=$\cdots$ ;label=1; }
 $\vdots$        $\vdots$           $\vdots$      $\vdots$
@border GammaJ(t=aJ,bJ) { x=$\cdots$; y=$\cdots$;label=1; }
\eT
the user can refer to $\Gamma$  by the number ``1''.
(examples are in \refSec{Meshing Examples}).

\textbf{2nd line:} the triangulation $\mathcal{T}_h$ of $\Omega$ is 
automatically generated  by 
``\ttCC{@buildmesh}(C(50))'' giving 50 points on $C$ as in Fig. \ref{firstTh}.
Automatic mesh generation is based on the Delaunay-Voronoi algorithm.
Refinement of the mesh are done by increasing the points on $\Gamma$, 
for example, ``\ttCC{@buildmesh}(C(100))'', because inner vertices are 
determined by the density of points on the boundary.

The symbol $\mathcal{T}_h$ (\texttt{Th} in \freefempp) shows
a family $\{T_k\}_{k=1,\cdots,n_t}$ of triangles in Fig. \ref{firstTh} 
with the size $h$ of the mesh.
Here $n_t$ stands for the number of 
triangules in $\mathcal{T}_h$.
If $\Omega$ is not polygonal domain, a ``skin'' remains between 
the exact domain $\Omega$ and its approximation 
$\Omega_h=\cup_{k=1}^{n_t}T_k$.
However, we notice that all corners of $\Gamma_h = \partial\Omega_h$ are 
on $\Gamma$.\\

\textbf{Step2: Making finite element space}\\

\textbf{3rd line:} ``\ttCC{@fespace} Vh(Th,P2)'' makes the continuous Finite Element SPACE
\begin{equation}
V_h(\mathcal{T}_h,P_2)=\left\{w(x,y)\left|\;
w(x,y)=\sum_{k=0}^{M-1}w_k\phi_k(x,y),\, w_k\textrm{ are real numbers}\right.\right\}
\end{equation}
where $P_2$ indicate $\phi_k$ is a polynomial of degree $\le 2$, that is,
in each $T_k$,
$$
\phi_k(x,y)=\alpha_1+\alpha_2x+\alpha_3y+\alpha_4x^2+\alpha_5xy+\alpha_6y^2
$$
and the constants $\alpha_1,\,\cdots,\, \alpha_6$ are defined by its values 
at the vertices of $T_k$ and their middle points that continuous in $\Omega$.
Here $w_k$ are called the degree of freedom of $w$ and $M$ the number of 
the degree of freedom.
Already \freefempp implemented
P0, P1, P2, RT0, P1nc, P1dc, P2dc, P1b, P2b elements, .
The user can easily add a part of arbitrary degree elements to \freefempp,
so the available finite elements will differ with the version.\\

\textbf{Step3: Setting the problem}\\

\textbf{4th line:} ``\texttt{Vh u}'' declare that $u$ is approximated 
through the use of the basis functions $\phi_k$ in $V_h$, that is,
\begin{equation*}
u(x,y)\simeq u_h(x,y)=\sum_{k=0}^{M-1} u_k\phi_k(x,y)
\end{equation*}
\textbf{5th line:} the given function $f$ is defined analytically using the keyword 
\ttCC{@func}.

\textbf{6th--9th lines:} the formulation of (\ref{eqn:Poisson}) and 
(\ref{eqn:Dirichlet}) are done.

Multiplying (\ref{eqn:Poisson}) by $v(x,y)$ and integrating 
the result over $\Omega$, we have
$$
-\int_{\Omega}v\Delta u \,dxdy = \int_{\Omega} vf\, dxdy
$$
Then, by Green's formula, the problem Poisson is translated into finding $u$ 
such that
\begin{eqnarray}
\label{eqn:weakform}
&&a(u,v) - \ell(f,v) = 0
\qquad \textrm{for all }v\\
&&a(u,v)=\int_{\Omega}\nabla u\cdot \nabla v \,dxdy
\quad \ell(f,v)=\int_{\Omega}fv\, dxdy
\label{eqn:bilinear}
\end{eqnarray}
satisfying $v=0$ on $\partial\Omega$. In \freefempp  
the problem \textbf{Poisson} is declared by
\begin{center}
\ttCC{Vh u,v; @problem Poisson(u,v) =}
\end{center}
and (\ref{eqn:weakform}) is expressed by symbols \ttCC{@dx}(u) $=\partial u/\partial x$, \ttCC{@dy}(u) $=\partial u/\partial y$ and
\begin{eqnarray*}
&&\int_{\Omega}\nabla u\cdot \nabla v\, dxdy \longrightarrow
\ttCC{@int@2d(Th)( @dx(u)*@dx(v) + @dy(u)*@dy(v) )}\\
&&\int_{\Omega}fv\, dxdy \longrightarrow
\ttCC{@int@2d(Th)( f*v )}\qquad 
\textrm{(notice here, $u$ is unused)}\\
\end{eqnarray*}
In \freefempp the first and second formulas just above must be distinguished each other.
Because, the linear system to be solved are created from substituting $u_h$ for $u$ and $\phi_i$ for $v$ in (\ref{eqn:weakform}),
\begin{eqnarray}
\label{eqn:Equation}
A_{ij}u_j - F_i=0\quad i,j=0,\cdots,M-1;\qquad 
F_i=\int_{\Omega}f\phi_i\, dxdy
\end{eqnarray}
and the solution $u_h=\sum_{j=0}^{M-1}u_j\phi_j$  must 
satisfy ``$u_h=0$ on $\Gamma_h\simeq C$''.
The matrix $A=(A_{ij})$ is called \emph{stiffness matrix}
\index{matrix!stiffness matrix} and is modified from
\begin{eqnarray}
\label{eqn:Stiffness0}
A^0=\{A^0_{ij}\},\, A^0_{ij}=\int_{\Omega}\nabla \phi_j\cdot \nabla \phi_i \,dxdy\quad i.j=0,\cdots,M-1
\end{eqnarray}
to ensure $u=0$ on $C$ by ``+\ttCC{@on}\{1,u=0\}'' in 9th line.
If you want use the symbol ``C'' such as ``+\ttCC{@on}\{C,u=0\}'' (9th line), 
then \emph{the user do not use the keyword ``label''}. 

we can create directly the stiffness matrix $A$ in 
(\ref{eqn:Equation}) by 
\bT
@varf a(u,v) = @int2d(Th)( @dx(u)*@dx(v) + @dy(u)*@dy(v)) 
               + @on(C,u=0) ; 
@matrix A=a(Vh,Vh);  // stiffness matrix, see (\ref{eqn:Stiffness0})
\eT
(see Example \ref{exm:second}).
The vector $B$ in (\ref{eqn:Equation}) is called \emph{load matrix}
\index{matrix!load matrix}, and also we get it:
\bT
@varf b([v],[f]) = @int2d(Th)(v*f);
@matrix B=b(Vh,Vh);
\eT

The linear system (\ref{eqn:Equation}) is solved by a Gauss LU factorisation.
You can declare the solver of (\ref{eqn:Equation}), for example, 
\begin{center}
\ttCC{Vh u,v; @problem Poisson(u,v,@solver=CG) =}
\end{center}
means that (\ref{eqn:Equation}) will be solved by Conjugate Graduent method.\\

\textbf{Step4: Solving and visualization}\\

\textbf{11th line:} the current time is stored into the real-valued variable \ttCC{cpu}.

\textbf{12th line:} the problem is solved by calling its name.

\textbf{13th line:} the visualization is done as illustrated in Fig. \ref{firstU}
(see \refSec{Plot} for zoom, postscript and other commands).
  
\textbf{14th line:} the time in calculation is outputed into your console 
(= default of standard output) using C++-like syntax.
The user need not study C++ for using \freefempp, because 
C++-like syntax is used for input/output, loops, flow-controls etc. 

\subsubsection{Features of \freefempp}

The language it
defines is typed, polymorphic and reentrant with macro generation (see
\ref{macro}).  Every variable must be typed and declared in a
statement; each statement separated from the next by a semicolon
`\texttt{;}'.

For purposes of explanation, we used $\mathcal{T}_h$ (\texttt{Th}),\, $V_h$ (\texttt{Vh}), unknown function $u$ (\texttt{u}), test functions $v$ (\texttt{v}) and the problem \textbf{Poisson}, etc. (the term inside the parentheses are symbols in \freefempp programming), but
you can use \emph{any name except reserved words and names already used}.
Reserved words are shown in blue. \texttt{pi, x, y, label, solver} are
reserved variables. It is allowed (although not advisable) to redefine
these variables, so they will not be highlighted again in the
following example programs.\\\\

In each step, the independence in \freefempp programming is very high 
as stated below.
\begin{itemize}
  \item 
  For example, by changing 1st and 2nd lines as
  following, we can solve (\ref{eqn:Poisson}) and (\ref{eqn:Dirichlet})
  in L-shape domain with $\Gamma=\sum_{j=1}^6\Gamma_j$.
\bT
@border G1(t=0,1){x=t;y=0;@label=1;}  // $\Gamma_1$
@border G2(t=0,0.5){x=1;y=t;@label=1;}  // $\Gamma_2$
@border G3(t=0,0.5){x=1-t;y=0.5;@label=1;}  // $\Gamma_3$
@border G4(t=0.5,1){x=0.5;y=t;@label=1;}  // $\Gamma_4$
@border G5(t=0.5,1){x=1-t;y=1;@label=1;}  // $\Gamma_5$
@border G6(t=0,1){x=0;y=1-t;@label=1;}  // $\Gamma_6$
@mesh Th = @buildmesh ( G1(6)+G2(4)+G3(4)+G4(4)+G5(4)+G6(6));
\eT
  \item
  In Step 3, you can control where the solution will be approximated.
  If you write ``\texttt{Vh(Th,P1);}'' in 3rd line, you can get $P_1$-approximation. The machine time by $P_1$-element will be faster than $P_2$-element
  and the storage is less.
  \item
  In Step 4, you can change the equation and boundary conditions easily.
  For example, if you want solve 
  \begin{eqnarray*}
  -\textrm{div}(k(x,y)\nabla u(x,y))&=&f(x,y)\quad\textrm{in }\Omega\\
  u(x,y)&=&0\qquad \textrm{if $(x,y)$ on }\Gamma
  \end{eqnarray*}
  you only write as follows
  \bT
  @func f= $\cdots$;
  @func k= 1+sin(2*pi*x)*cos(2*pi*y);
  @problem Poisson(u,v) =
     @int2d(Th)(k*(@dx(u)*@dx(v) + @dy(u)*@dy(v))) 
     - @int2d(Th)( f*v)          
     + @on(1,u=0)  ;  
  \eT
  \emph{The user can use FE-function as the given function $f$ } (see \refSec{FE-function}), for example, obtained function \texttt{u} in Example \ref{exm:first}.
  In \freefempp programming, the easy reuse of the obtained results 
  is important feature.
  \item
  The user can easily compare between mathematical modelling and \freefempp program.
\end{itemize}

\subsection{Projection or Interpolation}
\index{P1-projection}
For a finite element space $V_h$, $P_1$-projection $\Pi_h$ is defined by
\[
\Pi_h f=f(q^1)\phi_1+f(q^2)\phi_2+\cdots +f(q^{n_v})\phi_{n_v}
\]
for all continuous functions $f$. In \freefempp we can easily create the 
projection $f_h(=\texttt{fh})$ by 
\bT
Vh fh = $f(x,y)$;
\eT
$\Pi_h$ is also called $P_1$-interpolate.

\subsection{\setS{Matrix and Vector}}
Here, we show how to get the stiffness matrix using \freefempp
The first command \texttt{varf} is to define the \key{variational formula}.
\begin{example}\label{exm:second}
Here we solve the same problem (\ref{eqn:Poisson}) and (\ref{eqn:Dirichlet})
using matrix. 
For purposes of explanation, we chage mesh size and use $P_1$-element:
\bT
 1: @border C(t=0,2*pi) { x = cos(t); y = sin(t); } 
 2: @mesh Th = @buildmesh(C(7));  // changed from Example \ref{exm:first}
 3: @fespace Vh(Th,P1);
 4: Vh u,v,f,F; 
 5: @varf a(u,v) = @int2d(Th)( @dx(u)*@dx(v) + @dy(u)*@dy(v)) 
 6:             + @on(C,u=0) ; // see (\ref{eqn:Stiffness0})
 7: @varf b([v],[f]) = @int2d(Th)(v*f);
 8: 
 9: f = x*y;  // interpolate $(x,y) \longleftarrow x*y$ function 
10: @matrix A=a(Vh,Vh);  // stiffness matrix, see (\ref{eqn:Equation})
11: @matrix B=b(Vh,Vh);
12: F[]=B*f[];     // load vector, see (\ref{eqn:Equation})
13: @cout << "F=" << F[] << @endl;
14: @cout <<"A="<< A << @endl;
15: u[]=A^-1*F[];  // solve $A\vec{U}_h = \vec{F}$, see (\ref{eqn:Equation})
16: @plot(u);
\eT

We get the mesh $\mathcal{T}_h=\{T_1,\cdots,T_7\}$ (see Fig. \ref{fig:secondTh}).
\begin{note}
\label{note:mesh}
In what follows, we denote the vertices by $q^i,\, i=1,\cdots,8$,
the number of vertices by $n_v$, the number of triangles by $n_t$.
For each triangle $T_k\in \mathcal{T}_h$, we index the vertices by 
$q^{k_1},\, q^{k_2},\, q^{k_3}$ and denote the edges by
$[q^{k_1}, q^{k_2}]$, $[q^{k_2}, q^{k_3}]$, $[q^{k_3}, q^{k_i}]$, that is,
$[q^i,q^j]$ is the segment connecting $q^i$ and $q^j$.
We denote the number of edges $[q^i,q^j]$ 
by $n_e$ for all $q^i,\, q^j\partial\Omega_h$, 
$\Omega_h=\sum_{k=1}^7T_k$.
Here $n_v=8$, $n_t=7$, $n_e=7$.
\end{note}
\begin{figure}[htbp]
\begin{minipage}{\textwidth}
\begin{minipage}{0.3\textwidth}
\includegraphics[width=\textwidth]{secondT}%
\caption{mesh \texttt{Th}}
\label{fig:secondTh}
\end{minipage}
\hspace{0.5mm}
\begin{minipage}{0.7\textwidth}
\includegraphics[width=\textwidth]{hat}%
\caption{Graph of $\phi_1$ (left hand side) and $\phi_6$}
\label{fig:hatFunction}
\end{minipage}
\end{minipage}
\end{figure}


The function $v$ in ``\texttt{Vh}'' is expressed 
\begin{equation*}
v(x)=v_{1}\varphi _{1}(x) +\cdots +v_{n_{v}}\varphi _{n_{v}}(x)
\end{equation*}%
using the \key{hat functions} $\varphi _{j},\,j=1,\cdots ,n_{v}$ (see Fig.
\ref{fig:hatFunction}).
Here the $j$-th hat function $\varphi _{j}$ associated with $j$-th
vertex $q^j$ is defined in the following way:
\begin{enumerate}
\item $\varphi _{j}$ is continuous function on $\Omega_h$.

\item $\varphi _{j}$ is linear on each triangle $T_k,\, k=1,\cdots,n_{t}$
 of ``\texttt{Th}''.

\item $\varphi _{j}\left( {q^{i}}\right) =\delta _{ji}$ where $q^{i}$
denotes the $i$-th vertex, for all $i=1,\cdots ,n_{v}$.
\end{enumerate}
Here $\delta_{ij}$ is the Kronecker symbol.

\begin{note}
Other finite element spaces in \freefempp are explained in \refSec{Finite Elements}.
\end{note}
\begin{note}
\label{note:FE2VEC}
For an element $v=v_1\phi_1+\cdots+v_M\phi_M$ in 
a finite element space $V_h$, we get the \emph{column vector}
$\{v\}$
\[
\{v\}=\left[
\begin{array}{c}
v_1\\
\vdots\\
v_M
\end{array}
\right]\qquad
\{v\}=\texttt{v[]}\quad \textrm{in \freefempp}
\]
\end{note}
Theoretically, it is natural to use the finite element space
\[
H^1_{0h}=
\left\{v\in V_h(\mathcal{T}_h,P_1)\left|
\phi_i(x)=0\quad \textrm{if }q^i\in \partial\Omega_h
\right.\right\}
\]
Let $I_{\Omega}$ be the set of indices $i$ of all internal vertices of the mesh
\texttt{Vh}. In this example, $I_{\Omega}=\{6\}$.
The stiffness matrix $A$ in 10th line is:
\begin{eqnarray}
\label{eqn:StiffnessDirichlet}
\borderarray{[}{]}{1em}{1.2ex}{rrrrrrrrr}{
&1&2&3&4&5&6&7&8\\
1&10^{30}& -0.31& 0& 0&-0.46& -0.51& 0&0\\
2&-0.31& 10^{30}& -0.23& 0& 0&-0.71& 0&0\\
3&0&-0.23&10^{30}&-0.31& 0&-0.71& 0&0\\
4&0& 0&-0.31&10^{30}& 0& -0.51& -0.46&0 \\
5&-0.46& 0& 0& 0&10^{30}& -0.35& 0&-0.54\\
6&-0.51& -0.71& -0.71& -0.51& -0.35& 3.47& -0.35& -0.30\\
7&0& 0& 0&-0.46& &-0.35& 10^{30}& -0.54\\
8&0& 0& 0& 0&-0.54&-0.30&-0.54& 10^{30}
}
\end{eqnarray}
that is 
\begin{eqnarray}
A_{ij}&=&\int_{\Omega_h}\nabla u_j\cdot \nabla u_i\quad
\textrm{if }i\neq j,\, i=j\in I_{\Omega}\\
A_{ij}&=&E\qquad (E=10^{30})\quad \textrm{if }j\in I_{\Omega}.
\end{eqnarray}
The load matrix $F^T$ is:
\begin{eqnarray*}
\left(
\begin{array}{cccccccc}
-0.020& -0.037& 0.037& 0.020&0.064& 0& -0.064&1.\times 10^{-17}
\end{array}
\right)
\end{eqnarray*}
For $i\not\in I_{\Omega}$, 
\[
Eu_i+\sum_{i\neq j}A_{ij}u_j=b_i
\]
which means that
\[
u_i=(b_i-\sum_{i\neq j}A_{ij}u_j)\times E^{-1}\simeq 10^{-30}\simeq 0
\]
\end{example}

Mathematical results indicate that the Poisson equation 
with Neaumann boundary condition has not unique solution,
whose weak form is same to (\ref{eqn:Poisson}) except the boundary condition:
\[
\int_{\Omega}\nabla u\cdot \nabla v = \int_{\Omega}fvdx
\]
without pernarization $E$. Then the stiffness matrix is created by
\bT
@varf a(u,v) = @int2d(Th)( @dx(u)*@dx(v) + @dy(u)*@dy(v)) 
@matrix A=a(Vh,Vh); // stiffness matrix
\eT
and the obtained stiffness matrix is the following
\[
\borderarray{[}{]}{1em}{1.2ex}{rrrrrrrrr}{
&1&2&3&4&5&6&7&8\\
1&1.29&-0.31&0&0&-0.46&-0.51&0&0\\ 
2&-0.31&1.26&-0.23&0&0&-0.71&0&0\\
3&0&-0.23&1.26&-0.31&0&-0.71&0&0\\
4&0&0&-0.31&1.29&0&-0.51&-0.46&0\\
5&-0.46&0&0&0&1.35&-0.35&0&-0.54\\
6&-0.51&-0.71&-0.71&-0.51&-0.35&3.47&-0.35&-0.30\\
7&0&0&0&-0.46&0&-0.35&1.35&-0.54\\
8&0&0&0&0&-0.54&-0.30&-0.54&1.38
}
\]
The determinant of this matrix is $-1.7082274230870981\times 10^{-9}\approx 0$
(The matrix here differ from original one by omitting from third decimal decimal point). 

\subsubsection{Non-homogeneous Dirichlet Condition}
If we want solve the problem
\[
-\Delta u=f\quad \textrm{in }\Omega;\qquad 
u=g\quad \textrm{on }\partial\Omega
\]
We rewrite Example \ref{exm:first} as
\bT
 5: @func f= x*y; @func g = sin(pi*x)*cos(pi*y);
 6: @problem Poisson(u,v,@solver=LU) =
 7:    @int2d(Th)(@dx(u)*@dx(v) + @dy(u)*@dy(v))   //  bilinear part
 8:    - @int2d(Th)( f*v)          // right hand side 
 9:    + @on(1,u=g)  ;  // Non-homogeneous Dirichlet
\eT
This make the following linear system, for $i\not\in I_{\Omega}$, 
\[
Eu_i+\sum_{i\neq j}A_{ij}u_j=b_i+Eg(q^i)
\]
which means that
\[
u_i=g(q^i)+(b_i-\sum_{i\neq j}A_{ij}u_j)\times E^{-1}\simeq g(q^i)+O(1/E)
\]
\begin{note}
To solve non-homogeneous Dirichlet, we rewrite Example \ref{exm:second} as
\bT
 4: Vh u,v,f,F,g,bc; g = sin(pi*x)*cos(pi*y);
 5: @varf a(u,v) = @int2d(Th)( @dx(u)*@dx(v) + @dy(u)*@dy(v)) 
 6:             + @on(C,u=1) ; // see (\ref{eqn:Stiffness0})
10: @matrix A=a(Vh,Vh); bc[]=a(0,Vh);
12: F[]=B*f[];  F[] += bc[] .* g[];
\eT
Here ``\texttt{bc[]=a(0,Vh)}'' create the vector 
$[bc_1,bc_2,\cdots,bc_M]$, $bc_i=0$ if $i\in I_{\Omega}$ and
$bc_i=E (=10^{30})$ if $i\not\in I_{\Omega}$.
If the finite approximation of $g$ is $g\approx g_1\phi_1+\cdots+g_M\phi_M$
\begin{equation}
\texttt{bc[] .* g[]}=\sum_{j=0}^{M-1} bc_jg_j
\end{equation}
\end{note}

\subsubsection{\setS{Matrix Operations}}

The multiplicative operators *, /, and \% group left to right.

\begin{itemize}
\item  \verb@'@  is unary right transposition of array, matrix \index{transpose}
 \item \verb@.*@ is the term to term multiply operator. \index{.*} \index{\string'} \index{divide!term to term}
 \item \verb@./@ is the term to term divide operator. \index{./} \index{\string'} \index{product!term to term}
\end{itemize}
there are some compound operator: 
\begin{itemize}
 \item \verb@^-1@ is for  solving the linear system (example: \verb$ b = A^-1 x$) \index{solve!linear system}
 \item \verb@' *@ is the compound  of transposition and matrix product, so it is the dot product 
(example \verb$real DotProduct=a'*b$) \index{dot product}\index{product!dot} 
\end{itemize}
\begin{example}~
\bFF
@mesh Th = @square(2,1);
@fespace Vh(Th,P1);
Vh f,g; 
f = x*y;
g = sin(pi*x);
Vh<complex> ff,gg; // a complex valued finite element function \index{FE function!complex}
ff= x*(y+1i);
gg = exp(pi*x*i);
@varf mat(u,v) =
  int2d(Th)(1*dx(u)*dx(v)+2*dx(u)*dy(v)+3*dy(u)*dx(v)+4*dy(u)*dy(v))
  + on(1,2,3,4,u=1);
@varf mati(u,v) =
  int2d(Th)(1*dx(u)*dx(v)+2i*dx(u)*dy(v)+3*dy(u)*dx(v)+4*dy(u)*dy(v))
  + on(1,2,3,4,u=1);
@matrix A = mat(Vh,Vh);
@matrix<complex> AA = mati(Vh,Vh); // a complex sparce matrix \index{matrix:complex}

Vh m0; m0[] = A*f[];
Vh m01; m01[] = A'*f[];
Vh m1; m1[] = f[].*g[];
Vh m2; m2[] = f[]./g[];
@cout << "f = " << f[] << @endl;
@cout << "g = " << g[] << @endl;
@cout << "A = " << A << @endl;
@cout << "m0 = " << m0[] << @endl;
@cout << "m01 = " << m01[] << @endl;
@cout << "m1 = "<< m1[] << @endl;
@cout << "m2 = "<< m2[] << @endl;
@cout << "dot Product = "<< f[]'*g[] << @endl;
@cout << "hermitien Product = "<< ff[]'*gg[] << @endl;
\eFF
This produce the following:
\begin{eqnarray*}
A&=&\borderarray{[}{]}{1em}{1.2ex}{rrrrrrrr}{
&1&2&3&4&5&6\\
1&10^{30}& 1 0.5& 0&3 0.& 4 -2.5& 0\\
2&0.&10^{30}&0.5& 0&0.5&-2.5\\
3&0&0.&10^{30}& 0& 0&0.5\\
4&0.5& 0& 0& 10^{30}& 0.& 0\\
5&-2.5&0.5& 0&0.5&10^{30}&0.\\
6&0&-2.5&0.& 0&0.5& 10^{30}
}
\\
\{v\}=\texttt{f[]}&=&
\left(
\begin{array}{rrrrrr}
0 & 0 & 0 & 0 & 0.5 & 1
\end{array}
\right)^T\\
\{w\}=\texttt{g[]}&=&
\left(
\begin{array}{rrrrrr}
0 &1  &1.2\times 10^{-16}& 0 & 1 & 1.2\times 10^{-16}
\end{array}
\right)^T\\
\texttt{A*f[]}&=&
\left(
\begin{array}{rrrrrr}
-1.25 &  -2.25 &  0.5   & 0 & 5\times 10^{29} & 10^{30}
\end{array}
\right)^T\quad (=A\{v\})\\
\texttt{A'*f[]}&=&
\left(
\begin{array}{rrrrrr}
-1.25 &  -2.25 &  0  & 0.25 & 5\times 10^{29} & 10^{30}
\end{array}
\right)^T\quad (=A^T\{v\})\\
\texttt{f[].*g[]}&=&
\left(
\begin{array}{rrrrrr}
0 & 0 & 0 & 0 & 0.5 & 1.2\times 10^{-16}
\end{array}
\right)^T\quad =(v_1w_1\quad\cdots\quad v_Mw_M)^T\\
\texttt{f[]./g[]}&=&
\left(
\begin{array}{rrrrrr}
-nan & 0  & 0  & -nan  & 0.5 & 8.1\times 10^{15}
\end{array}
\right)^T\quad =(v_1/w_1\,\cdots\, v_M/w_M)^T\\
\texttt{f[]'*g[]}&=&0.5\quad 
(=\{v\}\{w\}^T=\{v\}\cdot\{w\})
\end{eqnarray*}
\end{example}
\begin{note}
The operators \verb|^-1| cannot create the matrix by themselves.
Indeed, the following occur errors
\bT
@matrix AAA = A^-1;
\eT
\end{note}

\subsection{\setS{Modeling}--Edit--Run--Visualize--Revise}
\bigskip 
\freefempp provide many examples and its documentation, so you can easily calculate
mathematical models by FEM (finite element method) and study them.
Explanations for these examples are given in this book. If you are a
beginner of FEM, you start from Quick Tour of 
\freefempp. The numerical simulation of scientific problem will be done as follows.

\begin{description}
\item[Modeling:] Make a mathematical model describing scientific problems.
Mathematical modeling is a deep and fruitful one, with many important
implications for scientific problems
(refer to Chapter \ref{sec:MathModels}).

\item[Programming:] Translate the mathematical model to 
\freefempp source code, which is easy because \freefempp
includes many clever techniques in FEM with mathematical writing.

\item[Run:] Next step is to run it to see if it works. If we provisionally
give the name of the source code to ``something.edp'', we can execute it by
the typing\newline
\newline
\texttt{\% freefem++ something.edp}

An important part in programming is to keep aware of collections of
programs that are available, and this manual contains many examples you
can use freely. So we hope you to run these examples and their
representing mathematical models, which are contained in the package in 
\freefempp.

\item[Visualization:] The numerical calculation by FEM make huge data, so
the easy way to check the obtained result is their visualization. \freefempp
can display the mesh and the contour lines of obtained functions. If
you want to use these visualization after execution, you add the filename of
PostScript to the commands ``plot'' (see \refSec{Plot}).

\item[Debugging:] If the boolean value of ``wait'' is true (default is `false'), then 
\freefempp will stop at the information in visual form.
Write the following, execute it and make a change the line
``\ttCC{@wait=@true}'' to ``\ttCC{@wait=@false}''.
\bT
@bool wait = true;  // set "true" if you want see each plotting
mesh Th = @square(10,10,[-1+2*x,-1+2*y]); // $]-1,1[^2$
@plot(Th);  // plot the mesh
@fespace Vh(Th,P2);
Vh f = @sin(pi*x)*@cos(pi*y);
plot(f,wait=wait);  // plot the function f
Vh g = @sin(@pi*x + @cos(@pi*y));
@plot(g,wait=wait);  // plot the function g
\eT
If there is a fatal error in your
source code, \freefempp will end and cause an error message to appear. In MS-Windows, \freefempp will open the message file by notepad.
For example, if you forget parenthesis as in
\bT
@mesh Th = @square(10,10;
@plot(Th);
\eT
then you will get the following message from \texttt{freefem++},
\bT
mesh Th = square(10,10;
 Error line number 0, in file xxxxxx.edp, before  token ;
parse error
Compile error : parse error
        line number :0, ;
 at exec line  0
error Compile error : parse error
        line number :0, ;
\eT
If you use the same symbol twice as in
\bT
@real aaa =1;
@real aaa;
\eT
then you will get the message
\bT
real aaa =1;
    1 : real aaa; The identifier aaa exist
\eT
Notice that the line number start from 0.
If you find that the program isn't doing what you want it 
to do, then you check the line number and try to figure out
what's wrong.
We give two techniques; One is \emph{trace} by \ttCC{@plot}
for \emph{meshes} and (FE-)functions with \ttCC{@wait=@true}, 
and by \ttCC{@cout} for scalar, vectors and matrices.
Another is to \emph{comment out} by ``\ttCC{//}''.
If you find a doubtful line in your source code, you comment out 
as follows,
\bT
@real aaa =1;
// real aaa;
\eT
\end{description}

\bigskip

\subsection{Installation}

There are binary packages available for Microsoft Windows and Apple
Mac OS. For all other platforms, \freefempp must be compiled and
installed from the source archive. This archive is available from:

\url{http://www.ann.jussieu.fr/~hecht/ftp/freefem/freefem++.tgz}.
 
 To
extract files from the compressed archive \texttt{freefem++.tgz} into
a directory called \texttt{freefem++-X.XX} (where X.XX is the version number)
enter the following commands in a shell window~:

\bFF
tar zxvf freefem++.tgz
cd freefem++-X.XX
\eFF

To compile and install \freefempp, just follow the \texttt{INSTALL}
and \texttt{README} files. The following programs are produced,
depending on the system you are running (Linux, Windows, MacOS)~:

\begin{enumerate}
\item \texttt{FreeFem++}, standard version, with a graphical interface
based on X11, Win32 or MacOS
\item \texttt{FreeFem++-nw}, postscript plot output only (batch version, no windows)
\item \texttt{FreeFem++-mpi}, parallel version, postscript output only
\item \texttt{FreeFem++-glx}, graphics using OpenGL and X11
\item \texttt{FreeFem++-cs}, integrated development environment
(please see chapter ``Graphical User Interface'' for more details).
\item \texttt{/Applications/FreeFem++.app}, Drag and Drop CoCoa MacOs
Application
\item \texttt{FreeFem++-CoCoa}, MacOS Shell script for MacOS OpenGL
version (MacOS 10.2 or better) (note: it uses
/Applications/FreeFem++.app)
\end{enumerate}

As an installation test, go into the directory
\texttt{examples++-tutorial} and run \freefempp on the example script
\texttt{LaplaceP1.edp} with the command~:

\bFF
FreeFem++ LaplaceP1.edp
\eFF

\textBlack
\section{Syntax}
\subsection{Data Types}
Basically \freefempp  is a \index{compiler} compiler,
  the language is typed, polymorphic and reentrant.
Every variable must be typed, declared in a  statement; 
each statement separated
from the next by a semicolon `\texttt{;}'.
The language allows the manipulation of basic types
integers (\texttt{int}), reals (\texttt{real}), strings (\texttt{string}),
arrays (example: \texttt{real[int]}),
 bidimensional (2D) finite element meshes (\texttt{mesh}),
2D finite element spaces (\texttt{fespace}) , definition of functions
(\texttt{func}), arrays of
finite element functions (\texttt{func$[basic\_type]$}),
linear and bilinear operators, sparse matrices, vectors , etc. For instance

\bFF
  @int i,n=20;               //  $ i,n$ are integer.
  @real[@int] xx(n),yy(n);    //  two array of size n
  @for (i=0;i<=20;i++)       // which can be used in statements such as
   { xx[i]= cos(i*pi/10); yy[i]= sin(i*pi/10); }
\eFF
The life of a variable is the current block $\{\ldots \}$, except the \texttt{fespace} variable, and the in variables local to a block are destroyed at the end of the block as follows.
\begin{example}~~
\bT
@real r= 0.01;
@mesh Th=@square(10,10); // unit square mesh
@fespace Vh(Th,@P1);     // P1 lagrange finite  element space
Vh u = x+ exp(y);
@func f = z * x + r * log(y);
@plot(u,wait=true);
{  // new block
  @real r = 2; // not the same r
  @fespace Vh(Th,@P1);//  error because Vh is a global name 
}  // end of block
//  here r back to 0.01
\eT
\end{example}
The type declarations are  compulsory in \freefempp  because it is easy
to make bugs in a language with many types. \index{variable} The
variable name is just an alphanumeric \index{alphanumeric} string, the
underscore character  ``\texttt{\_}'' is not allowed, because
it will be used as an operator in the future.\index{\_}

\subsection{List of major types}
\begin{description}
\item[bool]   is used for logical expression and flow-control.
\index{bool}\index{true}\index{false}
\item[int]
  declare an integer.
\item[string] declare the varible to store 
a text enclosed within double quates, such as:
\bT
"This is a string in double quotes."
\eT
\index{string}
\item[real] declare the variable to store a number such as ``12.345''. \index{real}
\item[complex]  Complex numbers, such as 
$1+2i,\, i=\sqrt{-1}$.
\bT
@complex a =  1@i, b = 2 + 3@i;
@cout << "a + b = " << a + b << @endl;
@cout << "a - b = " << a + b << @endl;
@cout << "a * b = " << a * b << @endl;
@cout << "a / b = " << a / b << @endl;
\eT
Here's the output;
\bT
a + b = (2,4)
a - b = (-2,-2)
a * b = (-3,2)
a / b = (0.230769,0.153846)
\eT
\item[ofstream]  make a output file and its functions.
\item[ifstream]   make a input file and its functions.

\item[real[int]]  declare a variable that store multiple
real numbers with integer index.
\index{array}
\bT
@real[@int] a(5);
a[0] = 1; a[1] = 2; a[2] = 3.3333333; a[3] = 4; a[4] = 5;
@cout << "a = " << a  << @endl;
\eT
This produces the output;
\bT
a = 5   :
  1       2     3.33333   4       5
\eT
\item[real[string]]  declare a variable that store multiple
real numbers with string index.
\item[string[string]]  declare a variable that store multiple
strings with string index.
\index{array}
\itemtt[func] define a function without argument, 
if independent variables are \ttCC{x, y}.
For example
\bT
@func f=cos(x)+sin(y) ;
\eT
\index{func}
Remark the function's type is given by the expression's type.
The power of functions are given in \freefempp such as 
\ttCC{x\^{}1}, \ttCC{y\^{}0.23}.

\itemtt[mesh]  \index{mesh}
create the triangulation, see \refSec{Mesh Generation}.
\itemtt[fespace]  
define a new type of finite element space, see Section \refSec{Finite Elements}.
\itemtt[problem]  declare the weak form of a partial differential problem without solving. \index{problem}
\itemtt[solve]  declare a problem and solve it.\index{solve}
\itemtt[varf]   define a full variational form. \index{varf}
\itemtt[matrix] define a sparce matrix. \index{matrix}
\end{description}

\subsection{Global Variables}\label{sec:Global}
 The names \ttCC{x,y,z,label,region,P,N,nu\_triangle} are used to link
the language to the finite element tools: 
\begin{description}
    \itemtt[x]  expresses $x$ coordinate of current point (real value) \index{x}
    \itemtt[y]  expresses $y$ coordinate  of current point (real value) \index{y}
    \itemtt[z]  expresses $z$ coordinate of current point (real value) \index{z}, but is reserved for future use.
\itemtt[label] show the label number of boundary if the  current point is 
on a boundary, otherwise 0 (int value). \index{label}    
    \item[region]   returns the region number of  the current point (x,y) (int value). \index{region}
\itemtt[P]  give the  current point  ($\R^{2}$ value. \index{P}).
By \texttt{P.x}, \texttt{P.y}, we can get the $x,\, y$ components of \texttt{P} .
Also \texttt{P.z} is reserved.
    \itemtt[N]  give the outward unit normal vector at the  current point is on the curve define by \texttt{border} ($\R^{3}$ value).
\texttt{N.x} and \texttt{N.y} are $x$ and $y$ components of the normal vector.
\texttt{N.z} is reserved. \index{N}.
    \itemtt[lenEdge] give the length of the current edge\index{lenEdge}\\
    \[
    \texttt{lenEdge} = |q^i-q^j|\quad \textrm{if the current edge is }[q^i,q^j]
    \]
    
    \itemtt[hTriangle] give the size of the current triangle \index{hTriangle}

    \itemtt[nuTriangle] give the index of the current triangle (integer).
    \index{nuTriangle}

    \itemtt[nuEdge]  give the index of the current edge in the triangle (integer).
    \index{nuEdge}

    \itemtt[nTonEdge] give the number of adjacent triangle of the current
    edge (integer ).\index{nTonEdge}

    \itemtt[area] give the area of the current triangle (real). \index{area}

\itemtt[cout]  is the standard output device (default is console).
On MS-Windows, the standard output is only to console, in this time.
  \Ostream
\itemtt[cin]  is the standard input device (default is keyboard). (\Istream).
On MS-Windows, this don't work.
\itemtt[endl] give the end of line in the input/output devices.
\itemtt[true]   means ``true'' in  \Bool\  value.
\itemtt[false]  means ``false'' in  \Bool\ value.
\itemtt[pi]   is the \Real ~approximation value of $\pi$.
\end{description}

\medskip

Here is how to show all the types, and all the operator and functions.
\bFF
 @dumptable(@cout);
\eFF \index{dumptable}
To execute a system command in the string (not implemented on Carbon
MacOs)
\bFF
  @exec("shell command");
\eFF
On MS-Windows, we need the full path. For example, if there is the command 
``ls.exe'' in the subdirectory ``\verb|c:\cygwin\bin\|'', then we must write
\bFF
  @exec("c:\\cygwin\\bin\\ls.exe");
\eFF
\index{exec}


\subsection{Arithmetic}
In integers, $+,\, -,\, *$ express the usual arithmetic summation (plus), 
subtraction (minus) and multiplication (times), respectively.
The operators $/$ and $\%$ yield the quotient and the remainder from the division of the first expression by the second. 
If the second number of $/$ or $\%$ is zero the behavior is undefined.
The \key{maximum} or \key{minimum} of two integers $a,\, b$ are obtained 
by \texttt{max($a$,$b$)} of 
\texttt{min($a$,$b$)}.
The power $a^b$ of two integers $a,\, b$ is calculated by writing \verb|a^b|.
\begin{example} Calculations with the integers
\label{exm:int}
\bFF
@int a = 12, b = 5;
@cout <<"plus, minus of "<<a<<" and "<<b<<" are "<<a+b<<", "<<a-b<<@endl;
@cout <<"multiplication, quotient of them are "<<a*b<<", "<<a/b<<@endl;
@cout <<"remainder from division of "<<a<<" by "<<b<<" is "<<a%b<<@endl;
@cout <<"the minus of "<<a<<" is "<< -a << @endl;
@cout <<a<<" plus -"<<b<<" need bracket:"<<a<<"+(-"<<b<<")="<<a+(-b)<<@endl;
@cout <<"max and min of "<<a<<" and "<<b<<" is "<<@max(a,b)<<","<<@min(a,b)<< @endl;
@cout <<b<<"th power of "<<a<<" is "<<a^b<< @endl;
b=0;
@cout <<a<<"/0"<<" is "<< a/b << @endl;
@cout <<a<<"\%0"<<" is "<< a\%b << @endl;
\eFF
produce the following result:
\bFF
plus, minus of 12 and 5 are 17, 7
multiplication, quotient of them are 60, 2
remainder from division of 12 by 5 is 2
the minus of 12 is -12
12 plus -5 need bracket :12+(-5)=7
max and min of 12 and 5 is 12,5
5th power of 12 is 248832
12/0 : long long long
Fatal error : ExecError  Div by 0 at exec line  9
Exec error : exit
\eFF
\end{example}

By the relation $integer\subset real$, the operators 
``$+,\, -,\, *,\, /,\, \%$'' and ``\ttCC{@max,\, @min,\, \^}'' 
are also applicable in real-type. However,  $\%$ 
calculates the remainder of the integral parts of two real numbers.

The following example similar to Example \ref{exm:int}
\bT
@real a=sqrt(2.), b = pi;
@cout <<"plus, minus of "<<a<<" and "<<pi<<" are "<< a+b <<", "<< a-b << @endl;
@cout <<"multiplication, quotient of them are "<<a*b<<", "<<a/b<< @endl;
@cout <<"remainder from division of "<<a<<" by "<<b<<" is "<< a%b << @endl;
@cout <<"the minus of "<<a<<" is "<< -a << @endl;
@cout <<a<<" plus -"<<b<<" need bracket :"<<a<<"+(-"<<b<<")="<<a + (-b) << @endl;
\eT
gives the following output:
\bT
plus, minus of 1.41421 and 3.14159 are 4.55581, -1.72738
multiplication, quotient of them are 4.44288, 0.450158
remainder from division of 1.41421 by 3.14159 is 1
the minus of 1.41421 is -1.41421
1.41421 plus -3.14159 need bracket :1.41421+(-3.14159)=-1.72738
\eT

By the relation 
$$
bool\subset int \subset real\subset complex,
$$
the operators 
``$+,\, -,\, *,\, /$'' and ``\ttCC{\^}'' are also applicable in complex-type, 
but ``\%,\, max, min'' fall into disuse.
Complex number such as \texttt{5+9i},\, i$=\sqrt{-1}$, can be a little tricky.
For real variables \texttt{a=2.45, b=5.33}, we must write the complex numbers 
\texttt{a+b*i} and \ttCC{a+@sqrt(2.0)*i} as 
\bT
@complex z1 = a+b*1i, z2=a+@sqrt(2.0)*1i;
\eT 
The imaginary and real parts of complex number \texttt{z} is obtained by
\ttCC{@imag} and \ttCC{@real}.
The conjugate of $a+bi$ ($a,b$ are real) is defined by $a-bi$, which
is denoted by \ttCC{@conj(a+b*1i)} in \freefempp.

The complex number $z=a+ib$ is considered as
the pair $(a,b)$ of real numbers $a,\, b$.
Now we draw the point $(a,b)$ in the plane (Cartesian rectangular system
of axes) and mark on the $x$-axis the real numbers in the usual way, on the 
$y$-axis the imaginary numbers with $i$ as unit.
By changing Cartesian coordinate $(a,b)$ to the polar coordinate $(r,\phi)$,
the complex number $z$ has another expression $z=r(\cos \phi+i\sin\phi )$,
$r=\sqrt{a^2+b^2}$ and $\phi=\tan^{-1}(b/a)$;
$r$ is called the \key{absolute value} and $\phi$ the \key{argument} of $z$.
In the following example, we shall show them using \freefempp programming,
and \key{de Moivre's formula} $z^n=r^n(\cos n\phi+i\sin n\phi)$. 

\begin{example}~
\label{exm:complex}
\bFF
@real a=2.45, b=5.33;
@complex  z1=a+b*1i, z2 = a+sqrt(2.)*1i;
@func @string pc(@complex z) // printout complex to (real)+i(imaginary)
{
   @string r = "("+real(z);
   if (@imag(z)>=0) r = r+"+";
   @return r+@imag(z)+"i)";
}
// printout complex to |z|*(cos(arg(z))+i*sin(arg(z)))
@func @string toPolar(@complex z) 
{
   @return @abs(z)+"*(cos("+@arg(z)+")+i*sin("+@arg(z)+"))";
}
cout <<"Standard output of the complex "<<pc(z1)<<" is the pair "
     <<z1<<endl;
cout <<"Plus, minus of "<<pc(z1)<<" and "<<pc(z2)<<" are "<< pc(z1+z2) 
     <<", "<< pc(z1-z2) << endl;
cout <<"Multiplication, quotient of them are "<<pc(z1*z2)<<", "
     <<pc(z1/z2)<< endl;
cout <<"Real/imaginary part of "<<pc(z1)<<" is "<<@real(z1)<<", "
     <<@imag(z1)<<endl;
cout <<"Absolute of "<<pc(z1)<<" is "<<@abs(z1)<<endl;
cout <<pc(z2)<<" = "<<toPolar(z2)<<endl;
cout <<"  and polar("<<@abs(z2)<<","<<@arg(z2)<<") = "
     << pc(@polar(abs(z2),arg(z2)))<<endl;
cout <<"de Moivre's formula: "<<pc(z2)<<"^3 = "<<toPolar(z2^3)<<endl;
cout <<"conjugate of "<<pc(z2)<<" is "<<pc(@conj(z2))<<endl;
cout <<pc(z1)<<"^"<<pc(z2)<<" is "<< pc(z1^z2) << endl;
\eFF
Here's the output from Example \ref{exm:complex}
\bT
Standard output of the complex (2.45+5.33i) is the pair (2.45,5.33)
Plus, minus of (2.45+5.33i) and (2.45+1.41421i) are (4.9+6.74421i), (0+3.91579i) 
Multiplication, quotient of them are (-1.53526+16.5233i), (1.692+1.19883i)
Real/imaginary part of (2.45+5.33i) is 2.45, 5.33
Absolute of (2.45+5.33i) is 5.86612
(2.45+1.41421i) = 2.82887*(cos(0.523509)+i*sin(0.523509))
  and polar(2.82887,0.523509) = (2.45+1.41421i)
de Moivre's formula: (2.45+1.41421i)^3 
                         = 22.638*(cos(1.57053)+i*sin(1.57053))
conjugate of (2.45+1.41421i) is (2.45-1.41421i)
(2.45+5.33i)^(2.45+1.41421i) is (8.37072-12.7078i)
\eT
\end{example}

\subsection{\setS{One Variable Functions}}
\index{functions}
\begin{description}
  \item[Fundamental functions] are built into \freefempp. 
The \emph{power function} \ttCC{x\^}$\alpha (=x^\alpha)$; 
the \emph{exponent function} \ttCC{@exp(x)} ($=e^x$);
the \emph{logarithmic function} \ttCC{@log(x)}($=\ln x$) or 
\ttCC{@log10(x)} ($=\log_{10}x$);
the \emph{trigonometric functions} \ttCC{@sin(x), @cos(x), @tan(x)} 
depending on angles measured by \emph{radian};
the inverse of $\sin x,\, \cos x,\, \tan x$ called \emph{circular function} or \emph{inverse trigonometric function} \ttCC{@asin(x)}(=$\arcsin x$), \ttCC{@acos(x)}(=$\arccos x$), \ttCC{@atan(x)}(=$\arctan x$);
the \emph{hyperbolic function},
\[
\sinh x=\left( e^x-e^{-x}\right)/2,\qquad
\cosh x=\left( e^x+e^{-x}\right)/2.
\]
and $\tanh x=\sinh x/\cosh x$ written 
by \ttCC{@sinh(x)}, \ttCC{@cosh(x)}, \ttCC{@asinh(x)} and \ttCC{@acosh(x)}.
\[
\sinh^{-1}x=\ln \left[x+\sqrt{x^2+1}\right],\qquad 
\cosh^{-1}x=\ln \left[x+\sqrt{x^2-1}\right]. 
\]
\itemtt[Elementary Functions]
is the class of functions consisting of the functions in this section
(polynomials, exponential, logarithmic, trigonometric, circular) and 
the functions obtained from those listed by the four arithmetic operations 
\[
f(x)+g(x),\, f(x)-g(x),\, f(x)g(x),\, f(x)/g(x)
\]
and by superposition $f(g(x))$, in which four arithmetic operarions and superpositions are permitted finitely many times. 
In \freefempp, we can create all elementary functions.
The derivative of an elementary function is also elementary.
However, the indefinite integral of an elementary function cannot always be expressed in terms of elementary functions.
\begin{example}
The following give the example 
to make the boundary using elementary functions. 
\emph{Cardioid}
\bT
@real b = 1.;
@real a = b;
@func @real phix(@real t)
{
   @return (a+b)*cos(t)-b*cos(t*(a+b)/b);
}
@func @real phiy(@real t)
{
   @return (a+b)*sin(t)-b*sin(t*(a+b)/b);
}
@border C(t=0,2*pi) { x=phix(t); y=phiy(t); }
@mesh Th = @buildmesh(C(50));
\eT
\end{example}
Taking the principal value, we can define $\log z$ for $z\neq 0$ by
\[
\ln z = \ln |z|+\arg z.
\]
Using \freefempp, we calculated 
\ttCC{@exp(1+4i)}, \ttCC{@sin(pi+1i)}, \ttCC{@cos(pi/2-1i)} and \ttCC{@log(1+2i)}, we then have
\begin{eqnarray*}
-1.77679-2.0572i,& 1.88967 10^{-16}-1.1752i,\\
9.44833 10^{-17}+1.1752i, & 0.804719+1.10715i.
\end{eqnarray*}
\end{description}

\subsection{Two Variable Functions}
\label{sec:TwoVarFunctions}
\subsubsection{\setS{Formula}}
The general form of real functions with two independent variables $x,\, y$ is
usually written as $z=f(x,y)$. In \freefempp, \ttCC{x} and \ttCC{y} are 
reserved word in Section \ref{sec:Global}.
When two independent variables are \ttCC{x} and \ttCC{y}, 
we can define a function without argument, for example
\bT
@func f=@cos(x)+@sin(y) ;
\eT
Remark the function's type is given by the expression's type.
The power of functions are given in \freefempp such as 
\ttCC{x\^{}1}, \ttCC{y\^{}0.23}.
In \ttCC{func}, we can write an elementary function as follows
\bT
@func f = @sin(x)*@cos(y);
@func g = (x^2+3*y^2)*@exp(1-x^2-y^2);
@func h = @max(-0.5,0.1*@log(f^2+g^2));
\eT

Complex valued function create functions with 2 variables \ttCC{x, y} as follows,
\bT
@mesh Th=square(20,20,[-pi+2*pi*x,-pi+2*pi*y]); // $]-\pi,\pi[^2$
@fespace Vh(Th,P2);
@func z=x+y*1i;  // $z=x+iy$
@func f=@imag(sqrt(z));  // $f=\Im\sqrt{z}$
@func g=@abs( sin(z/10)*exp(z^2/10) ); // $g=|\sin z/10\exp z^2/10|$
Vh fh = f; plot(fh);  // contour lines of $f$
Vh gh = g; plot(gh);  // contour lines of $g$
\eT
We call also by \emph{two variable elementary function} functions
obtained from elementary functions $f(x)$ or $g(y)$ 
by the four arithmetic operations 
and by superposition in finite times.

\subsubsection{\setS{FE-function}}\index{FE-function}
Arithmetic built-in functions are able to construct a new function by  
the four arithmetic operations and superposition of them
(see \emph{elementary functions}), which are called 
\key{formulas} to distinguish from 
FE-functions.
We can add \emph{new formulas} easily, if we want.
Here, FE-function is an element of
finite element space (real or complex) (see Section \refSec{Finite Elements}).
Or to put it another way: \emph{formulas} are the 
mathematical expressions combining its numerical analogs, but
it is independent of meshes (triangulations).

Also, in \texttt{freefem++}, we can give an arbitrary symbol to FE-function
combining numerical calculation by FEM.
The projection of a formula $f$ to FE-space is done as in
\bT
func f=x^2*(1+y)^3+y^2;
mesh Th = square(20,20,[-2+2*x,-2+2*y]); // square $]-2,2[^2$
fespace Vh(Th,P1);
Vh fh=f;  // fh is the  projection of f to Vh (real value)
func zf=(x^2*(1+y)^3+y^2)*exp(x+1i*y);
Vh<complex> zh = zf; // zh is the projection of zf 
// to complex value Vh space   \index{FE function!complex}
\eT
The construction of \ttCC{fh} (=$f_h$) is explained in
\refSec{Finite Elements}.

\begin{note}
The command \ttCC{@plot} is valid only for real  FE-functions.
\end{note}
Complex valued function create functions with 2 variables \ttCC{x, y} as follows,
\bT
@mesh Th=square(20,20,[-pi+2*pi*x,-pi+2*pi*y]); // $]-\pi,\pi[^2$
@fespace Vh(Th,P2);
@func z=x+y*1i;  // $z=x+iy$
@func f=@imag(sqrt(z));  // $f=\Im\sqrt{z}$
@func g=@abs( sin(z/10)*exp(z^2/10) ); // $g=|\sin z/10\exp z^2/10|$
Vh fh = f; plot(fh);  // Fig. \ref{cfunc1} isovalue of $f$
Vh gh = g; plot(gh);  // Fig. \ref{cfunc2} isovalue of $g$
\eT
\twoplot[height=5cm]{cfunc1}{cfunc2}{$\Im\sqrt{z}$ has branch}
{$|\sin (z/10)\exp (z^2/10)|$}

\subsection{Array}
\index{array}
An \emph{array} stores multiple objects, and
there are 2 kinds of arrays:
The first is the \emph{vector} that is arrays with \emph{integer indices}
and
arrays with \emph{string indices}.

In the first case, the size of this array
must be know at the execution time, and the implementation is done
with the \ttCC{KN<>} class so all the vector operator of
 \ttCC{KN<>} are implemented. The sample
\bT
@real [int] tab(10), tab1(10); // 2 array of 10 real
@real [int] tab2;    //  bug array with no size
tab = 1.03;                //  set all the array to 1.03
tab[1]=2.15;
@cout << tab[1] << " " << tab[9] << " size of tab = "
     << tab.n << " min: " << tab.min << "  max:" << tab.max 
     << " sum : "   << tab.sum <<   endl; //      
tab.resize(12); //  change the size of array tab 
  // to 12 with preserving first value 
tab(10:11)=3.14; //  set unset value 
cout <<" resize tab: " <<  tab << endl;  
\eT
\index{array!resize}\index{resize}\index{max}\index{array!max} \index{min}\index{array!min}\index{sum}\index{array!sum}
produce the output
\bT
2.15 1.03 size of tab = 10 min: 1.03  max:2.15 sum : 11.42
 resize tab: 12
        1.03    2.15    1.03    1.03    1.03
        1.03    1.03    1.03    1.03    1.03
        3.14    3.14
\eT

It is also possible to make an array of FE function, with the same syntax, 
and we can treat them as \emph{vector valued function} if we need them.
\index{array}\index{array!FE function}
\begin{example}
In the following example, Poisson's equation is solved under 3 different given 
functions $f=1,\, \sin(\pi x)\cos(\pi y),\, |x-1||y-1|$, whose solutions are
stored in an array of FE function.
\bT
@mesh Th=@square(20,20,[2*x,2*y]);
@fespace Vh(Th,P1);
Vh u, v, f;
@problem @Poisson(u,v) = 
    @int2d(Th)( @dx(u)*@dx(v) + @dy(u)*@dy(v))
     + @int2d(Th)( -f*v ) + @on(1,2,3,4,u=0) ;
Vh[int] uu(3); // an array of FE function
f=1;   // problem1
Poisson; uu[0] = u;
f=sin(pi*x)*cos(pi*y);  // problem2
Poisson; uu[1] = u;
f=abs(x-1)*abs(y-1);    // problem3
Poisson; uu[2] = u;
@for (int i=0; i<3; i++)  // plots all solutions
  @plot(uu[i], @wait=true);
\eT
\end{example}

 For the second case, it is just
 a map of the STL\footnote{Standard template Library, now part of standard \Cpp}\cite{STL}
 so no vector operation except the
 selection of an item is allowed . \index{dot product}\index{transpose}

The transpose operator is \texttt{\string'} like  MathLab or SciLab, so the way 
to compute the dot product of two array \ttCC{a,b} is  \ttCC{@real\ ab=\ a'*b}\index{product!dot}.
\index{min}\index{array!min}
\bFF
@int i;
@real [int] tab(10), tab1(10); // 2 array of 10 real
  \it  real [int] tab2;    //  bug array with no size
tab = 1;                //  set all the array to 1
tab[1]=2;
@cout << tab[1] << " " << tab[9] << " size of tab = " 
     << tab.n << " " << tab.min << " " << tab.max << " " <<  @endl;
tab1=tab;
tab=tab+tab1;
tab=2*tab+tab1*5;
tab1=2*tab-tab1*5;
tab+=tab;
@cout << " dot product " << tab'*tab << @endl; //  ${}^{t}{tab}\,{tab} $ 
@cout << tab << @endl;
@cout << tab[1] << " " << tab[9] <<  @endl;
@real[string] map;        //  a dynamique array
@for (i=0;i<10;i=i+1)
  {
    tab[i] = i*i;
    @cout << i << " " << tab[i] << "\n";
  };

map["1"]=2.0;
map[2]=3.0;             //  2 is automatically cast to the string "2"

@cout << " map[\"1\"] = " << map["1"] << "; "<< @endl;
@cout << " map[2] = " << map[2] << "; "<< @endl;
\eFF


\subsection{\setS{Loops}}

The \texttt{for} and \texttt{while}  loops are implemented
with \texttt{break} and \texttt{continue} keywords.
\index{for}\index{while}
\index{break}\index{continue}

In for-loop, there are three parameters; 
the INITIALIZATION of a control variable, 
the CONDITION to continue, 
the CHANGE of the control variable.
While \texttt{CONDITION} is true, for-loop continue.
\bT
@for (INITIALIZATION; CONDITION; CHANGE)
     { BLOCK of calculations }
\eT
The sum from 1 to 10 is calculated by (the result is in \ttCC{sum}),
\bT
@int sum=0;
@for (@int i=1; i<=10; i++)
   sum += i;
\eT
The while-loop
\bT
@while (CONDITION) {
   BLOCK of calculations or change of control variables
}
\eT
is executed repeatedly until CONDITION become false.
The sum from 1 to 10 is also written by \ttCC{@while} as follows,
\bT
@int i=1, sum=0;
@while (i<=10) {
  sum += i; i++;
}
\eT

We can exit from a loop in midstream by \ttCC{@break}.
The \ttCC{@continue} statement will pass the part from 
\emph{continue} to the end of the loop. 

\begin{example}~
\bFF
@for (@int i=0;i<10;i=i+1)
    @cout << i << "\n";
@real eps=1;
@while (eps>1e-5)
 { eps = eps/2;
   @if( i++ <100) @break;
   @cout << eps << @endl;}

@for (int j=0; j<20; j++) {
   @if (j<10) @continue;
   @cout << "j = " << j << @endl;
}
\eFF
\end{example}

\subsection{\setS{Input/Output}}
\index{cout}\index{cint}\index{ifstream}\index{ofstream}\index{endl}

The syntax of input/output statements is similar  to \Cpp syntax. It
uses \ttCC{@cout}, \ttCC{@cin}, \ttCC{@endl}, \ttCC{<<,>>}.

To write  to (resp. read from)  a file, \index{$<<$} \index{$>>$}\index{append}\index{ofstream!append}
declare a new variable \texttt{ofstream ofile("filename");} or \texttt{ofstream ofile("filename",append);} (resp.
\texttt{ifstream ifile("filename");} ) and use \texttt{ofile}  (resp. \texttt{ifile})
as \texttt{cout} (resp. \texttt{cin}). The word \texttt{append} in  \texttt{ofstream ofile("filename",append);} 
 means openning a file in append mode.

\begin{note} The file is closed
at the exit of the enclosing block, 
\end{note}
\begin{example}~
\label{exm:io}
\bFF
@int i;
@cout << " std-out" << @endl;
@cout << " enter i= ? ";
@cin >> i ;
{
  @ofstream f("toto.txt");
  f << i << "coucou'\n";
}; //  close the file f because the variable f is delete

{
  @ifstream f("toto.txt");
   f >> i;
}
{
  @ofstream f("toto.txt",append); 
     // to append to the existing file "toto.txt"
  f << i << "coucou'\n";
}; //  close the file f because the variable f is delete

  @cout << i << @endl;
\eFF
\end{example}

\section{\setS{Mesh Generation}}
\subsection{Commands for Mesh Generation}\label{sec:InitialMesh}
In Step1 in Section \ref{sec:example}, the keywords 
\texttt{\bf border, buildmesh}
are explained.
%square, 
%,  movemesh ,
% adaptmesh, readmesh, trunc, triangulate, splitmesh, emptymesh}
%
%The following keywords are discussed in this section:
%
%\texttt{\bf square, border, buildmesh,  movemesh ,
% adaptmesh, readmesh, trunc, triangulate, splitmesh, emptymesh}
%
% \index{square}\index{border}\index{buildmesh}\index{movemesh}\index{adaptmesh}
% \index{readmesh}\index{triangulate}\index{splitmesh}\index{emptymesh}
 
All the examples in this section come from the files \texttt{mesh.edp}
and \texttt{tablefunction.edp}.

\subsubsection{\setS{Square}}

For easy and simple testing, there is the command 
``\texttt{\bf square}''.
The following
\bT
@mesh Th = @square(4,5);
\eT
generate a $4\times 5$ grid in the unit squre $[0,1]^2$ whose labels
are shown in Fig. \ref{fig:square}.
\begin{figure}[htbp]
\begin{center}
  \includegraphics[height=5cm]{figures/square}
\end{center}
  \caption{Boundary labels of the mesh by \texttt{square(10,10)}}
  \label{fig:square} \index{label}
\end{figure}
If you want constructs a 
$n\times m$ grid in the rectangle $[x_0,x_1]\times [y_0,y_1]$, you can
write
\bFF
  @real x0=1.2,x1=1.8;
  @real y0=0,y1=1;
  @int n=5,m=20;
  @mesh Th=@square(n,m,[x0+(x1-x0)*x,y0+(y1-y0)*y]);
\eFF
 \begin{note}
You must notice that if you adding the name parameter \texttt{flags=1}, you  get a 
Union Jack fags mesh pattern. \index{square!flags=} 
\bFF
  @mesh Th=@square(n,m,[x0+(x1-x0)*x,y0+(y1-y0)*y],flags=1);  
\eFF
\end{note}



\subsubsection{\setS{Border}}\index{border}\index{label}

A domain is defined as being on the left (resp right) of its
parameterized boundary 
$$
\Gamma_j=\{(x,y)\left|\; x=\varphi_x(t),\, y=\varphi_y(t),\, a_j\le t\le b_j\right.\}
$$
We can easily check the orientation by drawing the curve 
$t\mapsto (\varphi_x(t),\varphi_y(t)),\, t_0\le t\le t_1$.
If the figure become like to Fig. \ref{fig:border}, then 
the domain lie on the shaded area, otherwise it lie on opposite side
(see also the examples enclosed with the box).
The boundaries $\Gamma_j$ can only intersect at their end points.

\begin{figure}[htbp]
\begin{center}
  \includegraphics[height=4cm]{figures/border}
\end{center}
  \caption{Orientation of the boundary defined by $(\phi_x(t),\phi_y(t))$}
  \label{fig:border} \index{border}
\end{figure}
The general expression of the triangulation is 
\[
\ttCC{@mesh  ~~Mesh\_Name = @buildmesh$\left(\Gamma_1(m_1)+\cdots+\Gamma_J(m_j)\right)$;}
\]
where $m_j$ are numbers of marked points on $\Gamma_j,\, 
\Gamma=\cup_{j=1}^J \Gamma_J$.
We can change the orientation of boundaries by changing the sign of $m_j$.
The following example shows how to change the orientation.
The example generates the unit disk
with a small circular hole, and assign ``1'' to the unit disk 
(``2'' to the circle inside). 
The boundary label must be non-zero, however we can omit the label 
if we want use only the symbol.

\bFF
1: @border a(t=0,2*pi){ x=cos(t); y=sin(t);label=1;}
2: @border b(t=0,2*pi){ x=0.3+0.3*cos(t); y=0.3*sin(t);label=2;}
3: @plot(a(50)+b(+30)) ; // to see a plot of the border mesh \index{plot!border} 
4: @mesh Thwithouthole= @buildmesh(a(50)+b(+30));
5: @mesh Thwithhole   = @buildmesh(a(50)+b(-30));
6: @plot(Thwithouthole,wait=1,ps="Thwithouthole.eps"); //figure \ref{Thwithouthole}\index{plot!mesh}
7: @plot(Thwithhole,wait=1,ps="Thwithhole.eps"); // figure \ref{Thwithhole}
\eFF
\begin{note}
You must notice that the orientation is changed by ``\texttt{b(-30)}'' in 5th line. In 7th line, \texttt{ps="fileName"} is used to generate a postscript file
identification that is shown on screen.
\end{note}

\twoplot[height=6cm]{Thwithouthole}{Thwithhole}{mesh without hole}{mesh with hole}

\subsubsection{Data Structure of Mesh and Reading/Writing a Mesh}

\index{readmesh}\index{savemesh} 
Some user asked us that they want use the triangulation made from other tools
or hand-made mesh.
The example
\bT
@border C(t=0,2*pi) { x=cos(t); y=sin(t); }
@mesh Th = @buildmesh(C(10));
@savemesh("mesh_sample.msh");
\eT
make the mesh as in Fig. \ref{fig:meshSample}. 
The informations about \texttt{Th} are save in the file ``mesh\_sample.msh''.

We can read from Fig. \ref{fig:meshSample} and ``mesh\_sample.msh'' 
as in Table \ref{tab:meshSample} where $n_v$ is 
the number of vertices, $n_t$ number of triangles 
and $n_s$ the number of edges on boundary.
For each vertex $q^i,\, i=1,\cdots,n_v$, we denote by $(q^i_x,q^i_y)$ 
the $x$-coordinate and $y$-coordinate.

Each triangle $T_k, k=1,\cdots,10$ have three vertices $q^{k_1},\, q^{k_2},\,q^{k_3}$ that are oriented in counterclockwise. 
The boundary consists of 10 lines $L_i,\, i=1,\cdots,10$ whose tips are
$q^{i_1},\, q^{i_2}$.

\begin{figure}[htbp]
\begin{minipage}{\textwidth}
\begin{minipage}{0.5\textwidth}
\includegraphics[width=\textwidth]{figures/mesh_sample}%
\caption{mesh by \texttt{buildmesh(C(10))}}
\label{fig:meshSample}
\end{minipage}
\hspace{0.5mm}
\begin{minipage}{0.5\textwidth}
In the left figure, we have the following.\\\\
$n_v=14,\, n_t=16,\, n_s=10$\\\\
$q^1=(-0.309016994375,\, 0.951056516295)$\\
$\vdots\qquad \vdots\qquad \vdots$\\
$q^{14}=(-0.309016994375,\, -0.951056516295)$\\\\
The vertices of $T_1$ are $q^9,\, q^{12},\, q^{10}$.\\
$\vdots\qquad \vdots\qquad \vdots$\\
The vertices of $T_{16}$ are $q^9,\, q^{10},\, q^{6}$.\\\\
The edge of 1st side $L_1$ are $q^6,\, q^5$.\\
$\vdots\qquad \vdots\qquad \vdots$\\
The edge of 10th side $L_{10}$ are $q^{10},\, q^6$.\\
\end{minipage}
\end{minipage}
\end{figure}

\begin{table}[htbp]
\begin{tabular}{|l|l|}
\hline
Contents of file&Explanation\\
\hline
14 16 10& $n_v$\qquad  $n_t$\qquad $n_e$\\
-0.309016994375 0.951056516295 1& $q^1_x$\qquad $q^1_y$\qquad boundary label=1\\
0.309016994375 0.951056516295 1& $q^2_x$\qquad $q^2_y$\qquad boundary label=1\\
$\cdots$  $\cdots$ $\vdots$& \\
-0.309016994375 -0.951056516295 1& $q^{14}_x$\qquad $q^{14}_y$\qquad boundary label=1\\
\hline
9 12 10 0&$1_1$\quad $1_2$\quad $1_3$\quad region label=0 \\
5 9 6 0&$2_1$\quad $2_2$\quad $2_3$\quad region label=0  \\
$\cdots$& \\
9 10 6 0&$16_1$\quad $16_2$\quad $16_3$\quad region label=0 \\
\hline
6 5 1&$1_1\quad 1_2$\quad boundary label=1\\
5 2 1&$2_1\quad 2_2$\quad boundary label=1\\
$\cdots$& \\
10 6 1&$10_1\quad 10_2$\quad boundary label=1\\
\hline
\end{tabular}
  \caption{The structure of ``mesh\_sample.msh''}
  \label{tab:meshSample}
\end{table}

There are many mesh file formats available for communication with
other tools such as emc2, modulef.. (see \refSec{Mesh Files}),
The extension of a file gives the chosen
type.\index{bamg} More details can be found in the article by F. Hecht
"bamg : a bidimentional anisotropic mesh generator" available from the
FreeFem web site.  \\

The following give the example write and read files of generated mesh,
Freefem can read and write files. A
mesh file can be read back into \freefempp but the names of the
borders are lost. So these borders have to be referenced by the number
which corresponds to their order of appearance in the program, unless
this number is forced by the keyword "label".

\bFF
@border floor(t=0,1){ x=t; y=0; label=1;}; // the unit square
@border right(t=0,1){ x=1; y=t; label=5;};
@border ceiling(t=1,0){ x=t; y=1; label=5;};
@border left(t=1,0){ x=0; y=t; label=5;};
@int n=10;
@mesh th= buildmesh(floor(n)+right(n)+ceiling(n)+left(n));
@savemesh(th,"toto.am_fmt");  // "formatted Marrocco" format \index{file!am\_fmt}
@savemesh(th,"toto.Th");      // "bamg"-type mesh   \index{file!bamg}
@savemesh(th,"toto.msh");     // freefem format \index{file!mesh} 
@savemesh(th,"toto.nopo");     // modulef format \index{file!nopo} see \cite{modulef}
@mesh th2 = readmesh("toto.msh"); // read the mesh 

\eFF

The following example explains methods to obtain mesh information. 
\index{triangle![]}\index{triangle!label}\index{triangle!label}
\index{vertex!x}\index{vertex!y}\index{vertex!label}
\bFF
{  // get mesh information (version 1.37)
  @mesh Th=square(2,2);
  // get data of the mesh
  @int nbtriangles=Th.nt;
  @for (@int i=0;i<nbtriangles;i++)
    @for (@int j=0; j <3; j++)
      @cout << i << " " << j << " Th[i][j] = "
           << Th[i][j] << "  x = "<< Th[i][j].x  << " , y= "<< Th[i][j].y
           << ",  label=" << Th[i][j].label << endl;
           
  // To Day:   this Hack works: to get x,y of vertex i \hfilll
  // remark: i can be set with i= Th[it][j] \hfilll
  // the idea is to build de interpolation of x and y function \hfilll
  // with 2 array now given i -> x and i-> y. \hfilll

  fespace femp1(Th,P1);
  femp1 Thx=x,Thy=y;
  cout << " nb of vertices = " << nbvertices << endl;
  for (int i=0;i<nbvertices;i++)
        cout << i  << " : " << Thx[][i] << " " << Thy[][i] << endl;

  //Hack  to get a triangle number of mesh contening point x,y \hfilll
  //     or  region number \hfilll
  // ----------------------------------------- \hfilll
  fespace femp0(Th,P0);
  femp0 nuT; // a P0 function  to get triangle numbering
    for (int i=0;i<Th.nt;i++)
     nuT[][i]=i;
  femp0 nuReg=region; // a P0 function to get the region number
  //  inquire
  int it0=nuT(0.55,0.6); //  number of triangle contening point (0.55,0,6);
  int nr0=nuReg(0.55,0.6); //  number of region of mesh contening point (0.55,0,6);
  // new method if   version > 1.450007
  int it00 = Th(0.55,0.6).nuTriangle; // get the number of Th's triangle contening (0.55,0.6)
  int nr00 = Th(0.55,0.6).region;; // get the region  number of Th's triangle 
    // dump
  cout << "  point (0.55,0,6) :triangle number " << it0 << " " << it00
       << ", region = " << nr0 << " == " << nr00 << endl;                     
}

\eFF
the output is:
\bFF
0 0 Th[i][j] = 0  x = 0 , y= 0,  label=4
0 1 Th[i][j] = 1  x = 0.5 , y= 0,  label=1
0 2 Th[i][j] = 4  x = 0.5 , y= 0.5,  label=0
1 0 Th[i][j] = 0  x = 0 , y= 0,  label=4
1 1 Th[i][j] = 4  x = 0.5 , y= 0.5,  label=0
1 2 Th[i][j] = 3  x = 0 , y= 0.5,  label=4
.......
5 2 Th[i][j] = 6  x = 0 , y= 1,  label=4
6 0 Th[i][j] = 4  x = 0.5 , y= 0.5,  label=0
6 1 Th[i][j] = 5  x = 1 , y= 0.5,  label=2
6 2 Th[i][j] = 8  x = 1 , y= 1,  label=3
7 0 Th[i][j] = 4  x = 0.5 , y= 0.5,  label=0
7 1 Th[i][j] = 8  x = 1 , y= 1,  label=3
7 2 Th[i][j] = 7  x = 0.5 , y= 1,  label=3
 Nb Of Nodes = 9
 Nb of DF = 9
 -- vector function's bound  -0 1
 -- vector function's bound  -0 1
 nb of vertices = 9
0 : -0 -0
1 : 0.5 -0
2 : 1 -0
3 : -0 0.5
4 : 0.5 0.5
5 : 1 0.5
6 : -0 1
7 : 0.5 1
8 : 1 1
 Nb Of Nodes = 8
 Nb of DF = 8
 -- vector function's bound  -0 -0
  point (0.55,0,6) :triangle number 7 7, region = 0 == 0
\eFF
\begin{example}[Readmesh.edp]
\index{tutorial!readmesh.edp}
\index{read files}
\index{write files}
\bFF
@border floor(t=0,1){ x=t; y=0; label=1;}; // the unit square
@border right(t=0,1){ x=1; y=t; label=5;};
@border ceiling(t=1,0){ x=t; y=1; label=5;};
@border left(t=1,0){ x=0; y=t; label=5;};
@int n=10;
@mesh th= buildmesh(floor(n)+right(n)+ceiling(n)+left(n));
@savemesh(th,"toto.am_fmt");  // format "formated Marrocco" \index{file!am\_fmt}
@savemesh(th,"toto.Th");      // format database  db mesh "bamg"   \index{file!bamg}
@savemesh(th,"toto.msh");     // format freefem \index{file!mesh}
@savemesh(th,"toto.nopo");     // modulef format \index{file!nopo} see \cite{modulef}
@mesh th2 = readmesh("toto.msh");
@fespace femp1(th,@P1);
femp1 f = sin(x)*cos(y),g;
{ // save solution
@ofstream file("f.txt");
file << f[] << endl;
}  // close the file (end block)
{  // read
@ifstream file("f.txt");
file >> g[] ;
} // close reading file (end block)
@fespace Vh2(th2,P1);
Vh2 u,v;
@plot(g);
@solve pb(u,v) =
    @int2d(th)( u*v - dx(u)*dx(v)-dy(u)*dy(v) )
  + @int2d(th)(-g*v)
  + @int1d(th,5)( g*v)
  + @on(1,u=0) ;
@plot (th2,u);
\eFF
\end{example}

\subsubsection{Triangulate}\index{triangulate}

\freefempp is able to build a triangulation from a set of points. This 
triangulation is a Delaunay mesh of the convex hull of the set of points.
It can be useful to build a mesh form a table function.

The coordinates of the points and the value of the table function 
are defined separately with rows of the form: \texttt{x y f(x,y)} 
in a file such as:

\bFF
0.51387 0.175741 0.636237
0.308652 0.534534 0.746765
0.947628 0.171736 0.899823
0.702231 0.226431 0.800819
0.494773 0.12472 0.580623
0.0838988 0.389647 0.456045
...............
\eFF
%%% Thxy.eps not found
\twoplot[height=4cm]{Thxy}{xyf}{Delaunay mesh of the convex hull of point set in file xyf}{Isovalue of table function}

The third column of each line is left untouched by the
\texttt{triangulate} command. But you can use this third value to
define a table function with rows of the form: \texttt{x y f(x,y)}.


The following example shows how to make mesh from the file ``xyf'' 
with the format stated just above. 
The command
\texttt{triangulate} command use only use 1st and 2nd rows.

\index{function!tables}

\bFF
@mesh Thxy=triangulate("xyf"); // build the Delaunay mesh of the convex hull 
// points are defined by the first 2 columns of file \texttt{xyf}
@plot(Thxy,ps="Thxyf.ps"); // (see figure  \ref{Thxy})

@fespace Vhxy(Thxy,P1); // create a P1 interpolation 
Vhxy fxy; // the function

// reading the 3rd row to define the function
{ @ifstream file("xyf");
   @real xx,yy;
   @for(@int i=0;i<fxy.n;i++)
   file >> xx >>yy >> fxy[][i];  // to read third row only. 
   // xx and yy are just skipped
}
@plot(fxu,ps="xyf.eps"); // plot the function (see figure  \ref{xyf})
\eFF

\subsection{build empty mesh}\index{emptymesh}
When you want to define Finite Element space on boundary, 
we come up with the idea of a mesh with no internal points (call empty mesh).
It can be useful when you have a Lagrange multiplier definied on the border.

So the function emptymesh remove all the internal point of a mesh expect if the
point is on internal boundary.

\bFF
{  //  new stuff 2004 emptymesh (version 1.40)
 // -- useful to build Multiplicator space 
 //  build a mesh without internal point
 // with the same boundary 
 //  -----
  assert(version>=1.40);
  @border a(t=0,2*pi){ x=cos(t); y=sin(t);label=1;}
  @mesh Th=buildmesh(a(20));
   Th=@emptymesh(Th);
  @plot(Th,wait=1,ps="emptymesh-1.eps");//see figure \ref{fig emptymesh-1}
}
\eFF

or it is also possible to build a empty mesh of peusdo subregion  
with \texttt{emptymesh(Th,ssd)} with the set of edges of the mesh \texttt{Th}
a edge $e$ is in  this set  if the two adjacent triangles $e =t1\cap t2$ 
and  $ ssd[T1] \neq ssd[T2]$ where \texttt{ssd}  defined the peusdo region numbering of triangle, when they are stored in \texttt{int[int]} array of size the number of triangles.
\bFF
{  //  new stuff 2004 emptymesh (version 1.40) \hfilll
 // -- useful to build Multiplicator space \hfilll
 //  build a mesh without internal point \hfilll
 // of peusdo sub domain  \hfilll
 //  ----- \hfilll
  assert(version>=1.40);
  mesh Th=square(10,10);
  int[int] ssd(Th.nt);  
  for(int i=0;i<ssd.n;i++) // build the  peusdo region numbering
   {  int iq=i/2;   // because 2 traingle per quad 
      int ix=iq%10; // 
      int iy=iq/10; // 
    ssd[i]= 1 + (ix>=5) +  (iy>=5)*2;
   }
  Th=emptymesh(Th,ssd); // build emtpy  with 
  //  all edge $e = T1 \cap T2$ and $ ssd[T1] \neq ssd[T2]$ 
  plot(Th,wait=1,ps="emptymesh-2.eps");//see figure \ref{fig emptymesh-2} 
  savemesh(Th,"emptymesh-2.msh");
}
\eFF

\twoplot[height=6cm]{emptymesh-1}{emptymesh-2}{ The empty mesh with boundary 
\label{fig emptymesh-1}}{An empty mesh 
defined from a peusdo region numbering of triangle\label{fig emptymesh-2}}

\subsection{Remeshing}
\subsubsection{\setS{Movemesh}}\index{movemesh}\index{checkmovemesh}
After solving the elasticity, we want watch the deformation 
$\Omega\mapsto\Phi(\Omega)$, 
$\vec\Phi(x,y)=(\Phi_1(x,y),\Phi_2(x,y))$ of shape.
In free boundary value problems, the shape of domain will vary.

If $\Omega$ is triangulated already -- dubbed $T_h(\Omega)$,
then we want $\Phi(\Omega)$ is also triangulated automatically.
This want is satisfied by
\bT
@mesh  Th=@movemesh(Th,[$\Phi$1,$\Phi$2]);
\eT
where $\Phi=(\Phi_1,\Phi_2)$ and $\Phi_i,\, i=1,2$ are functions. 
Sometimes the moved mesh is invalid because some triangle
becomes reversed (with a negative area). This is why we check the
minimum triangle area in the transformed mesh with
\texttt{checkmovemesh} before any real transformation.

\begin{example} $\Phi_1(x,y)=x+k*\sin(y*\pi)/10)$, 
$\Phi_2(x,y)=y+k*\cos(y\pi)/10)$ for a big number $k>1$.
\bFF
verbosity=4;
@border a(t=0,1){x=t;y=0;label=1;};
@border b(t=0,0.5){x=1;y=t;label=1;};
@border c(t=0,0.5){x=1-t;y=0.5;label=1;};
@border d(t=0.5,1){x=0.5;y=t;label=1;};
@border e(t=0.5,1){x=1-t;y=1;label=1;};
@border f(t=0,1){x=0;y=1-t;label=1;};
@func uu= sin(y*pi)/10;
@func vv= cos(x*pi)/10;

@mesh Th = buildmesh ( a(6) + b(4) + c(4) +d(4) + e(4) + f(6));
@plot(Th,wait=1,fill=1,ps="Lshape.eps");// see figure \ref{lshape}
@real coef=1;  
@real minT0= checkmovemesh(Th,[x,y]); // the min triangle area
@while(1) // find a correct move mesh 
{
  @real minT=@checkmovemesh(Th,[x+coef*uu,y+coef*vv]);//the min triangle area
  if (minT > minT0/5) break ; // if big enough 
  coef=/1.5; 
}

Th=@movemesh(Th,[x+coef*uu,y+coef*vv]);
@plot(Th,wait=1,fill=1,ps="movemesh.eps");// see figure \ref{movemesh}
\eFF

\twoplot[height=6cm]{lshape}{movemesh}{L-shape}{  moved L-shape }
\end{example}
\begin{note}
Consider a function $u$ defined on a mesh \texttt{Th}. A statement like
\texttt{Th=movemesh(Th...)} does not change $u$ and so the old mesh
still exists. It will be destroyed when no function use it. A
statement like $u=u$ redefines $u$ on the new mesh \texttt{Th} with
interpolation and therefore destroys the old \texttt{Th} if $u$ was the only
function using it.
\end{note}

\begin{example}[movemesh.edp]
\index{tutorial!movemesh.edp}
Now, we given an example of moving mesh with lagrangian\index{lagrangian}
function $u$ defined on the moving mesh.

\bFF
// simple movemesh example
@mesh Th=square(10,10);
@fespace Vh(Th,P1); 
@real t=0;
// ---
//  the problem is how to build data without interpolation
//  so the data u is moving with the mesh as you can see in the plot
// ---
Vh u=y;
@for (int i=0;i<4;i++)
{ 
 t=i*0.1;
 Vh f= x*t;
 @real minarea=checkmovemesh(Th,[x,y+f]);
 if (minarea >0 ) // movemesh will be ok 
   Th=movemesh(Th,[x,y+f]);

 cout << " Min area  " << minarea << endl;
 
 real[int] tmp(u[].n);
 tmp=u[];  // save the value  
 u=0;        // to change the FEspace and mesh associated with u
 u[]=tmp;  // set the value of u without any mesh update 
 @plot(Th,u,wait=1);
};
// In this program, since u is only defined on the last mesh, all the \hfilll
// previous meshes are deleted from memory.  \hfilll
//   --------  \hfilll
\eFF
\end{example}

\subsection{\setS{Regular Triangulation}}
For a set $S$, we define the diameter of $S$ by
\[
\textrm{diam}(S)=\sup\{|\vec{x}-\vec{y}|; \; \vec{x},\, \vec{y}\in S\}
\]
The sequence $\{\mathcal{T}_h\}_{h\downarrow 0}$ of $\Omega$ is called 
\emph{regular}\index{mesh!regular} if they satisfy the following:
\begin{enumerate}
  \item 
\[
\lim_{h\downarrow 0}\max\{\textrm{diam}(T_k)|\; T_k\in \mathcal{T}_h\}
\]
  \item
There is a number $\sigma>0$ independent of $h$ such that
\[
\frac{\rho(T_k)}{\textrm{diam}(T_k)}\ge \sigma
\qquad \textrm{for all }T_k\in \mathcal{T}_h
\]
where $\rho(T_k)$ are the diameter of the inscribed circle of $T_k$.
\end{enumerate}
We put $h(\mathcal{T}_h)=\max\{\textrm{diam}(T_k)|\; T_k\in \mathcal{T}_h\}$, 
which is obtained by 
\bT
@mesh Th = ......;
@fespace Ph(Th,P0);
Ph h = hTriangle;
@cout << "size of mesh = " << h[].max << @endl;
\eT

\subsection{Adaptmesh}\index{adaptmesh}
\label{sec:Adaptmesh}
The function
\[
f(x,y) = 10.0x^3+y^3+\tan^{-1}[\epsilon/(\sin(5.0y)-2.0x)]
\qquad \epsilon =  0.0001
\]
sharply vary its value. 
However, the initial mesh given by the command in Section \ref{sec:InitialMesh}
cannot reflect its sharp variation.
\begin{example}~
\bFF
@real eps =  0.0001;
@real h=1;
@real hmin=0.05;
@func f = 10.0*x^3+y^3+h*atan2(eps,sin(5.0*y)-2.0*x);

@mesh Th=square(5,5,[-1+2*x,-1+2*y]);
@fespace Vh(Th,P1);
Vh fh=f;
@plot(fh);
for (@int i=0;i<2;i++)
 {
   Th=@adaptmesh(Th,fh);
   fh=f;  // old mesh is deleted
   @plot(Th,fh,wait=1);
 }
\eFF
\end{example}
\plot[height=6cm]{adaptmesh}{3D graph under the initial mesh and after of 1st and 2nd adaptation}

\freefempp uses a variable metric/Delaunay automatic meshing
algorithm.
The command
\bT
@mesh ATh = @adaptmesh(Th, f);
\eT
create the new mesh \texttt{ATh} by the Hessian 
$$
D^2f=(\partial^2 f/\partial x^2,\, \partial^2 f/\partial x\partial y,
\partial^2 f/\partial y^2)
$$
of a function (formula or FE-function).
Mesh adaptation is a very powerful tool when the solution of a problem
vary locally and sharply.

Here we solve the problem (\ref{eqn:Poisson})-(\ref{eqn:Dirichlet}),
when $f=1$ and $\Omega$ is L-shape domain. 

\twoplot[height=5cm]{L-shape2}{lshapeSol}{ L-shape domain and its boundary name}{Final solution after 4-times adaptation}


\begin{example}[Adapt.edp]
\index{tutorial!adapt.edp}
The solution has the
\index{singularity}singularity $r^{3/2},\, r=|x-\gamma|$ 
at the point $\gamma$ of the intersection of two lines
$bc$ and $bd$ (see Fig. \ref{L-shape2}).
\bFF
@border ba(t=0,1.0){x=t;   y=0;  label=1;};
@border bb(t=0,0.5){x=1;   y=t;  label=1;};
@border bc(t=0,0.5){x=1-t; y=0.5;label=1;};
@border bd(t=0.5,1){x=0.5; y=t;  label=1;};
@border be(t=0.5,1){x=1-t; y=1;  label=1;};
@border bf(t=0.0,1){x=0;   y=1-t;label=1;};
@mesh Th = @buildmesh ( ba(6)+bb(4)+bc(4)+bd(4)+be(4)+bf(6) );
@fespace Vh(Th,@P1);  // set FE space
Vh u,v;             // set unknown and test function
func f = 1;
@real error=0.1;        // level of error
@problem Poisson(u,v,solver=CG,eps=1.0e-6) =
    @int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v))
  - @int2d(Th) ( f*v )
  + @on(1,u=0)  ;
@for (@int i=0;i< 4;i++)
{
  Poisson;
  Th=@adaptmesh(Th,u,err=error);
  error = error/2;
} ;
@plot(u);
\eFF
\end{example}
To speed up the adaptation
we change by hand a default parameter \texttt{err} of 
\texttt{adaptmesh}\index{concatenation}, which
specifies the required precision, so as to make the new mesh finer.
The problem is coercive and symmetric,
so the linear system can be solved with the conjugate gradient
method \index{solver=!CG} (parameter \texttt{solver=CG}
with the stopping criteria on the residual, here
\texttt{eps=1.0e-6}).
By \texttt{adaptmesh}, we get good slope of the final solution near 
the point of intersection of $bc$ and $bd$ as in Fig. \ref{lshapeSol}.

This method is described in detail in \cite{bamg}. It has a number of
default parameters which can be modified~:

\label{adaptmesh}
\begin{description}

    \item[\texttt{hmin=}] Minimum edge size.  \index{adaptmesh!hmin=}
    ({\tt val} is a real. Its default is related to
    the size of the domain to be meshed and the precision of the mesh
    generator).

    \item[\texttt{hmax=}] Maximum edge size.  ({\tt val} is a real. 
    It defaults to the diameter of the domain to be
    meshed) \index{adaptmesh!hmax=}

    \item[\texttt{err=}] $P^1$ interpolation error level (0.01 is the
    default).  \index{adaptmesh!err=}

    \item[\texttt{errg=}] Relative geometrical error. By default this
    error is 0.01, and in any case it must be lower than $1/\sqrt{2}$.
    Meshes created with this option may have some edges smaller than
    the {\tt -hmin } due to geometrical constraints.
    \index{adaptmesh!errg=}

    \item[\texttt{nbvx=}] Maximum number of vertices generated by the
    mesh generator (9000 is the default).
    \index{adaptmesh!nbvx=}

    \item[\texttt{nbsmooth=}] number of iterations of the smoothing
    procedure (5 is the default).  \index{adaptmesh!nbsmooth=}

    \item[\texttt{nbjacoby=}] number of iterations in a smoothing
    procedure during the metric construction, 0 means no smoothing (6
    is the default).  \index{adaptmesh!nbjacoby=}

    \item[\texttt{ratio=}] ratio for a prescribed smoothing on the
    metric.  If the value is 0 or less than 1.1 no smoothing is done
    on the metric (1.8 is the default).

    If \texttt{ratio} $> 1.1$, the speed of mesh size variations is
    bounded by $log(\mathtt{ratio})$.  Note: As {\tt ratio} gets
    closer to {\tt 1}, the number of generated vertices increases.
    This may be useful to control the thickness of refined regions
    near shocks or boundary layers .  \index{adaptmesh!ratio=}

   \item[\texttt{omega=}] relaxation parameter for the smoothing
   procedure (1.0 is the default).  \index{adaptmesh!omega=}

    \item[\texttt{iso=}] If true, forces the metric to be isotropic
    (false is the default).  \index{adaptmesh!iso=}

    \item[\texttt{abserror=}] If false, the metric is evaluated using
    the criterium of equi-repartion of relative error (false is the
    default).  In this case the metric is defined by

\begin{equation}
  \mathcal{M} = \left({1\over\mathtt{err}\,\, \mathtt{coef}^2} \quad {
  |\mathcal{H}| \over max(\mathtt{CutOff},|\eta|)}\right)^p
  \label{eq err rel}
\end{equation}
    \index{adaptmesh!abserror=}

    otherwise, the metric is evaluated using the criterium of
    equi-distribution of errors.  In this case the metric is defined
    by

\begin{equation}
  \mathcal{M} = \left({1\over \mathtt{err}\,\,\mathtt{coef}^2} \quad
  {|{\mathcal{H}|} \over
  {\mathit{sup}(\eta)-\mathit{inf}(\eta)}}\right)^p.\label{eq err abs}
\end{equation}

    \item[\texttt{cutoff=}] lower limit for the relative error
    evaluation (1.0e-6 is the default).
    \index{adaptmesh!cutoff=}

    \item[\texttt{verbosity=}] informational messages level (can be
    chosen between 0 and $\infty$). Also changes the value of the
    global variable verbosity (obsolete).  \index{adaptmesh!verbosity=
    }

    \item[\texttt{inquire=}] To inquire graphicaly about the mesh (false is the
    default).  \index{adaptmesh!inquire=}

    \item[\texttt{splitpbedge=}] If true, splits all internal edges in
    half with two boundary vertices (true is the default).
    \index{adaptmesh!splitpbedge=}

    \item[\texttt{maxsubdiv=}] Changes the metric such that the
    maximum subdivision of a background edge is bound by {\tt val}
    (always limited by 10, and 10 is also the default).
    \index{adaptmesh!maxsubdiv=}

    \item[\texttt{rescaling=}] if true, the function with respect to
    which the mesh is adapted is rescaled to be between 0 and 1 (true
    is the default).  \index{adaptmesh!rescaling=}

    \item[\texttt{keepbackvertices=}] if true, tries to keep as many
    vertices from the original mesh as possible (true is the default).
    \index{adaptmesh!keepbackvertices=}

    \item[\texttt{isMetric=}] if true, the metric is defined
    explicitly (false is the default).  If the 3 functions $m_{11},
    m_{12}, m_{22}$ are given, they directly define a symmetric matrix
    field whose Hessian is computed to define a metric. If only one
    function is given, then it represents the isotropic mesh size at
    every point.  \index{adaptmesh!isMetric=}
    
    For example, if the partial derivatives 
    \texttt{fxx} ($=\partial^2 f/\partial x^2$),
    \texttt{fxx} ($=\partial^2 f/\partial x\partial y$),
    \texttt{fyy} ($=\partial^2 f/\partial y^2$) are given, we can set
    $$
    \ttCC{Th=@adaptmesh(Th,fxx,fxy,fyy,IsMetric=1,nbvx=10000,hmin=hmin);}
    $$

    \item[\texttt{power=}] exponent power of the Hessian used to
    compute the metric (1 is the default).  \index{adaptmesh!powerin=}
    
    \item[\texttt{thetamax=}] minimum corner angle in degrees (default
    is 0).
    
    \item[\texttt{splitin2=}] boolean value. If true, splits all
    triangles of the final mesh into 4
    sub-triangles. \index{adaptmesh!splitin2}

    \item[\texttt{metric=}] \index{adaptmesh!metric=} an array of 3
    real arrays to set or get metric data information. The size of
    these three arrays must be the number of vertices. So if
    \texttt{m11,m12,m22} are three P1 finite elements related to the
    mesh to adapt, you can write: \texttt{metric=[m11[],m12[],m22[]]}
    (see file convect-apt.edp for a full example)

    \itemtt[nomeshgeneration=] \index{adaptmesh!nomeshgeneration=} If
    true, no adapted mesh is generated (useful to compute only a
    metric).

    \itemtt[periodic=] \index{adaptmesh!periodic=} %%% modif FH 
    As writing \texttt{periodic=[[4,y],[2,y],[1,x],[3,x]];}
    it builds an adapted periodic mesh. The sample 
    build a biperiodic mesh of a square.
    (see periodic finite element   spaces \ref{periodic BC}, and see \texttt{sphere.edp} for a  full example)

\end{description}

%%%alh proofreading ok up to here

\subsection{Trunc}\index{trunc}

  A small operator to create a truncated mesh from a mesh with respect to a 
boolean function. 

The two named parameter 
\begin{description} \index{split=} \index{label=}\index{trunc!split=} \index{trunc!label=}
  \itemtt[label=] sets the label number of new boundary item (one by default)
  \itemtt[split=] sets the level $n$ of triangle splitting. each triangle is splitted in  $n\times n$ ( one by default).
\end{description}

To create the mesh \texttt{Th3}  
where alls  triangles of a mesh \texttt{Th}  are splitted in $33$ , just write:
\bFF
  mesh Th3 = trunc(Th,1,split=3); 
\eFF

The  \texttt{truncmesh.edp} example construct 
all "trunc" mesh  to the support of the basic function  of the space \texttt{Vh} (cf. \texttt{abs(u)>0}), 
split all the  triangles in $5 5$, and put a label number to $2$ on new boundary.
\bFF
@mesh Th=square(3,3);
@fespace Vh(Th,P1);
Vh u;
@int i,n=u.n;
u=0;
@for (i=0;i<n;i++)  // all degre of freedom
 {
  u[][i]=1;        //  the basic function i 
  @plot(u,wait=1);
  @mesh Sh1=trunc(Th,abs(u)>1.e-10,split=5,label=2);
  plot(Th,Sh1,wait=1,ps="trunc"+i+".eps");// plot the mesh of
  // the function's support                  
  u[][i]=0;      // reset 
 }
\eFF
\twoplot[height=6cm]{trunc0}{trunc6}{ mesh of support the function P1  number 0, splitted in $55$ }{
mesh of support the function P1  number 6, splitted in $55$ }
\subsection{splitmesh}
A other way to split mesh triangle:
\bFF
{  //  new stuff 2004 splitmesh (version 1.37)
  assert(version>=1.37);
  @border a(t=0,2*pi){ x=cos(t); y=sin(t);label=1;}
  @plot(Th,wait=1,ps="nosplitmesh.eps"); // see figure \ref{fig nosplitmesh}
  @mesh Th=@buildmesh(a(20));
  @plot(Th,wait=1);
  @Th=@splitmesh(Th,1+5*(square(x-0.5)+y*y));
  @plot(Th,wait=1,ps="splitmesh.eps"); // see figure \ref{fig splitmesh}
}
\eFF

\twoplot[height=6cm]{nosplitmesh}{splitmesh}{\label{fig nosplitmesh}initial mesh}{\label{fig splitmesh}all left mesh triangle is split  conformaly in \texttt{int(1+5*(square(x-0.5)+y*y)\^2} triangles.}


\subsection{\setS{Meshing Examples}}

\begin{example}[Two rectangles touching by a side]~
\index{mesh!beam}
\bFF
@border a(t=0,1){x=t;y=0;};
@border b(t=0,1){x=1;y=t;};
@border c(t=1,0){x=t ;y=1;};
@border d(t=1,0){x = 0; y=t;};
@border c1(t=0,1){x=t ;y=1;};
@border e(t=0,0.2){x=1;y=1+t;};
@border f(t=1,0){x=t ;y=1.2;};
@border g(t=0.2,0){x=0;y=1+t;};
@int n=1;
@mesh th = @buildmesh(a(10*n)+b(10*n)+c(10*n)+d(10*n));
@mesh TH = @buildmesh ( c1(10*n) + e(5*n) + f(10*n) + g(5*n) );
@plot(th,TH,ps="TouchSide.esp"); // Fig. \ref{TouchSide}
\eFF
\end{example}

\begin{example}[NACA0012 Airfoil]~
\index{mesh!NACA0012}
\bFF
@border upper(t=0,1) { x = t;  
     y = 0.17735*sqrt(t)-0.075597*t
  - 0.212836*(t^2)+0.17363*(t^3)-0.06254*(t^4); }
@border lower(t=1,0) { x = t; 
     y= -(0.17735*sqrt(t)-0.075597*t
  -0.212836*(t^2)+0.17363*(t^3)-0.06254*(t^4)); }
@border c(t=0,2*pi) { x=0.8*cos(t)+0.5;  y=0.8*sin(t); } 
@mesh Th = @buildmesh(c(30)+upper(35)+lower(35));
@plot(Th,@ps="NACA0012.eps",@bw=1);  // Fig. \ref{NACA0012}
\eFF
\end{example}

\twoplot[height=5cm]{TouchSide}{NACA0012}{Two rectangles touching by a side}
{NACA0012 Airfoil}

\begin{example}[Cardioid]~
\index{mesh!Cardioid}
\bFF
@real b = 1, a = b;
@border C(t=0,2*pi) { x=(a+b)*cos(t)-b*cos((a+b)*t/b); 
                        y=(a+b)*sin(t)-b*sin((a+b)*t/b); }
@mesh Th = @buildmesh(C(50));
@plot(Th,@ps="Cardioid.eps",bw=1); // Fig. \ref{Cardioid}
\eFF
\end{example}
\begin{example}[Cassini Egg]~
\index{mesh!Cassini Egg}
\bFF
@border C(t=0,2*pi) { x=(2*cos(2*t)+3)*cos(t); 
                      y=(2*cos(2*t)+3)*sin(t); } 
@mesh Th = @buildmesh(C(50));
@plot(Th,@ps="Cassini.eps",bw=1); // Fig. \ref{Cassini}
\eFF
\end{example}
\twoplot[height=5cm]{Cardioid}{Cassini}{Domain with Cardioid curve boundary}
{Domain with Cassini Egg curve boundary}

\begin{example}[By cubic Bezier curve]~
\index{mesh!Bezier curve}
\bFF
// A cubic Bezier curve connecting two points with two control points
@func @real @bzi(@real p0,@real p1,@real q1,@real q2,@real t)
{
  @return p0*(1-t)^3+q1*3*(1-t)^2*t+q2*3*(1-t)*t^2+p1*t^3;
}

real[int] p00=[0,1], p01=[0,-1], q00=[-2,0.1], q01=[-2,-0.5];
real[int] p11=[1,-0.9], q10=[0.1,-0.95], q11=[0.5,-1];
real[int] p21=[2,0.7], q20=[3,-0.4], q21=[4,0.5];
real[int] q30=[0.5,1.1], q31=[1.5,1.2];
@border G1(t=0,1) { x=bzi(p00[0],p01[0],q00[0],q01[0],t); 
                   y=bzi(p00[1],p01[1],q00[1],q01[1],t); }
@border G2(t=0,1) { x=bzi(p01[0],p11[0],q10[0],q11[0],t); 
                   y=bzi(p01[1],p11[1],q10[1],q11[1],t); }
@border G3(t=0,1) { x=bzi(p11[0],p21[0],q20[0],q21[0],t); 
                   y=bzi(p11[1],p21[1],q20[1],q21[1],t); }
@border G4(t=0,1) { x=bzi(p21[0],p00[0],q30[0],q31[0],t); 
                   y=bzi(p21[1],p00[1],q30[1],q31[1],t); }
@int m=5;
@mesh Th = @buildmesh(G1(2*m)+G2(m)+G3(3*m)+G4(m));
@plot(Th,ps="Bezier.eps",bw=1);  // Fig \ref{Bezier}
\eFF
\end{example}

\begin{example}[Section of Engine]~
\index{mesh!Section of Engine}
\bFF
real a= 6., b= 1., c=0.5; 
border L1(t=0,1) { x= -a; y= 1+b - 2*(1+b)*t; }
border L2(t=0,1) { x= -a+2*a*t; y= -1-b*(x/a)*(x/a)*(3-2*abs(x)/a );}
border L3(t=0,1) { x= a; y=-1-b + (1+ b )*t; }
border L4(t=0,1) { x= a - a*t;   y=0; }
border L5(t=0,pi) { x= -c*sin(t)/2; y=c/2-c*cos(t)/2; }
border L6(t=0,1) { x= a*t;  y=c; }
border L7(t=0,1) { x= a;  y=c + (1+ b-c )*t; }
border L8(t=0,1) { x= a-2*a*t; y= 1+b*(x/a)*(x/a)*(3-2*abs(x)/a); }
mesh Th = buildmesh(L1(8)+L2(26)+L3(8)+L4(20)+L5(8)+L6(30)+L7(8)+L8(30));
plot(Th,ps="Engine.eps",bw=1); // Fig. \ref{Engine}
\eFF
\end{example}

\begin{figure}[hbt]
\begin{multicols}{2}
\begin{center}
\includegraphics*[height=5cm]{Bezier}
\caption{\label{Bezier} Boundary drawed by Bezier curves}
\end{center}
\begin{center}
\vspace{3cm}~~\par
\includegraphics*[height=2.8cm]{Engine}
\caption{\label{Engine} Section of Engine}
\end{center}
\end{multicols}
\end{figure}

\begin{example}[Domain with U-shape channel]~
\index{mesh!U-shape channel}
\bFF
@real d = 0.1; // width of U-shape
@border L1(t=0,1-d) { x=-1; y=-d-t; } 
@border L2(t=0,1-d) { x=-1; y=1-t; }
@border B(t=0,2) { x=-1+t; y=-1; } 
@border C1(t=0,1) { x=t-1; y=d; }
@border C2(t=0,2*d) { x=0; y=d-t; }  
@border C3(t=0,1) { x=-t; y=-d; }
@border R(t=0,2) { x=1; y=-1+t; }  
@border T(t=0,2) { x=1-t; y=1; }
@int n = 5;
@mesh Th = buildmesh (L1(n/2)+L2(n/2)+B(n)+C1(n)+C2(3)+C3(n)+R(n)+T(n));
@plot(Th,ps="U-shape.eps",bw=1); // Fig \ref{U-shape}
\eFF
\end{example}
\begin{example}[Domain with V-shape cut]~
\index{mesh!V-shape cut}
\bFF
@real dAg = 0.01; // angle of V-shape
@border C(t=dAg,2*pi-dAg) { x=cos(t); y=sin(t); };
@real[int] pa(2), pb(2), pc(2);
pa[0] = cos(dAg); pa[1] = sin(dAg);
pb[0] = cos(2*pi-dAg); pb[1] = sin(2*pi-dAg);
pc[0] = 0; pc[1] = 0;
@border seg1(t=0,1) { x=(1-t)*pb[0]+t*pc[0]; y=(1-t)*pb[1]+t*pc[1]; };
@border seg2(t=0,1) { x=(1-t)*pc[0]+t*pa[0]; y=(1-t)*pc[1]+t*pa[1]; };
@mesh Th = @buildmesh(seg1(20)+C(40)+seg2(20));
@plot(Th,@ps="V-shape.eps",@bw=1);  // Fig. \ref{V-shape}
\eFF
\end{example}
\twoplot[height=5cm]{U-shape}{V-shape}{Domain with U-shape channel changed by \ttCC{d}}
{Domain with V-shape cut changed by \ttCC{dAg}}

\begin{example}[Smiling face]~
\index{mesh!Smiling face}
\bFF
@real d=0.1;
@int m=5;
@real a=1.5, b=2, c=0.7, e=0.01;
@border F(t=0,2*pi) { x=a*cos(t); y=b*sin(t); }
@border E1(t=0,2*pi) { x=0.2*cos(t)-0.5; y=0.2*sin(t)+0.5; }
@border E2(t=0,2*pi) { x=0.2*cos(t)+0.5; y=0.2*sin(t)+0.5; }
@func @real @st(real t) {
   @return sin(pi*t)-pi/2;
}
@border C1(t=-0.5,0.5) { x=(1-d)*c*cos(st(t)); y=(1-d)*c*sin(st(t)); }
@border C2(t=0,1){x=((1-d)+d*t)*c*cos(st(0.5));y=((1-d)+d*t)*c*sin(st(0.5));}
@border C3(t=0.5,-0.5) { x=c*cos(st(t)); y=c*sin(st(t)); }
@border C4(t=0,1) { x=(1-d*t)*c*cos(st(-0.5)); y=(1-d*t)*c*sin(st(-0.5));}

@border C0(t=0,2*pi) { x=0.1*cos(t); y=0.1*sin(t); }
@mesh Th=@buildmesh(F(10*m)+C1(2*m)+C2(3)+C3(2*m)+C4(3)
                  +C0(m)+E1(-2*m)+E2(-2*m));
@plot(Th,@ps="SmileFace.eps",@bw=1);  // see Fig. \ref{SmileFace}
}\eFF
\end{example}

\begin{example}[3point bending]~
\index{mesh!3point bending}
\bFF
// Square for Three-Point Bend Speicmens fixed on \ttCC{Fix1, Fix2}
// It will be loaded on \ttCC{Load}.
@real a=1, b=5, c=0.1;
@int n=5, m=b*n;
@border Left(t=0,2*a) { x=-b; y=a-t; }
@border Bot1(t=0,b/2-c) { x=-b+t; y=-a; }
@border Fix1(t=0,2*c) { x=-b/2-c+t; y=-a; }
@border Bot2(t=0,b-2*c) { x=-b/2+c+t; y=-a; }
@border Fix2(t=0,2*c) { x=b/2-c+t; y=-a; }
@border Bot3(t=0,b/2-c) { x=b/2+c+t; y=-a; }
@border Right(t=0,2*a) { x=b; y=-a+t; }  
@border Top1(t=0,b-c) { x=b-t; y=a; }
@border Load(t=0,2*c) { x=c-t; y=a; }
@border Top2(t=0,b-c) { x=-c-t; y=a; }
mesh Th = buildmesh(Left(n)+Bot1(m/4)+Fix1(5)+Bot2(m/2)+Fix2(5)+Bot3(m/4)
                    +Right(n)+Top1(m/2)+Load(10)+Top2(m/2));
plot(Th,ps="ThreePoint.eps",bw=1); // Fig. \ref{ThreePoint}
\eFF
\end{example}

\begin{figure}[hbt]
\begin{multicols}{2}
\begin{center}
\includegraphics*[height=5cm]{SmileFace}
\caption{\label{SmileFace} Smiling face (Mouth is changeable)}
\end{center}
\begin{center}
\vspace{2cm}~~\par
\includegraphics*[height=2.8cm]{ThreePoint}
\caption{\label{ThreePoint} Domain for three-point bending test}
\end{center}
\end{multicols}
\end{figure}


\section{\setS{Finite Elements}} \index{finite element space}
As stated in Step2 in Section \ref{sec:example}.
FEM make approximations all functions $w$ to
\[
w(x,y)\simeq w_0\phi_0(x,y)+w_1\phi_1(x,y)+\cdots+w_{M-1}\phi_{M-1}(x,y)
\]
with finite basis functions $\phi_k(x,y)$ and numbers $w_k$ ($k=0,\cdots,M-1$).
The functions $\phi_k(x,y)$ is constructed from the triangle $T_{i_k}$, so 
$\phi_k(x,y)$ is called \emph{shape function}.
The finite element space 
$$
V_h=\left\{w\left|\; w_0\phi_0+w_1\phi_1+\cdots+w_{M-1}\phi_{M-1},\,
w_i\in \R\right.\right\}
$$ is easily created by  
\bT
     @fespace IDspace(IDmesh,<IDFE>) ;
\eT
or with $\ell$ pair of periodic boundary condition
\bT
     @fespace IDspace(IDmesh,<IDFE>,
                      periodic=[[la$_1$,sa$_1$],[lb$_1$,sb$_1$],
                                ...  
                                [la$_k$,sa$_k$],[lb$_k$,sb$_\ell$]]); 
\eT
where
\index{fespace}\index{periodic}
\ttCC{IDspace} is the name of the space (e.g. \ttCC{Vh}),
\ttCC{IDmesh} is the name of the associated mesh and  \ttCC{<IDFE>}
is a identifier of finite element type. 
In a pair of periodic boundary condition, \label{periodic BC}
if \ttCC{[la$_i$,sa$_i$],[lb$_i$,sb$_i$]} is a pair of
\texttt{int}, this expressions the 2 labels \ttCC{la$_i$} and \ttCC{lb$_i$}
of the piece of the boundary to be equivalence;
If \ttCC{[la$_i$,sa$_i$],[lb$_i$,sb$_i$]} is a pair of \texttt{real},
this expressions \ttCC{sa$_i$} and \ttCC{sb$_i$}
give two common abscissa on the two boundary curve, and two points are identify 
if the two abscissa are equal.


\medskip
 As of today, the known
types of finite element are: \index{type of finite element}
\begin{description}
     \item[P0]  piecewise constante discontinuous finite element
     \index{P0|textbf}\index{fespace!P0}
    \begin{eqnarray}
    \label{eq:P0}
     P0_{h} = \left\{ v \in L^2(\Omega) \left|\; \textrm{for all }K \in \mathcal{T}_{h}\;\;\textrm{there is }\alpha_{K}\in \R :
        \;\; v_{|K} = \alpha_{K } \right.\right\}
     \end{eqnarray}
     \item[P1]  piecewise linear  continuous finite element
     \index{P1|textbf}\index{fespace!P1}
     \begin{eqnarray}
     &&P1_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}
        \quad v_{|K} \in P_{1} \right.\right\} \label{eq:P1}
     \end{eqnarray}
     \item[P1dc]  piecewise linear  discontinuous finite element
     \index{P1dc|textbf}\index{fespace!P1dc}
     \begin{equation}
     P1dc_{h} = \left\{ v \in L^{2}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}
        \quad v_{|K} \in P_{1} \right.\right\} \label{eq:P1dc}
     \end{equation}
     \item[P1b]  piecewise linear  continuous finite element plus bubble
     \index{P1b|textbf}\index{fespace!P1b}
     \begin{equation}
     P1b_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}
        \quad v_{|K} \in P_{1} \oplus Span\{  \lambda^{K}_{0} \lambda^{K}_{1} \lambda^{K}_{2} \} \right.\right\} \label{eq:P1b}
     \end{equation}
     where $\lambda ^{K}_{i}, i=0,1,2$ are the 3 area coordinate functions of the triangle $K$

     \item[P2] piecewise $P_{2}$  continuous finite element,
     \index{P2|textbf}\index{fespace!P2}
     \begin{equation}
     P2_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}
        \quad v_{|K} \in P_{2} \right.\right\}
     \end{equation}
     where
     $P_{2}$ is the set of polynomials of $\R^{2}$ of  degrees $\le 2$.
     \item[P2b] piecewise $P_{2} $ continuous finite element  plus bubble,
     \index{P2|textbf}\index{fespace!P2}
     \begin{equation}
     P2_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}
        \quad v_{|K} \in P_{2} \oplus Span\{  \lambda^{K}_{0} \lambda^{K}_{1} \lambda^{K}_{2} \} \right.\right\}
     \end{equation}

     \item[P2dc] piecewise $P_{2}$  discontinuous finite element,
     \index{P2dc|textbf}\index{fespace!P2dc}
     \begin{equation}
     P2dc_{h} = \left\{ v \in L^{2}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}
        \quad v_{|K} \in P_{2} \right.\right\}
     \end{equation}
     \item[RT0]  Raviart-Thomas finite element
     \index{RT0|textbf}\index{fespace!RT0}
     \begin{equation}
         RT0_{h} = \left\{ \mathbf{v} \in H(\textrm{div}) \left|\; \forall K \in
         \mathcal{T}_{h} \quad  \mathbf{v}_{|K}(x,y) =
         \vecttwo{\alpha_{K}}{\beta_{K}} + \gamma_{K}\vecttwo{x}{y}  \right.\right\}
         \label{eq:RT0}
     \end{equation}
      where by writing 
      $\textrm{div }\mathbf{w}=\partial w_1/\partial x+\partial w_2/\partial y,
      \, \mathbf{w}=(w_1,w_2)$,
      $$
      H(\textrm{div})=\left\{\mathbf{w}\in L^{2}(\Omega)^2\left| 
      \textrm{div } \mathbf{w}\in L^{2}(\Omega)
      \right.\right\}
      $$ 
      and 
      $\alpha_{K},\beta_{K},\gamma_{K} $ are real numbers.
     \item[P1nc] \index{P1nc|textbf}\index{fespace!P1nc} piecewise linear   element continuous at
     the middle of edge only.

\end{description}

If we get the finite element spaces
$$  X_{h} = \{ v \in H^{1}(]0,1[^2) |\; \forall K \in \mathcal{T}_{h}
\quad v_{|K} \in
P_{1} \}$$
$$ X_{ph} = \{  v \in X_{h} |\; v(\vecttwo{0}{.} ) =  v(\vecttwo{1}{.}) , v(\vecttwo{.}{0} ) =  v(\vecttwo{.}{1} )  \}$$
$$  M_{h} = \{ v \in H^{1}(]0,1[^2) |\; \forall K \in \mathcal{T}_{h}
\quad v_{|K} \in
P_{2} \}$$
$$  R_{h} = \{ \mathbf{v} \in H^{1}(]0,1[^2)^{2} |\; \forall K \in \mathcal{T}_{h}
\quad
 \mathbf{v}_{|K}(x,y) =
         \vecttwo{\alpha_{K}}{\beta_{K}} + \gamma_{K}\vecttwo{x}{y} \}$$

when $\mathcal{T}_h$ is a mesh $10\times 10$ of the unit square $]0,1[^2$,
we only write in \freefempp as follows:
\bT
@mesh Th=@square(10,10);  
@fespace Xh(Th,@P1);      //  scalar FE
@fespace Xph(Th,P1,
         periodic=[[2,y],[4,y],[1,x],[3,x]]);//bi-periodic FE 
@fespace Mh(Th,@P2);      //  scalar FE
@fespace Rh(Th,@RT0);     //  vectorial FE
\eT
where \texttt{Xh,Mh,Rh} expresses finite element spaces (called FE spaces
\index{FE space}) $X_h,\, M_h,\, R_h$, respectively.
If we want use FE-functions 
$ u_{h},v_{h} \in X_{h} $ and $ p_{h},q_{h} \in M_{h} $
and $U_{h},V_{h} \in R_{h}$
\index{FE-function}, we write in \freefempp
\bT
  Xh uh,vh;
  Xph uph,vph;
  Mh ph,qh;
  Rh [Uxh,Uyh],[Vxh,Vyh];
  Xh[@int] Uh(10); //  array of 10 function in Xh 
  Rh[@int] [Wxh,Wyh](10); //  array of 10 functions in Rh.\index{array!fespace}
\eT

The functions $U_{h},V_{h}$ have two components so we have
$$U_{h}=\vecttwo{Uxh}{Uyh}  \quad \mbox{and}\quad V_{h}=\vecttwo{Vxh}{Vyh}$$

\subsection{Lagrange finite element}
\label{sec:P0P1P2}
\subsubsection{P0-element}
For each triangule $T_k$, the basis function $\phi_k$ in \texttt{Vh(Th,P0)} 
is given by
$$
\phi_k(x,y)=1\textrm{ if }(x,y)\in T_k,\qquad
\phi_k(x,y)=0\textrm{ if }(x,y)\not\in T_k
$$
If we write 
\bT
Vh(Th,@P0);  Vh fh=$f(x.y)$;
\eT
then for vertices $q^{k_i},\, i=1,2,3$ in Fig. \ref{P1P2}(a),
$$
\ttCC{fh}=f_h(x,y)=\sum_{k=1}^{n_t}\frac{f(q^{k_1})+f(q^{k_2})+f(q^{k_3})}{3}\phi_k
$$
See Fig. \ref{projP0} for the projection of $f(x,y)=\sin(\pi x)\cos(\pi y)$ 
into \ttCC{Vh(Th,@P0)} when 
the mesh \ttCC{Th} with $4\times 4$-grid of $[-1,1]^2$ as in Fig. \ref{P0P1P2P1nc}.

\subsubsection{P1-element}
\plot[height=4cm]{P1P2}{$P_1$  and $P_2$ degrees of freedom on triangle $T_k$}

For each vertex $q^i$, the basis function $\phi_i$ in \texttt{Vh(Th,P1)} 
is given by
\begin{eqnarray*}
&&\phi_i(x,y)=a^k_i+b^k_ix+c^k_iy~\textrm{for }(x,y)\in T_k,\\
&&\phi_i(q^i)=1,\quad \phi_i(q^j)=0\textrm{ if }i\neq j
\end{eqnarray*}
The basis function $\phi_{k_1}(x,y)$ with the vertex $q^{k_1}$ in 
Fig. \ref{P1P2}(a) at point $p=(x,y)$ in triangle $T_k$ simply coincide with the 
\emph{barycentric coordinates $\lambda^k_1$ (area coordinates)} :
$$
\phi_{k_1}(x,y) = \lambda^k_{1}(x,y)=
\frac{\textrm{area of triangle} (p, q^{k_2},q^{k_3})}
{\textrm{area of triangle}(q^{k_1},q^{k_2},q^{k_3})}
$$
If we write 
\bT
Vh(Th,@P1); Vh fh=$g(x.y)$;
\eT
then 
$$
\ttCC{fh}=f_h(x,y)=\sum_{i=1}^{n_v}f(q^i)\phi_i(x,y)
$$
See Fig. \ref{projP1} for the projection of $f(x,y)=\sin(\pi x)\cos(\pi y)$ 
into \ttCC{Vh(Th,@P1)}.

\twoplot[height=5cm]{P0P1P2P1nc}{projP0}{Test mesh \texttt{Th} for projection}{projection to \texttt{Vh(Th,P0)}}

\subsubsection{P2-element}
For each vertex or midpoint $q^i$. the basis function $\phi_i$ in \texttt{Vh(Th,P2)} 
is given by
\begin{eqnarray*}
&&\phi_i(x,y)=a^k_i+b^k_ix+c^k_iy+d^k_ix^2+e^k_ixy+f^f_jy^2~\textrm{for }(x,y)\in T_k,\\
&&\phi_i(q^i)=1,\quad \phi_i(q^j)=0\textrm{ if }i\neq j
\end{eqnarray*}
The basis function $\phi_{k_1}(x,y)$ with the vertex $q^{k_1}$ in 
Fig. \ref{P1P2}(b) is defined by the \emph{barycentric coordinates}:
$$
\phi_{k_1}(x,y) = \lambda^k_{1}(x,y)(2\lambda^k_1(x,y)-1)
$$
and for the midpoint $q^{k_2}$
$$
\phi_{k_2}(x,y) = 4\lambda^k_1(x,y)\lambda^k_4(x,y)
$$
If we write 
\bT
Vh(Th,@P2); Vh fh=$f(x.y)$;
\eT
then 
$$
\ttCC{fh}=f_h(x,y)=\sum_{i=1}^{M}f(q^i)\phi_i(x,y)\quad (\textrm{summation over all vetex or midpoint})
$$
See Fig. \ref{projP2} for the projection of $f(x,y)=\sin(\pi x)\cos(\pi y)$ 
into \ttCC{Vh(Th,@P2)}.

\twoplot[height=5cm]{projP1}{projP2}{projection to \texttt{Vh(Th,P1)}}{projection to \texttt{Vh(Th,P2)}}

\subsection{P1 Nonconforming Element}
Refer \cite{Thomasset} for detail. 
In \refSec{P0P1P2}, the approximation are a continuous function all 
over the domain, and
$$
w_h\in V_h\subset H^1(\Omega)
$$
However, we allow the continuity requirement to be relaxed.
If we write 
\bT
Vh(Th,@P1nc); Vh fh=$f(x.y)$;
\eT
then 
$$
\ttCC{fh}=f_h(x,y)=\sum_{i=1}^{n_v}f(m^i)\phi_i(x,y)\quad (\textrm{summation over all midpoint})
$$
Here the basis function $\phi_i$ associat with the midpoint 
$m^i=(q^{k_i}+q^{k_{i+1}})/2$ where $q^{k_i}$ is the $i$-th point in $T_k$,
and we assume that $j+1=0$ if $j=3$:
\begin{eqnarray*}
&&\phi_i(x,y)=a^k_i+b^k_ix+c^k_iy~\textrm{for }(x,y)\in T_k,\\
&&\phi_i(m^i)=1,\quad \phi_i(m^j)=0\textrm{ if }i\neq j
\end{eqnarray*}

Strictly speaking $\partial \phi_i/\partial x,\, \partial \phi_i/\partial y$
contain Dirac distribution $\rho \delta_{\partial T_k}$.
The numerical calculations will automatically \emph{ignore} them.
In \cite{Thomasset}, there is a proof of the estimation
\[
\left(\sum_{k=1}^{n_v}\int_{T_k}|\nabla w-\nabla w_h|^2dxdy\right)^{1/2}
=O(h)
\]
The basis functions $\phi_k$ have the following properties.
\begin{enumerate}
  \item 
  For the bilinear form $a$ defined in (\ref{eqn:bilinear}) satisfy
  \begin{eqnarray*}
  &&a(\phi_i,\phi_i)>0,\qquad a(\phi_i,\phi_j)\le 0\quad\textrm{if }i\neq j\\
  &&\sum_{k=1}^{n_v}a(\phi_i,\phi_k)\ge 0
  \end{eqnarray*}
  \item
  $f\ge 0 \Rightarrow u_h\ge 0$
  \item If $i\neq j$, the basis function $\phi_i$ and $\phi_j$ are $L^2$-orthogonal:
  $$
  \int_{\Omega}\phi_i\phi_j\, dxdy=0\qquad \textrm{if }i\neq j
  $$
  which is false for $P_1$-element.
\end{enumerate}
See Fig. \ref{projP1nc} for the projection of $f(x,y)=\sin(\pi x)\cos(\pi y)$ 
into \ttCC{Vh(Th,@P1nc)}.
See Fig. \ref{projP1nc} for the projection of $f(x,y)=\sin(\pi x)\cos(\pi y)$ 
into \ttCC{Vh(Th,@P1nc)}.

\twoplot[height=5cm]{projP1nc}{projP1b}{projection to \texttt{Vh(Th,P1nc)}}{projection to \texttt{Vh(Th,P1b)}}

\subsection{Other FE-space}
For each triangle $T_k\in \mathcal{T}_h$, 
let $\lambda_{k_1}(x,y),\, \lambda_{k_2}(x,y),\, \lambda_{k_3}(x,y)$ be 
the area cordinate
of the triangle (see Fig. \ref{P1P2}), and put
\begin{equation}
\beta_k(x,y)=27\lambda_{k_1}(x,y)\lambda_{k_2}(x,y)\lambda_{k_3}(x,y)
\end{equation}
called \emph{bubble}\index{bubble} function on $T_k$.
The bubble function has the feature:
\begin{enumerate}
  \item 
  $\beta_k(x,y)=0\quad \textrm{if }(x,y)\in \partial T_k$.
  \item
  $\beta_k(q^{k_b})=1$ where $q^{k_b}$ is the barycentre 
  $\frac{q^{k_1}+q^{k_2}+q^{k_3}}{3}$.
\end{enumerate}
If we write 
\bT
Vh(Th,@P1b); Vh fh=$f(x.y)$;
\eT
then 
$$
\texttt{fh}=f_h(x,y)=\sum_{i=1}^{n_v}f(q^i)\phi_i(x,y)+\sum_{k=1}^{n_t}f(q^{k_b})\beta_k(x,y)
$$
See Fig. \ref{projP1b} for the projection of $f(x,y)=\sin(\pi x)\cos(\pi y)$ 
into \ttCC{Vh(Th,@P1b)}.


\subsection{Vector valued FE-function}
Functions from  $\R^{2}$ to $\R^{N}$ with $N=1$ is called scalar function and 
called \emph{vector valued} when $N>1$.
When $N=2$
\bT
     @fespace Vh(Th,[@P0,@P1]) ;
\eT
make the space
\[
V_h=\{\mathbf{w}=(w_1,w_2)|\; w_1\in V_h(\mathcal{T}_h,P_0),\,
w_2\in V_h(\mathcal{T}_h,P_1)\}
\]

\subsubsection{Raviart-Thomas element}
In the Raviart-Thomas finite element $RT0_{h}$,
the degree of freedom are the flux  throw an edge $e$ of the mesh, where the flux of the function $\mathbf{f} : \R^2 \longrightarrow \R^2 $ is $\int_{e} \mathbf{f}.n_{e}$,
 $n_{e}$ is the unit normal of edge $e$.
 
 This implies a orientation of all the edges of the mesh,
 for exemple we can use the global numbering of the edge vertices and we just go to small to large number.
 
To compute the flux, we use an quadrature formulation with one point, the middle point of the edge. Consider a triangle $T_k$ with three vertices $(\mathbf{a},\mathbf{b},\mathbf{c})$. 
Let denote the  vertices numbers by $i_{a},i_{b},i_{c}$, and define the three edge vectors $\mathbf{e}^{1},\mathbf{e}^{2},\mathbf{e}^{3}$ 
by $ sgn(i_{b}-i_{c})(\mathbf{b}-\mathbf{c})$, $sgn(i_{c}-i_{a})(\mathbf{c}-\mathbf{a})$, $sgn(i_{a}-i_{b})(\mathbf{a}-\mathbf{b})$, 
  
We get three basis functions,
\begin{equation}
\boldsymbol{\phi}^{k}_{1}= \frac{sgn(i_{b}-i_{c})}{2|T_k|}(\mathbf{x}-\mathbf{a}),\quad  
\boldsymbol{\phi}^{k}_{2}= \frac{sgn(i_{c}-i_{a})}{2|T_k|}(\mathbf{x}-\mathbf{b}),\quad  
\boldsymbol{\phi}^{k}_{3}= \frac{sgn(i_{a}-i_{b})}{2|T_k|}(\mathbf{x}-\mathbf{c}),
\end{equation}
where $|T_k|$ is the area of the triangle $T_k$.
If we write 
\bT
Vh(Th,@RT0); Vh [f1h,f2h]=[$f1(x.y),f2(x,y)$];
\eT
then 
$$
\ttCC{fh}=\vec{f}_h(x,y)=\sum_{k=1}^{n_t}\sum_{l=1}^6 
n_{i_lj_l}|\mathbf{e^{i_l}}|f_{j_l}(m^{i_l})
\phi_{i_lj_l}
$$
where $n_{i_lj_l}$ is the $j_l$-th component of the normal vector 
$\vec{n}_{i_l}$,
$$
\{m_1,m_2,m_3\} = \left\{\frac{\mathbf{b}+\mathbf{c}}{2},
\frac{\mathbf{a}+\mathbf{c}}{2}, 
\frac{\mathbf{b}+\mathbf{a}}{2} \right\}
$$
and 
$i_l=\{1,1,2,2,3,3\},\, j_l=\{1,2,1,2,1,2\}$ with the order 
of $l$.
\plot[height=4cm]{RT0}{normal vectors of each edge}

\begin{example}
\bFF
@mesh Th=@square(2,2);
@fespace Xh(Th,@P1);
@fespace Vh(Th,@RT0);
Xh uh,vh;
Vh [Uxh,Uyh];
[Uxh,Uyh] = [sin(x),cos(y)];   // ok vectorial FE function
vh= x^2+y^2;  // vh
Th = @square(5,5); // change the mesh
//  Xh is unchange
uh = x^2+y^2; // compute on the new Xh
Uxh = x;    // error: impossible to set only 1 component
         // of  a vector FE function.
vh = Uxh;  // ok
// and now uh use the 5x5 mesh
// but the fespace of vh is alway the 2x2 mesh
@plot(uh,ps="onoldmesh.eps");  // figure \ref{onoldmesh}
uh = uh; // do a interpolation of vh (old) of 5x5 mesh
            // to get the new vh on 10x10 mesh.
@plot(uh,ps="onnewmesh.eps"); // figure \ref{onnewmesh}
vh([x-1/2,y])= x^2 + y^2;  // interpole vh = $((x-1/2)^2 + y^2)  $
\eFF
\twoplot[height=6cm]{onoldmesh}{onnewmesh}{ vh Iso on mesh $2\times 2$}{
vh Iso on mesh $5\times 5$}
\end{example}


 To get the value at a point $x=1,y=2$ of the FE function \texttt{uh},
 or \texttt{[Uxh,Uyh]},one writes

\bFF
   @real value;
   value = uh(2,4);       //  get value= uh(2,4)
   value = Uxh(2,4);      // get value= Uxh(2,4)
   //  ------  or ------
   x=1;y=2;
   value = uh;       // get value= uh(1,2)
   value = Uxh;      // get value= Uxh(1,2)
   value = Uyh;      // get value= Uyh(1,2).
\eFF

  To get the value of the array associated to the FE function
  \texttt{uh}, one writes

  \index{FE function!value}\index{FE function![]|textbf}
  \index{FE function!n|textbf}\index{[]@\verb=[]=}\index{n}

\bFF
   @real value = uh[][0] ; // get the value of degree of freedom 0
   @real maxdf = uh[].max; //  maximum value of degree of freedom
   @int size = uh.n; // the number of degree of freedom
   @real[int] array(uh.n)= uh[]; //  copy the array of the function uh
\eFF
Warning for no scalar finite element function   \texttt{[Uxh,Uyh]}
 the two array \texttt{Uxh[]} and  \texttt{Uyh[]} are the same array, because
 the degre of freedom can touch more than one componant. 



The other way to set a FE function  is to solve a `problem' (see
below).

%%Changed the place (OT 04/02/2005)
\subsection{A \setS{Fast Finite Element Interpolator}}
\medskip
In practice one may discretize the variational equations by the Finite Element method. Then
there will be one mesh for $\Omega_1$ and another one for $\Omega_2$.  The computation
of integrals of products of functions defined on different meshes is difficult.  
Quadrature formulae and interpolations from one mesh to another at quadrature points are needed.
We present below the interpolation operator which we have used and which is new, 
to the best of our knowledge.
\bigskip
Let ${\cal T}_{h}^0=\cup_k T^0_k,{\cal T}_{h}^1=\cup_k T^1_k$ be two triangulations of a domain $\Omega$.
Let 
$$
V({\hbox{${\cal T}$}_{h}^i}) =\{ C^0(\Omega_h^i)~:~f|_{T^i_k}\in P^1\},~~~i=0,1
$$
be the spaces of continuous piecewise affine functions on each triangulation.

Let $f\in V({\cal T}_{h}^0)$. The problem is to find $g\in V({\cal T}_{h}^1)$ such that
$$
g(q) = f(q) \quad \forall q\hbox{~vertex of ~} {\cal T}_{h}^1
$$
Although this is a seemingly simple problem, it is difficult to find an 
efficient algorithm in practice.
We propose an algorithm which is of complexity  $N^1\log N^0$, where $N^i$ is
the number of vertices of ${\hbox{${\cal T}$}_{h}^i}$, and which
is very fast for most practical 2D applications.
\bigskip

{\bf Algorithm }\par
 The method has 5 steps.  
  First a quadtree is built containing all the vertices of mesh ${\cal T}_{h}^0$ such that in
 each terminal cell there are at least one, and at most 4, vertices of ${\cal T}_{h}^0$ .\par
For each $q^1$, vertex of ${\cal T}_{h}^1$ do:   
\\\\
\begin{description}
\item[Step 1] 
Find the terminal cell of the quadtree containing $q^1$. 
 \item[Step 2] Find the the nearest vertex $q^0_j$ to $q^1$ in that cell.
 \item[Step 3] Choose one triangle $T_k^0\in{\cal T}_{h}^0$ which has $q^0_j$ for vertex.
 \item[Step 4] Compute the barycentric coordinates $\{\lambda_j\}_{j=1,2,3}
 $ of $q^1$ in $T^0_k$.
\begin{itemize}
 \item{$-$} if all barycentric coordinates are positive, go to Step 5
 \item{$-$} else if one barycentric coordinate $\lambda_i$ is negative replace $T^0_k$ by the
 adjacent triangle opposite $q^0_i$ and go to Step 4.
 \item{$-$} else two barycentric coordinates are negative so take one of the two randomly
 and replace $T^0_k$ by the adjacent triangle as above.
\end{itemize}
  \item[Step 5] Calculate $g(q^1)$ on $T^0_k$ by linear interpolation of $f$:
 $$
 g(q^1) = \sum_{j=1,2,3} \lambda_j f(q^0_j)
 $$
 \item[End]~
\end{description}
\plot[height=5cm]{fastInterpolat}{
 To interpolate a function at $q^0$ the knowledge of the triangle
which contains $q^0$ is needed.  The algorithm may start at $q^1\in T_k^0$ and stall
on the boundary (thick line) because the line $q^0q^1$ is not inside $\Omega$. But if the holes
are triangulated too (doted line) then the problem does not arise.}

Two problems needs to solved: 
\begin{itemize}
  \item {\it  What if $q^1$ is not in $\Omega^0_h$ ?}  Then Step 5 will stop with a
 boundary triangle. So we add a step which test the distance of $q^1$ with the
 two adjacent boundary edges and select the nearest, and so on till the distance
 grows.
 \medskip
 \item {\it What if $\Omega^0_h$ is not convex and the marching process of Step 4
 locks on a boundary?}
 By construction  Delaunay-Vorono\"{i} mesh generators always triangulate the convex
 hull of the vertices of the domain.  So we make sure that this information is not
 lost when ${\cal T}_{h}^0,{\cal T}_{h}^1$ are constructed and we keep the triangles which are
 outside the domain in a special list. Hence in step 5 we can use that list
 to step over holes if needed.
\end{itemize}

\begin{note}
 Step 3 requires an array of pointers 
 such that each vertex points to one triangle 
 of the triangulation.
\end{note}

\subsection{Problem and solve}

 For \freefempp  a problem must be given in variational form, %\cite{blop},
 so we need a bilinear form $a(u,v)$ , a linear form $\ell(f,v)$,
and possibly a boundary condition form must be added.
 \index{problem}
\bT
@problem P(u,v) =
     a(u,v) - $\ell$(f,v)
     + (boundary condition);
\eT
For example, see (\ref{eqn:weakform}).

\begin{note} When you want to formulate the problem and to solve it 
in the same time, you can use the keywork \texttt{solve}.
\index{solve}
\end{note}

\subsection{Parameter Description for \texttt{solve} and \texttt{problem}}

The parameters are FE function real or complex, the number $n$ of parameters is even
($n=2*k$), the $k$ first function parameters are unknown, and the $k$
last are test functions.

\begin{note} If the functions are a part of
vectoriel FE then you must give  all the functions of the vectorial
FE in the same order (see laplaceMixte problem for example).
\end{note}
\begin{note} Don't mixte  complex and real parameters  FE function. %add  FH 
\end{note}
\begin{bug}
The mixing of \texttt{fespace} with differents periodic boundary condition is not
implemented. So all the finite element space use for test or unknow functions
in a problem, must  have the same  type of periodic boundary condition or 
no periodic boundary condition. 
No clean message is given and the result is
impredictible, Sorry.\index{periodic}\index{fespace!periodic=}
\end{bug}

\index{solver=!LU}\index{solver=!CG}\index{solver=!Crout}\index{solver=!GMRES}\index{solver=!Cholesky}\index{solver=!UMFPACK}
\index{LU}\index{CG}\index{Crout}\index{GMRES}\index{Cholesky}\index{UMFPACK}

The named parameters are:
\begin{description}
    \item[solver=]   \texttt{LU}, \texttt{CG},\index{solve!solver=}\index{problem!solver=}
    \texttt{Crout},\texttt{Cholesky},\texttt{GMRES},\texttt{UMFPACK} ...

    The default solver is \texttt{LU}.
    The storage mode of the matrix of the underlying linear system
    depends on
    the type of solver chosen; for \texttt{LU}  the matrix is sky-line non
    symmetric, for \texttt{Crout} the matrix is sky-line symmetric, for
    \texttt{Cholesky} the matrix is sky-line symmetric positive
    definite,  for \texttt{CG}   the matrix is sparse symmetric positive,
    and for \texttt{GMRES} or \texttt{UMFPACK} the matrix is just  sparse.

    \item[eps=]  \index{problem!eps=}  \index{solve!eps=} a real expression. $\varepsilon$  sets the stopping test for
    the iterative methods like \texttt{CG}. Note that if $\varepsilon$
    is negative  then the stopping test is:
    $$  || A x - b || < |\varepsilon| $$
    if it is positive then the stopping test is \index{stop test}
        $$  || A x - b || < \frac{|\varepsilon|}{|| A x_{0} - b ||} $$

    \item[init=]   \index{problem!init=}  \index{solve!init=}boolean expression, if it is false or 0 \index{init=}
    the matrix is reconstructed. Note that if the mesh changes the matrix is
    reconstructed too.
    \item[precon=]  \index{problem!precon=}  \index{solve!precon=}name of a function (for example \texttt{P}) to set the precondioner. \index{precon=}
    The prototype for the function \texttt{P} must be
\bFF
    @func @real[@int]  P(@real[@int] & xx) ;
\eFF
      \item[tgv=]  \index{problem!tgv=}  \index{solve!tgv=}  Huge value ($10^{30}$) used to lock boundary conditions (see (\ref{eqn:StiffnessDirichlet}))
\end{description}

\subsection{Problem definition}

Below  \texttt{v} is the unknown function and \texttt{w} is the test function.

  After the "=" sign, one may find sums of:
  \index{int1d}\index{int2d}\index{intalledges}

\begin{itemize}
    \item a name; this is the name given to the
     variational form (type \texttt{varf} \index{varf}) for possible reuse.
    \item  the bilinear form term: for given functions $K$ and 
    unknown function $v$, test tunctions $w$,
    \begin{itemize}
       \item[-)]   \texttt{ int2d(Th)( K*v*w) } $ \displaystyle =       \sum_{T\in\mathtt{Th}}\int_{T } K\,v\,w  $ 
       \item[-)]   \texttt{ int2d(Th,1)( K*v*w) } $ \displaystyle = \sum_{T\in\mathtt{Th},T\subset \Omega_{1}}\int_{T} K\,v\,w  $ 
          
       \item[-)] \texttt{ int1d(Th,2,5)( K*v*w) }  $ \displaystyle = \sum_{T\in\mathtt{Th}}\int_{(\partial T\cup\Gamma) \cap ( \Gamma_2 \cup \Gamma_{5})
          } K\,v\,w  $ 
 
       \item[-)] \texttt{ intalledges(Th)( K*v*w) } $ \displaystyle = \sum_{T\in\mathtt{Th}}\int_{\partial T } K\,v\,w  $ 
       \item[-)] \texttt{ intalledges(Th,1)( K*v*w) } $ \displaystyle = \sum_{{T\in\mathtt{Th},T\subset \Omega_{1}}}\int_{\partial T } K\,v\,w  $ 
        
       \item[-)]  they become a sparse matrix of type \texttt{matrix}
       \end{itemize}
    \item  the linear form term: for given functions $K,\, f$ and test functions $w$,
         \begin{itemize}
       \item[-)]
         \texttt{ int1d(Th)( K*w) } $ \displaystyle = \sum_{T\in\mathtt{Th}}\int_{T
          } K\,w  $ 

      \item[-)] \texttt{ int1d(Th,2,5)( K*w) }   $ \displaystyle = \sum_{T\in\mathtt{Th}}\int_{(\partial T\cup\Gamma) \cap ( \Gamma_2 \cup \Gamma_{5})
          } K \,w  $ 

       \item[-)] \texttt{ intalledges(Th)( f*w) } $ \displaystyle = \sum_{T\in\mathtt{Th}}\int_{\partial T } f\,w  $ 

       \item[-)] a vector of type  \texttt{real[int]}
      \end{itemize}
 
    \item  The boundary condition form term : 
    \begin{itemize}
        \item  An "on" form (for Dirichlet ) :\index{on}
     \texttt{ on(1, u = g )}\index{on}
        \item  a linear form on $\Gamma$  (for Neumann )
         \texttt{ -int1d(Th))( f*w) } or \texttt{ -int1d(Th,3))( f*w) }
        \item   a bilinear form on $\Gamma$  or $\Gamma_{2}$ (for  Robin )
         \texttt{ int1d(Th))( K*v*w) } or
         \texttt{ int1d(Th,2))( K*v*w)}.

    \end{itemize}

\end{itemize}

If needed, the different kind of terms in the sum can appear more than once.

Remark: the integral mesh and the mesh associated to test function or unkwon 
function can be different in the case of linear form.

\begin{note}
 \texttt{N.x} and \texttt{N.y} are the normal's components. \index{normal}\index{N}
 \end{note}

{\bf Important}: it is not possible to write in the same integral the
linear part and the bilinear part such as in
\texttt{ int1d(Th)( K*v*w - f*w) }.

\subsection{\setS{Numerical Integration}}
Let $D$ be a $N$-dimensional bounded domain. 
For an arbitrary polynomials $f$ of degree $r$, 
if we can find particular points $\vec{\xi}_j,\, j=1,\cdots,J$ in $D$ and
constants $\omega_j$ such that 
\begin{eqnarray}
\label{eqn:GaussInt}
\int_{D}f(\vec{x}) = \sum_{\ell =1}^L c_\ell f(\vec{\xi}_\ell)
\end{eqnarray}
then we have the error estimation (see Crouzeix-Mignot (1984)),
then there exists a constant $C>$ such that, 
\begin{eqnarray}
\label{eqn:GaussIntError}
\left|\int_{D}f(\vec{x}) - \sum_{\ell =1}^L \omega_\ell 
f(\vec{\xi}_\ell )\right|
\le C|D|h^{r+1}
\end{eqnarray}
for any function $r + 1$ times continuously differentiable $f$ in $D$, 
where $h$ is the diameter of $D$ and $|D|$ its measure.

a point in the segment $[q^iq^j]$ is given as
\[
\{(x,y)|\; x=(1-t)q^i_x+tq^j_x,\, y=(1-t)q^i_y+tq^j_y,\, 0\le t\le 1\}
\]
For a domain $\Omega_h=\sum_{k=1}^{n_t}T_k,\, \mathcal{T}_h=\{T_k\}$, 
we can calculate the integral over $\Gamma_h=\partial\Omega_h$ by
\begin{eqnarray*}
\int_{\Gamma_h}f(\vec{x})ds&=&\texttt{int1d(Th)(f)}\\
&=&\texttt{int1d(Th,qfe=*)(f)}\\
&=&\texttt{int1d(Th,qforder=*)(f)}
\end{eqnarray*}
where * stands for the name of quadrature formulas or the order of the Gauss formula.
\begin{figure}[hbt]
\begin{tabular}{|c|c|c|c|c|c|}
    \hline
    $L$ & name (\texttt{qfe=}) & order \texttt{qforder=} &  
    point in $[q^iq^j](=t)$ & $\omega_\ell$~~~  & degree of exact \\
    \hline
    \hline
    1 & qf1pE&2&$0$ & $|q^iq^j|$ & 1 \\
    \hline
    2 & qf2pE&3& $(1-\sqrt{1/3})/2$ & $|q^iq^j|/2$ & 3 \\
    & &&$(1+\sqrt{1/3})/2$ & $|q^iq^j|/2$ &  \\
    \hline
    3 & \textbf{qf3pE} &6&$(1-\sqrt{3/5})/2$ & $(5/18)|q^iq^j|$ & 5  \\
    & & & $1/2$ & $(8/18)|q^iq^j|$ & \\
    & & & $(1+\sqrt{3/5})/2$ & $(5/18)|q^iq^j|$ &\\
    \hline
    2 &qf1pElump E&2& $-1$ & $|q^iq^j|/2$ & 1 \\
    & &&$+1$ & $|q^iq^j|/2$ &  \\
    \hline

\end{tabular}
\index{quadrature:qf1pE}\index{quadrature:qf2pE}%
\index{quadrature:qf3pE}%
\index{quadrature:qf1pElump}%
\end{figure}
where $|q^iq^j|$ is the length of segment $\overline{q^iq^j}$.
For a part $\Gamma_1$ of $\Gamma_h$ with the label ``1'', we can 
calculate the integral over $\Gamma_1$ by 
\begin{eqnarray*}
\int_{\Gamma_1}f(x,y)ds&=&\texttt{int1d(Th,1)(f)}\\
&=&\texttt{int1d(Th,1,qfe=qf2pE)(f)}
\end{eqnarray*}
The integral over $\Gamma_1,\, \Gamma_3$ are given by
\begin{eqnarray*}
\int_{\Gamma_1\cup \Gamma_3}f(x,y)ds=\texttt{int1d(Th,1,3)(f)}
\end{eqnarray*}

For each triangule $T_k=[q^{k_1}q^{k_2}q^{k_3}]$ , the point 
$P(x,y)$ in $T_k$ is expressed by the \emph{area coordinate}\index{area coordinate} as $P(\xi,\eta)$:
\begin{eqnarray*}
&&|T_k|=\left|
\begin{array}{ccc}
1&q^{k_1}_x&q^{k_1}_y\\
1&q^{k_2}_x&q^{k_2}_y\\
1&q^{k_3}_x&q^{k_3}_y
\end{array}
\right|\quad
D_1=\left|
\begin{array}{ccc}
1&x&y\\
1&q^{k_2}_x&q^{k_2}_y\\
1&q^{k_3}_x&q^{k_3}_y
\end{array}
\right|
\quad
D_2=\left|
\begin{array}{ccc}
1&q^{k_1}_x&q^{k_1}_y\\
1&x&y\\
1&q^{k_3}_x&q^{k_3}_y
\end{array}
\right|
\quad
D_3=\left|
\begin{array}{ccc}
1&q^{k_1}_x&q^{k_1}_y\\
1&q^{k_2}_x&q^{k_2}_y\\
1&x&y
\end{array}
\right|\\
&&\xi=D_1/|T_k|\qquad
\eta=D_2/|T_k|\qquad \textrm{then }
1-\xi-\eta=D_3/|T_k|
\end{eqnarray*}
For a domain $\Omega_h=\sum_{k=1}^{n_t}T_k,\, \mathcal{T}_h=\{T_k\}$, 
we can calculate the integral over $\Omega_h$ by
\begin{eqnarray*}
\int_{\Omega_h}f(x,y)&=&\texttt{int2d(Th)(f)}\\
&=&\texttt{int2d(Th,qft=*)(f)}\\
&=&\texttt{int2d(Th,qforder=*)(f)}
\end{eqnarray*}
where * stands for the name of quadrature formulas or the order of the Gauss formula.
\begin{figure}[hbt]
\begin{tabular}{|c|c|c|c|c|c|}
    \hline
    $L$ & \texttt{qfe=} & \texttt{qforder=} &  
    point in $T_k$ & $\omega_\ell$~~~  & degree of exact \\
    \hline
    \hline
    1 & qf1pT&2&$\left(\frac{1}{3},\frac{1}{3}\right)$ & $|T_k|$ & 1 \\
    \hline
    3 & qf2pT&3& $\left(\frac{1}{2},\frac{1}{2}\right)$ & $|T_k|/3$ & 2 \\
    & &&$\left(\frac{1}{2},0\right)$ & $|T_k|/3$ &  \\
    & &&$\left(0,\frac{1}{2}\right)$ & $|T_k|/3$ &  \\
    \hline
    7 & \textbf{qf5pT}&6&$\left(\frac{1}{3},\frac{1}{3}\right)$ & $0.225|T_k|$ & 5 \\
    & & & $\left(\frac{6-\sqrt{15}}{21},\frac{6-\sqrt{15}}{21}\right)$ & $
    \frac{(155-\sqrt{15})|T_k|}{1200}$ & \\
    & & & $\left(\frac{6-\sqrt{15}}{21},\frac{9+2\sqrt{15}}{21}\right)$ & $\frac{(155-\sqrt{15})|T_k|}{1200}$ &\\
    & & & $\left(\frac{9+2\sqrt{15}}{21},\frac{6-\sqrt{15}}{21}\right)$ & $\frac{(155-\sqrt{15})|T_k|}{1200}$ &\\
    & & & $\left(\frac{6+\sqrt{15}}{21},\frac{6+\sqrt{15}}{21}\right)$ & $\frac{(155+\sqrt{15})|T_k|}{1200}$ &\\
    & & & $\left(\frac{6+\sqrt{15}}{21},\frac{9-2\sqrt{15}}{21}\right)$ & $\frac{(155+\sqrt{15})|T_k|}{1200}$ &\\
    & & & $\left(\frac{9-2\sqrt{15}}{21},\frac{6+\sqrt{15}}{21}\right)$ & $\frac{(155+\sqrt{15})|T_k|}{1200}$ &\\
    \hline
    3 & qf1pTlump& & $\left(0,0\right)$ & $|T_k|/3$ & 1 \\
    & &&$\left(1,0\right)$ & $|T_k|/3$ &  \\
    & &&$\left(0,1\right)$ & $|T_k|/3$ &  \\
    \hline
    9 & qf2pT4P1& &$\left(\frac{1}{4},\frac{3}{4}\right)$ & $|T_k|/12$ & 1  \\
      &         & &$\left(\frac{3}{4},\frac{1}{4}\right)$ & $|T_k|/12$ &   \\
      &         & &$\left(0,\frac{1}{4}\right)$ & $|T_k|/12$ &   \\
      &         & &$\left(0,\frac{3}{4}\right)$ & $|T_k|/12$ &   \\
      &         & &$\left(\frac{1}{4},0\right)$ & $|T_k|/12$ &   \\
      &         & &$\left(\frac{3}{4},0\right)$ & $|T_k|/12$ &   \\
      &         & &$\left(\frac{1}{4},\frac{1}{4}\right)$ & $|T_k|/6$ &   \\
      &         & &$\left(\frac{1}{4},\frac{1}{2}\right)$ & $|T_k|/6$ &   \\
      &         & &$\left(\frac{1}{2},\frac{1}{4}\right)$ & $|T_k|/6$ &   \\
    \hline
    15 & qf7pT& 8 & see  \cite{0501496} for detail  & &7 \\
       \hline
    21 & qf9pT& 10 & see \cite{0501496} for detail  & &9 \\
    \hline

\end{tabular}
\index{quadrature:qf1pT} \index{quadrature:qf2pT}\index{quadrature: qf5pT}
\index{quadrature:qf1pTlump}\index{quadrature:qf2pT4P1}
\index{quadrature:qf7pT}\index{quadrature:qf7pT}

\index{quadrature:qfe=} \index{quadrature:qft=}\index{quadrature:qforder=}
\end{figure}

\begin{note}
 By default,  we use the formular exact for polynomes of degrees $5$ on triangles or edges (in bold in two tables)\index{quadrature:default}.
\end{note}



\subsection{Variational Form, Sparse Matrix, Right Hand Side Vector}
  \index{varf}\index{array}
  It is possible to define variational forms:
\bFF
@mesh Th=@square(10,10);
@fespace Xh(Th,@P2),Mh(Th,@P1);

@varf bx(u1,q) = @int2d(Th)( (dx(u1)*q));
\eFF
$$ bx(u_{1},q)= \int_{\Omega_{h}} \frac{\partial u_{1}}{\partial x} q $$

\bFF
@varf by(u1,q) = @int2d(Th)( (dy(u1)*q));
\eFF
$$ by(u_{1},q)= \int_{\Omega_{h}} \frac{\partial u_{1}}{\partial y} q $$
\bFF
@varf a(u1,u2)= @int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) )
                    +  @on(1,2,4,u1=0)  +  @on(3,u1=1) ;
\eFF
\begin{note}
 the parameters of the variationnal form are completely formal,  but is not the case
 in \texttt{problem} and \texttt{solve} functionality. %FH add
\end{note}

$$ a(u_{1},v_{2}) = \int_{\Omega_{h}}  \nabla u_{1}.\nabla u_{2}; \quad
             \quad u_{1} = 1*g \mbox{ on } \Gamma_{3}, u_{1} =0 \mbox{ on } \Gamma_{1}\cup \Gamma_{2}\cup \Gamma_{4} $$
 where $f$ is defined later.
 \\
 Later variational forms can be used to construct right hand side vectors,
matrices associated to them, or to define a new problem;\index{matrix}
\bFF
Xh u1,u2,v1,v2;
Mh p,q,ppp;

Xh bc1; bc1[] = a(0,Xh);  //  right hand side for boundary condition
Xh b;

@matrix A= a(Xh,Xh,solver=CG);   // the Laplace matrix \index{matrix!solver} \index{GC} 
@matrix<complex> CA= a(Xh,Xh,solver=CG);   // the complex Laplace matrix \index{matrix!complex} \index{GC} 

@matrix Bx= bx(Xh,Mh);    // $ Bx = (Bx_{ij})$ and $ Bx_{ij}= bx(b^x_j,b^m_j)$
//  where $b^x_j$ is a basis of Xh, and $b^m_j$ is a basis of Mh.
@matrix By= by(Xh,Mh);    // $ By= (By_{ij})$ and $ By_{ij}= by(b^x_j,b^m_j)$
\eFF
\begin{note}
The line of the matrix corresponding to test function on the bilinear form.
\end{note}

\begin{note}
The vector $bc1[]$ contains the contribution of the boundary condition $u_{1}=1$.
\end{note}
Here we have three matrices $A,Bx,By$, and we can solve the problem:\\
find $ u_{1} \in X_{h}$ such that
$$ a(v_{1},u_{1})= by(v_{1},f), \forall v_{1}\in X_{0h}, $$
$$ u_{1} = g , \quad \mbox{on~} \Gamma_{1}, \mbox{and}\quad u_{1}=0 \quad \mbox{on~}  \Gamma_{1}\cup \Gamma_{2}\cup \Gamma_{4}$$
with the following line (where $f=x$, and $ g=\sin(x)$)\index{[]@\verb=[]=}
\bFF
Mh f=x;
Xh g=sin(x);
b[]  = Bx'*f[]; // 
b[] += bc1[] .*bcx[]; // u1= g on $\Gamma_{3}$ boundary see following remark
u1[] = A^-1*b[]; // solve the linear system \index{solve!linear system}\index{\string^-1}
\eFF
\begin{note} The boundary condition \index{boundary condition} is implemented
 by penalization and the vector \texttt{bc1[]} contains
 the contribution of the boundary condition $u_{1}=1$ ,
so to change the boundary condition,
we have just to multiply the vector $bc1[]$ by the value $f$
 of the new boundary condition term by term
with the operator \texttt{.*}.\index{.*@\verb=.*=}
The \refSec{Uzawa} \texttt{StokesUzawa.edp}  gives
 a real example of using all this features.
\end{note}

We add automatic expression optimization by default, if this optimization trap
you can remove the use of this optimization by writing for example : \index{optimize=}
\bFF
@varf a(u1,u2)= @int2d(Th,optimize=false)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) )
                    +  @on(1,2,4,u1=0)  +  @on(3,u1=1) ;
\eFF

Remark, it is all possible to build interpolation matrix, like in 
\index{interpolate}\index{matrix!interpolate}
the following exemple:
\bFF
@mesh  TH = square(3,4);
@mesh  th = square(2,3);
@mesh  Th = square(4,4);


@fespace VH(TH,P1);
@fespace Vh(th,P1);
@fespace Wh(Th,P1);

@matrix B= interpolate(VH,Vh);  // build interpolation matrix  Vh->VH 
@matrix BB= interpolate(Wh,Vh);  // build interpolation matrix  Vh->Wh 
\eFF
and after some operations on sparce matrices are avialable for example
\bFF
  @int N=10;
  @real [int,int] A(N,N);  // a full matrix
  @real [int] a(N),b(N);
  A =0; 
  @for (@int i=0;i<N;i++)
    {
      @A(i,i)=1+i;
      @if(i+1 < N)    A(i,i+1)=-i;
      a[i]=i;
    }
  b=A*b;
  @cout << "xxxx\n"; 
  @matrix sparseA=A; 
  cout << sparseA << endl;
  @sparseA = 2*sparseA+sparseA';  
  @sparseA = 4*sparseA+sparseA*5; //  
  matrix sparseB=sparseA+sparseA+sparseA; ;
  @cout << "sparseB = " << sparseB(0,0) << endl;
\eFF
\subsection{Interpolation matrix}

 This becomes possible to store the matrix of a linear interpolation operator from
 a finite element space $V_h$ to  $W_h$ with \texttt{interpolate} function.
Note that the continuous finite functions are extended by continuity 
to the outside of the domain.


The named parameter of function \texttt{interpolate} are:
\begin{description}
\item[\texttt{inside=}] set true to create zero-extension.
\item[\texttt{t=}] set true to get the transposed matrix
\item[\texttt{op=}] set an integer written below

\begin{description}
\item[0] the default value and interpolate of the function
\item[1] interpolate the $\partial_x$ 
\item[2] interpolate the $\partial_y$  
\end{description}

 
 \index{inside=}\index{interpolate!inside=}
 \index{interpolate!t=}\index{interpolate!t=}.
 \index{interpolate!op=}\index{interpolate!op=}.
\end{description}

\begin{example}[mat\_interpol.edp]~
\bFF
@mesh Th=square(4,4);
@mesh Th4=square(2,2,[x*0.5,y*0.5]);
@plot(Th,Th4,ps="ThTh4.eps",wait=1);
@fespace Vh(Th,P1);     @fespace Vh4(Th4,P1);
@fespace Wh(Th,P0);     @fespace Wh4(Th4,P0);

@matrix IV= interpolate(Vh,Vh4); //  here the function is 
// exended by continuity
cout << " IV Vh<-Vh4 " << IV << endl;

@matrix IV0= interpolate(Vh,Vh4,inside=1); // here the fonction is 
// exended by zero
cout << " IV Vh<-Vh4 (inside=1)  " << IV0 << endl;

@matrix IVt0= interpolate(Vh,Vh4,inside=1,t=1);
cout << " IV Vh<-Vh4^t (inside=1)  " << IVt0 << endl;

@matrix IV4t0= interpolate(Vh4,Vh);
cout << " IV Vh4<-Vh^t  " << IV4t0 << endl;

@matrix IW4= interpolate(Wh4,Wh);
cout << " IV Wh4<-Wh  " << IW4  << endl;

@matrix IW4V= interpolate(Wh4,Vh);
cout << " IV Wh4<-Vh  " << IW4  << endl;
\eFF
\end{example}

\subsection{Finite elements connectivity}
Here, we show how get the informations of a
finite element space $W_h({\cal T}_n,*)$,
where ``*'' denotes P1, P2, P1nc, etc.
\index{nt} \index{ndof} \index{ndofK} \index{connectivity}
\index{FEspace!nt}\index{FEspace!ndof} \index{FEspace!(int ,int )}
\begin{itemize}
\item   \ttCC{Wh.nt}  gives the number of element of $W_h$
\item   \ttCC{   Wh.ndof}  gives the number of degree of freedom or unknows 
\item   \ttCC{   Wh.ndofK }  gives the number of degree of freedom on one element 
\item   \ttCC{   Wh(k,i) }   gives the number of $i$th  degree of freedom of element $k$.
 
\end{itemize}
See the following for an exemple:
\begin{example}[FE.edp]
\bFF
@mesh Th=@square(5,5);
@fespace Wh(Th,P2);
@cout << " nb of degree of freedom           : " << Wh.ndof << endl;
@cout << " nb of degree of freedom / ELEMENT : " << Wh.ndofK << endl;
 @int k= 2;  // element 2 
 @int kdf= Wh.ndofK ;
 @cout << " df of element " << k << ":" ;
 @for (@int i=0;i<kdf;i++)
    @cout << Wh(k,i) << " ";
 @cout << @endl;
\eFF
\end{example}
and the output is:
\bFF
 Nb Of Nodes = 121
 Nb of DF = 121
 FESpace:Gibbs: old skyline = 5841  new skyline = 1377
 nb of degre of freedom           : 121
 nb of degre of freedom / ELEMENT : 6
 df of element 2:78 95 83 87 79 92 
\eFF


\section{Visualization}
Numerical results in FEM create huge data, so it is very important to
make obtained results visible.
There are two ways of visualization in \freefempp:
One is default view supporting the draw of meshes, isovalue of real  FE-functions
and vector fields by the command \ttCC{@plot} (see \refSec{Plot}).
For documentation, \freefempp make the plotting stored as postscript files.

Another method is to use the external tools, for example, gnuplot 
(see Section \ref{sec:gnuplot}), medit (see Section \ref{sec:medit})
 using the command \ttCC{@system}.

\subsection{Plot} \index{sec:Plot}\label{sec:Plot}
   With the command plot,
   meshes, isovalues and vector fields can be displayed.

The parameters of the plot command can be , meshes,real FE functions ,
arrays of 2  real FE functions, arrays of two arrays of double, to plot
respectively mesh,
isovalue, vector field, or curve defined by the two arrays of double.

The named parameter are
\begin{description}
    \item[wait=] boolean expression to wait or not (by default no wait). If true we wait for
    a keyboard up event or mouse event, 
    they respond to an event by the following characters
    \begin{description}
        \item[\texttt{+}]  to zoom in around the mouse cursor,    
        \item[\texttt{-}]  to zoom out around the mouse cursor,   
        \item[\texttt{=}]  to restore de initial graphics state,    
        \item[\texttt{c}]  to decrease the vector arrow coef,  
        \item[\texttt{C}]  to increase the vector arrow coef,    
        \item[\texttt{r}]  to refresh the graphic window,
        \item[\texttt{f}]  to toggle the filling between isovalues,
        \item[\texttt{b}]  to toggle the black and white, 
        \item[\texttt{g}]  to toggle to  grey or color , 
        \item[\texttt{v}]  to toggle  the plotting of value,  
        \item[\texttt{p}]  to save to a postscript file,  
  \item[\texttt{?}]  to show all actives keyboard char,
    \end{description}
    to redraw, otherwise we continue.
    
    \itemtt[ps=]  \index{plot!ps=}  string expression to save the plot on postscript file
    \itemtt[coef=]  \index{plot!coef=} the vector arrow coef between arrow unit and domain unit.
    \itemtt[fill=]  \index{plot!coef=} to fill between isovalues.
     \itemtt[cmm=]  \index{plot!cmm=}string expression to write in the graphic window
     \itemtt[value=]  \index{plot!value=}to plot the value of isoline and the value of vector arrow.
    \itemtt[aspectratio=] \index{plot! aspectratio =}boolean to be sure that the aspect ratio of plot
 is preserved or not.
    \itemtt[bb=] \index{plot!bb=}array of 2 array ( like \texttt{ [[0.1,0.2],[0.5,0.6]]}),
       to set the bounding box and specify a partial view where the  box defined by the two corner points [0.1,0.2] and [0.5,0.6].

    \itemtt[nbiso=]  \index{plot! nbiso =}(int) sets the number of isovalues (20 by default) 
    \itemtt[nbarrow=] \index{plot!nbarraw=} (int) sets the number of colors of arrow values (20 by default) 
    \itemtt[viso=]  \index{plot!viso=}sets the array  value of isovalues (an array real[int]) 
    \itemtt[varrow=] \index{plot!varrow=}  sets the array value of color arrows (an array real[int])
    \itemtt[bw=] \index{plot!bw=} (bool)  sets or not the plot in black and white color.
    \itemtt[grey=] \index{plot!grey=} (bool)  sets or not the plot in grey color.
\end{description}
For example: \index{plot!cut}
\bFF
@real[@int] xx(10),yy(10);
@mesh Th=@square(5,5);
@fespace Vh(Th,@P1);
Vh uh=x*x+y*y,vh=-y^2+x^2;
@int i;
//  compute a cut
@for (i=0;i<10;i++)
 {
   x=i/10.; y=i/10.;
   xx[i]=i;
   yy[i]=uh; // value of uh at point (i/10. , i/10.)
 }
 @plot(Th,uh,[uh,vh],value=true,ps="three.eps",wait=true); // figure \ref{three}
 //  zoom on box defined by the two corner points [0.1,0.2] and [0.5,0.6]
 @plot(uh,[uh,vh],bb=[[0.1,0.2],[0.5,0.6]],
        wait=true,grey=1,fill=1,value=1,ps="threeg.eps"); // figure \ref{threeg}
 @plot([xx,yy],ps="likegnu.eps",wait=true); // figure \ref{likegnu}
\eFF
\twoplot[height=6cm]{three}{threeg}{ mesh, isovalue, and
vector}{inlargement in grey of isovalue, and
vector}

\plot[height=6cm]{likegnu}{Plots a cut of uh. Note that a refinement of the same can be obtained
in combination with gnuplot}

\subsection{link with gnuplot}\label{sec:gnuplot}
\index{gnuplot}\index{exec}
First this work only if gnuplot\footnote{\url{http://www.gnuplot.info/}} is installed , and 
only on unix computer.

You just and to the previous example: 
{\def\bks{$\backslash$}
\bFF
// file for gnuplot
{
  @ofstream gnu("plot.gp");
  @for (int i=0;i<=n;i++)
   {
     gnu <<  xx[i] << " " << yy[i] << endl;
    }
} //  the file plot.gp is close because the variable gnu is delete

//  to call gnuplot command and wait 5 second (tanks to unix command)
//  and make postscipt plot 
@exec("echo 'plot \bks"plot.gp\bks" w l \bks
pause 5 \bks
set term postscript \bks
set output \bks"gnuplot.eps\bks" \bks
replot \bks
quit' | gnuplot"); 
\eFF}
\plot[height=7cm,angle=270]{gnuplot}{Plots a cut of uh with gnuplot}

\subsection{link with medit}\label{sec:medit}
First this work only if medit \footnote{\url{http://www-rocq.inria.fr/gamma/medit/medit.html}} 
software is installed. 

\index{medit}\index{exec}

\bFF
// build square $]-1,1[^2$
mesh Th=square(10,10,[2*x-1,2*y-1]); 
fespace Vh(Th,P1);
Vh u=2-x*x-y*y;

   savemesh(Th,"mm",[x,y,u*.5]); //save mm.points and mm.faces file 
// for medit
   // build a mm.bb file 
  { ofstream file("mm.bb"); 
  file << "2 1 1 "<< u[].n << " 2 \n";
  int j;
  for (j=0;j<u[].n ; j++)  
    file << u[][j] << endl; 
    }  
    // call medit command   
    exec("medit mm");
    // clean files on unix OS
    exec("rm mm.bb      mm.faces   mm.points");

\eFF
\plot[height=10cm]{medit}{medit plot}



\section{Algorithms}

 The associated example is fully defined in \texttt{algo.edp} file.

 \subsection{conjugate Gradient/GMRES}

If we want to solve  the Euler problem: find $ x\in \R^n $  such that  
\begin{equation}
\label{eqn:dJ=0}
\nabla J(x) = \left(\frac{\partial J}{\partial x_i} (\vec{x})\right) = 0
\end{equation}
where $ J$ is a functional (to minimize  for example) from  $ \R^n$ to $ \R$.

If the function is convex we can use the conjugate gradient to solve the problem, and we just need the function (named \texttt{dJ} for example)
which compute $\nabla J$, so the two parameters
are the name of the function with prototype \ttCC{@func\ @real[@int]\  dJ(@real[@int] \& xx)} 
 which compute $\nabla J$, 
a vector \ttCC{x} of type \ttCC{@real[@int]} to initialize the process and get the result.


Given a staring value $\vec{x}^{(0)}$, a maximum number $i_{\max}$ 
of iterations, and an error tolerance $0<\epsilon<1$: 
Put $\vec{x}=\vec{x}^{(0)}$ and write
\begin{quote}\texttt{
NLCG($\nabla J$, $\vec{x}$, precon$=M$, nbiter$=i_{\max}$, eps$=\epsilon$);
}
\end{quote}
Then we get the solution $\vec{x}$ of $\nabla J(\vec{x})=0$.
We can omit parameters \texttt{precon, nbiter, eps}.
Here $M$ is the preconditioner whose default is the identity matrix.
The stopping test is 
\[
\| \nabla J(\vec{x})\|_P\le \epsilon\| \nabla J(\vec{x}^{(0)})\|_P
\]
Writing the minus value in \texttt{eps=}, i.e.,
\begin{quote}\texttt{
NLCG($\nabla J$, $\vec{x}$, precon$=M$, nbiter$=i_{\max}$, eps$=-\epsilon$);
}
\end{quote}
we can use the stopping test
\[
\| \nabla J(\vec{x})\|_P^2\le \epsilon
\]
The named parameter of these three functions are:
\begin{description}  \index{linearCG!nbiter=} \index{linearCG!precon=} \index{linearCG!eps=}\index{linearCG!veps=}
\index{NLCG!nbiter=}  \index{NLCG!eps=}\index{NLCG!veps=}
\index{LinearGMRES!nbiter=} \index{LinearGMRES!precon=} \index{LinearCMRES!eps=}\index{LinearGMRES!veps=}

\itemtt[nbiter=] set the number of iteration (by default $100$)
\itemtt[precon=] set the preconditionner function (\texttt{P} for example)   by default it is the identity, remark the prototype 
is \ttCC{@func\ @real[\@int]\ P(@real[@int] \&x)}.
\itemtt[eps=] set the value of the stop test $\varepsilon$ ($=10^{-6}$ by default) if positive then relative test 
$||\nabla J(x)||_P\leq \varepsilon||\nabla J(x_0)||_P$, otherwise the  absolute test is  $||\nabla J(x)||_P^2\leq |\varepsilon|$.
\itemtt[veps=] set and return the value of the stop test,  if positive then relative test 
$||\nabla J(x)||_P\leq \varepsilon||\nabla J(x_0)||_P$, otherwise the  absolute test is  $||\nabla J(x)||_P^2\leq |\varepsilon|$.
The return value is  minus  the real stop test (remark: it is useful in loop).

\end{description}
\begin{example}[from algo.edp]
For a given function $b$, let us find the minimizer $u$ of the functional
\begin{eqnarray*}
 J(u) &=& \int_{\Omega} f(|\nabla u|^2) - \int_{\Omega}  u b \\
 f(x) &=& ax + x-\ln(1+x), \quad f'(x) = a+\frac{x}{1+x}, \quad f''(x) =  \frac{1}{(1+x)^2}
\end{eqnarray*}
under the boundary condition $u=0$ on $\partial\Omega$.
\bFF
@mesh Th=@square(10,10);  // mesh definition of $\Omega$
@fespace Vh(Th,P1);      // finite element space
@fespace Ph(Th,P0);      // make optimization
\eFF
/*
A small hack to construct a function 
\[
Cl= \left\{
\begin{array}{cl} 1 & \textrm{\rm on interior degree of freedom} \\
 0 & \textrm{\rm on boundary degree of freedom} 
 \end{array}\right. 
\]
*/\\
// Hack to construct an array :\\
//  1 on interior nodes and 0 on boundary nodes
\bFF
@varf vCl(u,v) = @on(1,2,3,4,u=1);
Vh Cl;
Cl[]= vCl(0,Vh,tgv=1);  //  0 and tgv 
@real tgv=Cl[].max;     // 
Cl[] = -Cl[];  Cl[] += tgv; Cl[] /=tgv;
\eFF
// the definition of $f$, $f'$, $f''$ and $b$
\bFF
@real a=0.001;

@func @real f(@real u) { @return u*a+u-log(1+u); }
@func @real df(@real u) { @return a+u/(1+u);}
@func @real ddf(@real u) { @return 1/((1+u)*(1+u));}
Vh b=1;  // to defined b
// the routine to compute the functional $J$
@func @real J(@real[int] & x)
  {
    Vh u;u[]=x; 
    @real r=@int2d(Th)(f( dx(u)*dx(u) + dy(u)*dy(u) ) - b*u) ;
    @cout << "J(x) =" << r << " " << x.min <<  " " << x.max << @endl;
    @return r;
  }
// The function  \index{function}to compute $D J$, where $u$ is the current solution.
Vh u=0; //  the current value of the solution
Vh alpha; // of store  $f'(|\nabla u|^2)$
@int iter=0;
alpha=df( dx(u)*dx(u) + dy(u)*dy(u) ); // optimization 

@func @real[@int] dJ(@real[int] & x)
  {
    @int verb=verbosity; verbosity=0; 
    Vh u;u[]=x; 
    alpha=df( dx(u)*dx(u) + dy(u)*dy(u) ); // optimization 
    @varf au(uh,vh) = @int2d(Th)( alpha*( dx(u)*dx(vh) + dy(u)*dy(vh) ) - b*vh);
    x= au(0,Vh);  
    x = x.* Cl[]; //  the grad in 0 on boundary 
    verbosity=verb;
    @return x; // warning no return of local array  
  }
\eFF
/*
We want to construct also a preconditioner $C$
with solving the problem:  find $u_h \in V_{0h}$ such that
\[
\forall v_h \in V_{0h}, \quad  \int_\Omega \alpha \nabla u_h . \nabla v_h = \int_\Omega b v_h  
\]
where $ \alpha=f'(|\nabla u|^2)$.
*/
\bFF
@varf alap(uh,vh,solver=Cholesky,init=iter)=  
   @int2d(Th)( alpha *( dx(uh)*dx(vh) + dy(uh)*dy(vh) )) + @on(1,2,3,4,uh=0);

@varf amass(uh,vh,solver=Cholesky,init=iter)=  
   @int2d(Th)( uh*vh)  + @on(1,2,3,4,uh=0);

@matrix Amass = alap(Vh,Vh,solver=CG); // \index{matrix}

@matrix Alap=  alap(Vh,Vh,solver=Cholesky,factorize=1);   // \index{Cholesky}\index{factorize=}\index{solver=}

// the preconditionner function
@func @real[@int] C(@real[@int] & x)
{
   @real[@int] u(x.n);
   u=Amass*x;
   x = Alap^-1*u; 
   x = x .* Cl[];     
   @return x; // no return of local array  variable 
}
\eFF
/*
To solve the problem, we make 10 iteration of the conjugate gradient, 
recompute the preconditioner and restart the conjugate gradient:
*/
\bFF
   verbosity=5;
   @int conv=0;
   @real eps=1e-6; 
   @for(@int i=0;i<20;i++)
   {
     conv=NLCG(dJ,u[],nbiter=10,precon=C,veps=eps); // \index{veps=}\index{NLCG}
     @if (conv) break;  // if converge break loop
    
     alpha=df( dx(u)*dx(u) + dy(u)*dy(u) ); // recompute alpha optimization 
     Alap = alap(Vh,Vh,solver=Cholesky,factorize=1);   
     @cout << " restart with new preconditionner " << conv << " eps =" << eps << endl;
    }

   @plot (u,wait=1,cmm="solution with NLCG");
\eFF
\end{example}
For a given symmetric positive matrix $A$, consider the quadratic form
\[
J(\vec{x})=\frac{1}{2}\vec{x}^TA\vec{x}-\vec{b}^T\vec{x}
\]
then $J(\vec{x})$ is minimized by the solution $\vec{x}$ of $A\vec{x}=\vec{b}$.
In this case, we can use the function \texttt{LinearCG}
\begin{quote}\texttt{
LinearCG($A$, $\vec{x}$, precon$=M$, nbiter$=i_{\max}$, eps$=\pm\epsilon$);
}
\end{quote}
If $A$ is not symmetric, we can use GMRES(Generalized Minimum Residual) algorithm by 
\begin{quote}\texttt{
LinearGMRES($A$, $\vec{x}$, precon$=M$, nbiter$=i_{\max}$, eps$=\pm\epsilon$);
}
\end{quote}
Also, we can use the non-linear version of GMRES algorithm
(the functional $J$ is just convex)
\begin{quote}\texttt{
LinearGMRES($\nabla J$, $\vec{x}$, precon$=M$, nbiter$=i_{\max}$, eps$=\pm\epsilon$);
}
\end{quote}
For detail of these algorithms, refer to \cite{Lucquin}[Chapter IV, 1.3].

\subsection{Optimization}
Two algorithms of 
COOOL  a package \cite{coool} are interfaced with
the Newton Raphson method  (call \texttt{Newton}) and 
the  \texttt{BFGS} method. \index{Newton}\index{BFGS} 
Be careful these algorithms, because the
implementation use full matrix.

Example of utilization of \texttt{algo.edp}
\bFF
  @func real J(real[int] & x)
    {
      @real s=0;
      for (int i=0;i<x.n;i++)
         s +=(i+1)*x[i]*x[i]*0.5 - b[i]*x[i];
         cout << "J ="<< s << " x =" <<  x[0] << " " << x[1] << "...\n" ;
      return s;
    }
  b=1; x=2; // set  right hand side and initial gest
  @BFGS(J,dJ,x,eps=1.e-6,nbiter=20,nbiterline=20);
  @cout << "BFGS: J(x) = " << J(x) << " err=" << error(x,b) << endl;
  
\eFF


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mathematical Models}
\label{sec:MathModels}

\subsection{Static Problems}

\subsubsection{\setS{Soap Film}}
Our starting point here will be the mathematical model to find the shape of 
\textbf{soap film} which is glued to the ring on the $xy-$plane 
\begin{equation*}
C=\{(x,y);\;x=\cos t,\,y=\sin t,\,0\leq t\leq 2\pi \}.
\end{equation*}
We assume the shape of the film is descrined as the graph $(x,y,u(x,y))$ of the vertical displacement $u(x,y)\, (x^2+y^2<1)$ under a vertical pressure $p$ 
in terms of force per unit area and an initial tension $\mu$ in terms of force 
per unit length.
Consider ``small plane'' ABCD, A:$(x,y,u(x,y))$, B:$(x,y,u(x+\delta x,y))$, C:$(x,y,u(x+\delta x,y+\delta y))$ and D:$(x,y,u(x,y+\delta y))$.
Let us denote by $\vec{n}(x,y)=(n_x(x,y),n_y(x,y),n_z(x,y))$ the normal vector of the surface $z=u(x,y)$.
We see that the vertical force due to the tension $\mu$ acting along the edge
AD is $-\mu n_x(x,y)\delta y$ and the the vertical force acting along the edge
AD is 
\[
\mu n_x(x+\delta x,y)\delta y\simeq \mu\left(n_x(x,y)
+\frac{\partial n_x}{\partial x}\delta x\right)(x,y)\delta y.
\]
\begin{figure}[htbp]
\label{fig:soupfilm}
\begin{center}
\includegraphics[height=3cm]{soapfilm}
\end{center}
%\caption{``small plane'' ABCD}
\label{fig:soapfilm}
\end{figure}
Similarly, for the edges AB and DC we have
\[
-\mu n_y(x,y)\delta x,\qquad 
\mu\left(n_y(x,y)+\partial n_y/\partial y\right)(x,y)\delta x.
\]
The force in the vertical direction on the surface ABCD due to the tension $\mu$ is given by the summension
\[
\mu\left(\partial n_x/\partial x\right)\delta x\delta y+T\left(\partial n_y/\partial y\right)\delta y\delta x.
\]
Assuming small displacements, we have
\begin{eqnarray*}
\nu_x&=&(\partial u/\partial x)/\sqrt{1+(\partial u/\partial x)^2+(\partial u/\partial y)^2}\simeq \partial u/\partial x,\\
\nu_y&=&(\partial u/\partial y)/\sqrt{1+(\partial u/\partial x)^2+(\partial u/\partial y)^2}\simeq \partial u/\partial y.
\end{eqnarray*}
Letting $\delta x\to dx,\, \delta y\to dy$, we have the equilibrium of the virtical displacement of soap film on ABCD by $p$
\[
\mu dx dy\partial^2 u/\partial x^2 +  \mu dx dy\partial^2 u/\partial y^2 
+ p dx dy = 0.
\]
Using the Laplace operator $\Delta = \partial^2 /\partial x^2 + \partial^2 /\partial y^2$, we can find the virtual displacement write the following
\begin{equation}
-\Delta u = f\quad \mbox{in }\Omega  
\end{equation}%
where $f=p/\mu$, $\Omega =\{(x,y);\;x^{2}+y^{2}<1\}$.
 Poisson's equation (\ref{eqn:Poisson}) appear
also in \textbf{electrostatics} taking the form of $f=\rho /\epsilon $ where 
$\rho $ is the charge density, $\epsilon $ the dielectric constant and $u$
is named as electrostatic potential. The soap film is glued to the ring $%
\partial \Omega =C$, then we have the boundary condition 
\begin{equation}
u=0\quad \mbox{on }\partial \Omega 
\end{equation}%
If the force is gravity, for simplify, we assume that $f=-1$.


\begin{example}[a\_tutorial.edp]~
\index{tutorial!aTutorial.edp}
\bFF
 1 : @border a(t=0,2*pi){ x = cos(t); y = sin(t);label=1;};
 2 :
 3 : @mesh disk = @buildmesh(a(50));
 4 : @plot(disk);
 5 : @fespace femp1(disk,P1);
 6 : femp1 u,v;
 7 : @func f = -1;
 8 : @problem laplace(u,v) =
 9 :     @int2d(disk)( @dx(u)*@dx(v) + @dy(u)*@dy(v) )     //  bilinear form
10 :   - @int2d(disk)( f*v )                          //  linear form
11 :   + @on(1,u=0) ;                                // boundary condition
12 : @func ue = (x^2+y^2-1)/4;   // ue: exact solution
13 : laplace;
14 : femp1 err = u - ue;
15 :
16 : @plot (u,ps="aTutorial.eps",value=true,wait=true);
17 : @plot(err,value=true,wait=true);
18 :
19 : @cout << "error L2=" << @sqrt(@int2d(disk)( err^2) )<< @endl; 
20 : @cout << "error H10=" << @sqrt( @int2d(disk)((dx(u)-x/2)^2)
21 :                               + @int2d(disk)((dy(u)-y/2)^2))<< @endl;
22 :
23 : disk = @adaptmesh(disk,u,err=0.01);
24 : @plot(disk,wait=1);
25 :
26 : laplace;
27 :
28 : @plot (u,value=true,wait=true);
29 : err = u - ue;  // become FE-function on adapted mesh
30 : @plot(err,value=true,wait=true);
31 : cout << "error L2=" << @sqrt(@int2d(disk)( err^2) )<< endl; 
32 : cout << "error H10=" << @sqrt(@int2d(disk)((@dx(u)-x/2)^2)
33 :                              + @int2d(disk)((@dy(u)-y/2)^2))<< endl; 
\eFF
\begin{figure}[htbp]
\begin{minipage}{\textwidth}
\begin{minipage}{0.4\textwidth}
\includegraphics[width=\textwidth]{aTutorial}%
\caption{isovalue of $u$}
\label{aTutorial}
\end{minipage}
\hspace{0.5mm}
\begin{minipage}{0.6\textwidth}
\includegraphics[width=\textwidth]{soapfilm3d}%
\caption{a side view of $u$}
\end{minipage}
\end{minipage}
\end{figure}

In 19th line, the $L^2$-error estimation between the exact solution $u_e$,
$$
\|u_h - u_e\|_{0,\Omega}=\left(\int_{\Omega}|u_h-u_e|^2\, dxdy\right)^{1/2}
$$
and from 20th line to 21th line, the $H^1$-error seminorm estimation
$$
|u_h - u_e|_{1,\Omega}=\left(\int_{\Omega}|\nabla u_h-\nabla u_e|^2\, dxdy\right)^{1/2}
$$
are done on the initial mesh. The results are
$\|u_h - u_e\|_{0,\Omega}=0.000384045,\, |u_h - u_e|_{1,\Omega}=0.0375506$.

After the adaptation, we hava
$\|u_h - u_e\|_{0,\Omega}=0.000109043,\, |u_h - u_e|_{1,\Omega}=0.0188411$.
So the numerical solution is improved by adaptation of mesh.
\end{example}

\subsubsection{Electrostatics}
We assume that there is no current and a time independent charge distribution.
Then the electric field $\vec E$ satisfy
\begin{eqnarray}
\label{eqn:Maxwell0}
\mathrm{div}\vec E=\rho/\epsilon,\quad \mathrm{curl}\vec E=0
\end{eqnarray}
where $\rho$ is the charge density and $\epsilon$ is called the permittivity of free space. From the second equation in (\ref{eqn:Maxwell0}), we can introduce 
the electrostatic potential such that $\vec E=-\nabla \phi$.
Then we have Poisson equation $-\Delta \phi=f$, $f=-\rho/\epsilon$.
We now obtain the equipotential line which is the level curve of $\phi$,
when there are no charges except conductors $\{C_i\}_{1,\cdots,K}$.
Let us assume $K$ conductors $C_1,\cdots,C_K$ within an enclosure $C_0$. 
Each one is held
at an electrostatic potential $\varphi_i$. We assume that the enclosure $C0$ is
held at
potential 0.
In order to know $\varphi(x)$ at any point $x$ of the domain $\Omega$, we must
solve
\begin{equation}
-\Delta \varphi =0\quad \textrm{in  }\Omega ,
\end{equation}
where $\Omega$ is the interior of $C_0$ minus the conductors $C_i$, and 
$\Gamma$ is the boundary of $\Omega$, that is $\sum_{i=0}^N C_i$. 
Here $g$ is any function of $x$ equal to $\varphi_i$ on $C_i$ and to 
0 on $C_0$. The second equation is a reduced form for:
\begin{equation}
\varphi =\varphi _{i}\;\text{on }C_{i},\;i=1...N,\varphi =0\;\text{on\ }%
C_{0}.
\end{equation}
\begin{example}~
First we give the geometical informations; $C_0=\{(x,y);\; x^2+y^2=5^2\}$,
$C_1=\{(x,y):\; \frac{1}{0.3^2}(x-2)^2+\frac{1}{3^2}y^2=1\}$, 
$C_2=\{(x,y):\; \frac{1}{0.3^2}(x+2)^2+\frac{1}{3^2}y^2=1\}$.
Let $\Omega$ be the disk enclosed by $C_0$ with the elliptical holes enclosed
by $C_1$ and $C_2$. Note that $C_0$ is described counterclockwise, whereas the 
elliptical holes are described clockwise, because the boundary must be oriented so that the computational domain is to its left.
\bFF
// a circle with center at (0 ,0) and radius 5
border C0(t=0,2*pi) { x = 5 * cos(t); y = 5 * sin(t); }
border C1(t=0,2*pi) { x = 2+0.3 * cos(t); y = 3*sin(t); }
border C2(t=0,2*pi) { x = -2+0.3 * cos(t); y = 3*sin(t); }

mesh Th = buildmesh(C0(60)+C1(-50)+C2(-50));
plot(Th,ps="electroMesh"); // figure \ref{electroMesh}
fespace Vh(Th,P1);     // P1 FE-space
Vh uh,vh;              // unkown and test function. 
problem Electro(uh,vh) =  //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear
    + on(C0,uh=0)       //  boundary condition on $C_0$
    + on(C1,uh=1)       //  +1 volt on $C_1$
    + on(C2,uh=-1) ;    //  -1 volt on $C_2$

Electro; // solve the problem, see figure \ref{electro} for the solution
plot(uh,ps="electro.eps",wait=true); // figure \ref{electro}
\eFF
\end{example}

\twoplot[height=5cm]{electroMesh}{electro}{Disk with two elliptical holes}
{Equipotential lines, where $C_1$ is located in right hand side}

\subsubsection{Aerodynamics}
Let us consider a wing profile $S$ in a uniform flow. 
Infinity will be represented
by a large circle $\Gamma_{\infty}$. 
As previously, we must solve
\begin{equation}
\label{eqn:NACA-5-5}
\Delta \varphi=0\quad\textrm{in }\Omega,
\quad \varphi|_S=c,\quad 
\varphi|_{\Gamma_{\infty}}=u_{\infty 1x}-u_{\infty2x}
\end{equation}
where $\Omega$ is the area occupied by the 
fluid, $u_{\infty}$ is the air speed at infinity, $c$
is a constant to be determined so that 
$\partial_n\varphi$ is continuous at the trailing edge
$P$ of $S$ (so-called Kutta-Jukowski condition). 
Lift is proportional to $c$.
To find $c$ we use a superposition method. As all equations in 
(\ref{eqn:NACA-5-5}) are
linear, the solution $\varphi_c$ is a linear function of $c$
\begin{equation}
\label{eqn:NACA-5-6}
\varphi_c = \varphi_0 + c\varphi_1, 
\end{equation}
where $\varphi_0$ is a solution of (\ref{eqn:NACA-5-5}) with $c = 0$ and 
$\varphi_1$ is a solution with $c = 1$ and
zero speed at infinity. 
With these two fields computed, we shall determine $c$
by requiring the continuity of $\partial \varphi /\partial n$ at the trailing edge.
An equation for the upper surface of a NACA0012 (this is a classical wing
profile in aerodynamics; the rear of the wing is called the trailing edge) is:
\begin{equation}
\label{eqn:NACA-5-7}
y := 0.17735\sqrt{x} - 0.075597x - 0.212836x^2 + 0.17363x^3 - 0.06254x^4. 
\end{equation}
Taking an incidence angle $\alpha$ such that $\tan \alpha = 0.1$, we must solve
\begin{equation}
\label{eqn:NACA-5-8}
-\Delta\varphi  = 0\qquad \textrm{in }\Omega, \qquad
\varphi|_{\Gamma_1} = y - 0.1x,\quad \varphi |_{\Gamma_2} = c,
\end{equation}
where $\Gamma_2$ is the wing profile and $\Gamma_1$ is an approximation of 
infinity. One finds $c$ by solving:
\begin{eqnarray}
\label{eqn:NACA-5-9}
-\Delta\varphi_0 = 0 ~~\textrm{in }\Omega,\qquad 
\varphi_0|_{\Gamma_1} = y - 0.1x, \quad \varphi_0|_{\Gamma_2} = 0,\\
\label{eqn:NACA-5-10}
-\Delta\varphi_1 = 0 ~~\textrm{in }\Omega, \qquad 
\varphi_1|_{\Gamma_1} = 0, \quad \varphi_1|_{\Gamma_2} = 1.
\end{eqnarray}
The solution $\varphi  = \varphi_0+c\varphi_1$ allows us to find $c$ 
by writing that $\partial_n\varphi$  has no jump
at the trailing edge $P = (1, 0)$. 
We have $\partial n\varphi  -(\varphi (P^+)-\varphi (P))/\delta$ where $P^+$
is the point just above $P$ in the direction normal to the profile at a distance
$\delta$. Thus the jump of $\partial_n\varphi$  is 
$(\varphi_0|_{P^+} +c(\varphi_1|_{P^+} -1))+(\varphi_0|_{P^-} +c(\varphi_1|_{P^-} -1))$
divided by $\delta$ because the normal changes sign between the lower and upper
surfaces. Thus
\begin{equation}
\label{eqn:NACA-5-11}
c = -\frac{\varphi_0|_{P^+} + \varphi_0|_{P^-}}
{(\varphi_1|_{P^+} + \varphi_1|_{P^-} - 2)} ,
\end{equation}
which can be programmed as:
\begin{equation}
\label{eqn:NACA-5-12}
c = -\frac{\varphi_0(0.99, 0.01) + \varphi_0(0.99,-0.01)}
{(\varphi_1(0.99, 0.01) + \varphi_1(0.99,-0.01) - 2)} . 
\end{equation}

\begin{example}
\bFF
// Computation of the potential flow around a NACA0012 airfoil.
// The method of decomposition is used to apply the Joukowski condition
// The solution is seeked in the form psi0 + beta psi1 and beta is
// adjusted so that the pressure is continuous at the trailing edge

@border a(t=0,2*pi) { x=5*cos(t);  y=5*sin(t); };// approximates infinity
 
@border upper(t=0,1) { x = t;  
     y = 0.17735*sqrt(t)-0.075597*t
  - 0.212836*(t^2)+0.17363*(t^3)-0.06254*(t^4); }
@border lower(t=1,0) { x = t; 
     y= -(0.17735*sqrt(t)-0.075597*t
  -0.212836*(t^2)+0.17363*(t^3)-0.06254*(t^4)); }
@border c(t=0,2*pi) { x=0.8*cos(t)+0.5;  y=0.8*sin(t); } 

@wait = @true;
@mesh  Zoom = @buildmesh(c(30)+upper(35)+lower(35));
@mesh Th = @buildmesh(a(30)+upper(35)+lower(35));
@fespace Vh(Th,P2);     // P1 FE space
Vh psi0,psi1,vh;              // unkown and test function. 
@fespace ZVh(Zoom,P2);

@solve Joukowski0(psi0,vh) =     //  definion of  the problem 
    @int2d(Th)( dx(psi0)*dx(vh) + dy(psi0)*dy(vh) ) //  bilinear form
  + @on(a,psi0=y-0.1*x)                      //  boundary condition form
  + @on(upper,lower,psi0=0);
@plot(psi0);

@solve Joukowski1(psi1,vh) =     //  definion of  the problem 
    @int2d(Th)( dx(psi1)*dx(vh) + dy(psi1)*dy(vh) ) //  bilinear form
  + @on(a,psi1=0)                      //  boundary condition form
  + @on(upper,lower,psi1=1);

@plot(psi1);

    // continuity of pressure at trailing edge
@real beta = psi0(0.99,0.01)+psi0(0.99,-0.01);  
@beta = -beta / (psi1(0.99,0.01)+ psi1(0.99,-0.01)-2);


Vh psi = beta*psi1+psi0; 
@plot(psi);
ZVh Zpsi=psi;
@plot(Zpsi,bw=true);
Vh cp = -dx(psi)^2 - dy(psi)^2; 
@plot(cp);
ZVh Zcp=cp;
@plot(Zcp,nbiso=40);
\eFF
\end{example}
\twoplot[height=5cm]{naca1}{naca2}
{isovalue of $cp = -(\partial_x\psi)^2 - (\partial_y\psi)^2$}
{Zooming of $cp$}


\subsubsection{Error estimation}
There are famous estimation between the numerical result $u_h$ and the 
exact solution $u$ of the problem \ref{eqn:Poisson} and \ref{eqn:Dirichlet}:
If triangulations $\{\mathcal{T}_h\}_{h\downarrow 0}$ is regular 
(see \refSec{Regular Triangulation}), then we have the estimates
\begin{eqnarray}
\label{eqn:H1err}
|\nabla u - \nabla u_h|_{0,\Omega}&\le& C_1h\\
\label{eqn:L2err}
\|u - u_h\|_{0,\Omega}&\le& C_2h^2
\end{eqnarray}
with constants $C_1,\, C_2$ independent of $h$, 
if $u$ is in $H^2(\Omega)$. It is known that $u\in H^2(\Omega)$ 
if $\Omega$ is convex.

In this section we check (\ref{eqn:H1err}) and (\ref{eqn:L2err}).
We will pick up numericall error if we use the numerical derivative,
so we will use the following for (\ref{eqn:H1err}).
\begin{eqnarray*}
\int_{\Omega}|\nabla u - \nabla u_h|^2\, dxdy
&=&\int_{\Omega}\nabla u\cdot \nabla(u - 2u_h)\, dxdy+
\int_{\Omega}\nabla u_h\cdot \nabla u_h\, dxdy\\
&=&\int_{\Omega}f(u-2u_h)\, dxdy+\int_{\Omega}fu_h\, dxdy
\end{eqnarray*}
The constants $C_1,\, C_2$ are depend on $\mathcal{T}_h$ and $f$, 
so we will find them by \freefempp. 
In general, we cannot get the solution $u$ as a elementary functions 
(see Section \ref{sec:TwoVarFunctions}) even if spetical functions are added.
Instead of the exact solution, here we use the approximate solution $u_0$  in 
$V_h(\mathcal{T}_h,P_2),\, h\sim 0$.

\begin{example}~
\bFF
 1 : @mesh Th0 = @square(100,100);
 2 : @fespace V0h(Th0,P2);
 3 : V0h u0,v0;
 4 : @func f = x*y; // sin(pi*x)*cos(pi*y);
 5 :
 6 : @solve Poisson0(u0,v0) =
 7 :     @int2d(Th0)( @dx(u0)*@dx(v0) + @dy(u0)*@dy(v0) )     //  bilinear form
 8 :   - @int2d(Th0)( f*v0 )                          //  linear form
 9 :   + @on(1,2,3,4,u0=0) ;                // boundary condition
10 :
11 : @plot(u0);
12 :
13 : @real[int] errL2(10), errH1(10);
14 :
15 : @for (@int i=1; i<=10; i++) {
16 :    @mesh Th = @square(5+i*3,5+i*3);
17 :    @fespace Vh(Th,P1);
18 :    @fespace Ph(Th,P0);
19 :    Ph h = hTriangle;  // get the size of all triangles
20 :    Vh u,v;
21 :    @solve Poisson(u,v) =
22 :         @int2d(Th)( dx(u)*dx(v) + dy(u)*dy(v) )     //  bilinear form
23 :         - @int2d(Th)( f*v )                          //  linear form
24 :         + @on(1,2,3,4,u=0) ;                // boundary condition
25 :    V0h uu = u;
26 :    errL2[i-1] = @sqrt( @int2d(Th0)((uu - u0)^2) )/h[].max^2;
27 :    errH1[i-1] = @sqrt( @int2d(Th0)( f*(u0-2*uu+uu) ) )/h[].max;
28 : }
29 : @cout << "C1 = " << errL2.max <<"("<<errL2.min<<")"<< endl;
30 : @cout << "C2 = " << errH1.max <<"("<<errH1.min<<")"<< endl;
\eFF
\end{example}
We can guess that $C_1=0.0179253(0.0173266)$ and  
$C_2=0.0729566(0.0707543)$, where the numbers inside the parentheses
are minimum in calculation.

\subsubsection{Periodic }\index{periodic}\index{fespace!periodic=}
We now solve the Poisson equation 
$$ -\Delta u= sin(x+\pi/4.)*cos(y+\pi/4.)$$ on 
the square $]0,2\pi[^2$ 
under bi-periodic boundary condition
$u(0,y)=u(2\pi,y)$ for all $y$ and 
$u(x,0)=u(x,2\pi)$ for all $x$.
These boundary conditions are achieved from the definition 
of the periodic finite element space.

\begin{example}[periodic.edp]~
\label{exm:periodic}
\index{tutorial!periodic.edp}
\bFF
@mesh Th=square(10,10,[2*x*pi,2*y*pi]);
// defined the \bgroup\tt fespace\egroup  with periodic condition
//    label :  2 and 4  are left and right   side with y the curve abcissa 
//             1 and 2  are bottom and upper side with x the curve abcissa
@fespace Vh(Th,P2,periodic=[[2,y],[4,y],[1,x],[3,x]]);   
 Vh uh,vh;              // unkown and test function. 
 @func f=sin(x+pi/4.)*cos(y+pi/4.);      //  right hand side function 

@ problem laplace(uh,vh) =                      //  definion of  the problem 
    @int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + @int2d(Th)( -f*vh )                         //  linear form
;                

  @laplace; // solve the problem plot(uh); // to see the result
  @plot(uh,ps="period.eps",value=true);
\eFF
\plot[height=6cm]{period}{The isovalue of solution $u$ with periodic boundary condition}
\end{example}

The periodic condition does not necessarily require 
parallel to the axis. Example \ref{exm:periodic4}
 give such example.

\begin{example}[periodic4.edp]~
\label{exm:periodic4}
\index{tutorial!periodic4.edp}
\bFF
@real r=0.25;
// a diamond with a hole
@border a(t=0,1){x=-t+1; y=t;label=1;}; 
@border b(t=0,1){ x=-t; y=1-t;label=2;};
@border c(t=0,1){ x=t-1; y=-t;label=3;};
@border d(t=0,1){ x=t; y=-1+t;label=4;};
@border e(t=0,2*pi){ x=r*cos(t); y=-r*sin(t);label=0;};
@int n = 10;
@mesh Th= buildmesh(a(n)+b(n)+c(n)+d(n)+e(n)); 
@plot(Th,wait=1);
@real r2=1.732;
@func abs=sqrt(x^2+y^2);
//  warning for periodic condition: \hfilll
//  side a and c \hfilll
//  @on side a (label 1) $ x \in [0,1] $ or $ x-y\in [-1,1] $ \hfilll
//  @on side c (label 3) $ x \in [-1,0]$ or $ x-y\in[-1,1] $\hfilll
// so the common abcissa can be repectively $x$ and $x+1$
// or you can can try curviline abcissa $x-y$ and $x-y$ 
//  1 first way \hfilll
// @fespace Vh(Th,P2,periodic=[[2,1+x],[4,x],[1,x],[3,1+x]]);  \hfilll    
// 2 second way \hfilll
 @fespace Vh(Th,P2,periodic=[[2,x+y],[4,x+y],[1,x-y],[3,x-y]]);     

 Vh uh,vh;             

 @func f=(y+x+1)*(y+x-1)*(y-x+1)*(y-x-1);                
 @real intf = @int2d(Th)(f);
 @real mTh = @int2d(Th)(1);
 @real k =  intf/mTh; 
 @cout << k << @endl; 
 @problem laplace(uh,vh) =                     
    @int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) + @int2d(Th)( (k-f)*vh ) ;                
 laplace; 
 @plot(uh,wait=1,ps="perio4.eps"); 
\eFF
\end{example}
\plot[height=6cm]{perio4}{The isovalue of solution $u$ for
$ \Delta u = ((y+x)^{2}+1)((y-x)^{2}+1) - k$, in $\Omega$ and $\partial_{n} u =0 $ on hole,and with two periodic boundary condition on external border}


\subsubsection{Poisson with mixed boundary condition}
Here we consider the Poisson equation with mixed boundary value 
problems: For given functions $f$ and $g$, find $u$ such that
\begin{eqnarray}
\label{eqn:mixBoundary}
-\Delta u &=& f\qquad \textrm{in }\Omega\nonumber\\ 
u&=&g\quad \textrm{on }\Gamma_D,\quad 
\partial u/\partial n=0\quad \textrm{on }\Gamma_N
\end{eqnarray}
where $\Gamma_D$ is a part of the boundary $\Gamma$ and 
$\Gamma_N=\Gamma\setminus \overline{\Gamma_D}$.
The solution $u$ has the singularity at the points 
$\{\gamma_1,\gamma_2\}=\overline{\Gamma_D}\cap\overline{\Gamma_N}$.
When $\Omega=\{(x,y);\; -1<x<1,\, 0<y<1\}$,
$\Gamma_N=\{(x,y);\; -1\le x<0,\, y=0\}$,\,
$\Gamma_D=\partial \Omega\setminus \Gamma_N$,  
the singularity will appear at $\gamma_1=(0,0),\, \gamma_2(-1,0)$,
and $u$ has the expression
$$
u=K_iu_S + u_R,\, u_R\in H^2(\textrm{near }\gamma_i),\, i=1,2
$$
with a constants $K_i$.
Here $u_S = r_j^{1/2}\sin(\theta_j/2)$ by the local polar coordinate
$(r_j,\theta_j$ at $\gamma_j$ such that
$(r_1,\theta_1)=(r,\theta)$.
Instead of poler coordinate system $(r,\theta)$, we use that
$r=\ttCC{sqrt( x\^2+y\^2 )}$ and $\theta = \ttCC{atan2(y,x)}$
in \freefempp.

\begin{example} Assume that $f=-2\times 30(x^2+y^2)$ and  
$g=u_e=10(x^2+y^2)^{1/4}\sin\left ([\tan^{-1}(y/x)]/2\right)
+30(x^2y^2)$, where $u_e$S is the exact solution.
\bFF
 1 : @border N(t=0,1) { x=-1+t; y=0; label=1; };
 2 : @border D1(t=0,1){ x=t;  y=0; label=2;};
 3 : @border D2(t=0,1){ x=1; y=t; label=2; };
 4 : @border D3(t=0,2){ x=1-t; y=1; label=2;};
 5 : @border D4(t=0,1) { x=-1; y=1-t; label=2; };
 6 :
 7 : @mesh T0h = @buildmesh(N(10)+D1(10)+D2(10)+D3(20)+D4(10));
 8 : @plot(T0h,wait=true);
 9 : @fespace V0h(T0h,P1);
10 : V0h u0, v0;
11 :
12 : @func f=-2*30*(x^2+y^2); // given function
13 : // the singular term of the solution is K*us (K: constant)
14 : @func us = sin(atan2(y,x)/2)*sqrt( sqrt(x^2+y^2) );
15 : @real K=10.;
16 : @func ue = K*us + 30*(x^2*y^2);
17 :
18 : @solve Poisson0(u0,v0) =
19 :     @int2d(T0h)( dx(u0)*dx(v0) + dy(u0)*dy(v0) )     //  bilinear form
20 :   - @int2d(T0h)( f*v0 )                          //  linear form
21 :   + @on(2,u0=ue) ;                                // boundary condition
22 :
23 : // adaptation by the singular term
24 : @mesh Th = @adaptmesh(T0h,us);
25 : @for (@int i=0;i< 5;i++)
26 : {
27 :   @mesh Th=@adaptmesh(Th,us);
28 : } ;
29 :
30 : @fespace Vh(Th, P1);
31 : Vh u, v;
32 : @solve Poisson(u,v) =
33 :     @int2d(Th)( dx(u)*dx(v) + dy(u)*dy(v) )     //  bilinear form
34 :   - @int2d(Th)( f*v )                          //  linear form
35 :   + @on(2,u=ue) ;                                // boundary condition
36 :
37 : /* plot the solution */
38 : @plot(Th,ps="adaptDNmix.ps");
39 : @plot(u,wait=true);
40 :
41 : Vh uue = ue;
42 : @real  H1e = @sqrt( @int2d(Th)( dx(uue)^2 + dy(uue)^2 + uue^2 ) );
43 :
44 : /* calculate the H1 Sobolev norm */
45 : Vh err0 = u0 - ue;
46 : Vh  err = u - ue;
47 : Vh  H1err0 = @int2d(Th)( dx(err0)^2+dy(err0)^2+err0^2 );
48 : Vh  H1err = @int2d(Th)( dx(err)^2+dy(err)^2+err^2 );
49 : @cout <<"Relative error in first mesh "<< @int2d(Th)(H1err0)/H1e<<@endl;
50 : @cout <<"Relative error in adaptive mesh "<< @int2d(Th)(H1err)/H1e<@<endl;
\eFF
From 24th line to 28th, adaptation of meshes are done using the 
base of singular term.
In 42th line, \ttCC{H1e}=$\|u_e\|_{1,\Omega}$ is calculated.
In last 2 lines, the relative errors are calculated, that is,
\begin{eqnarray*}
\|u^0_h-u_e\|_{1,\Omega}/\ttCC{H1e}&=&0.120421\\
\|u^a_h-u_e\|_{1,\Omega}/\ttCC{H1e}&=&0.0150581
\end{eqnarray*}
where $u^0_h$ is the numerical solution in \ttCC{T0h} and
$u^a_h$ is \ttCC{u} in this program.
\end{example}

\subsubsection{Adaptation with residual error indicator}

We do metric mesh adaption and compute the classical 
residual error indicator $\eta_{T}$ on the element $T$ for the Poisson problem.

\begin{example}[adaptindicatorP2.edp]~
\index{tutorial!adaptindicatorP2.edp}
First, we solve the same problem as in a previous example.
\bFF
 1 : @border ba(t=0,1.0){x=t;   y=0;  label=1;}; // see Fig,\ref{L-shape2}
 2 : @border bb(t=0,0.5){x=1;   y=t;  label=2;};
 3 : @border bc(t=0,0.5){x=1-t; y=0.5;label=3;};
 4 : @border bd(t=0.5,1){x=0.5; y=t;  label=4;};
 5 : @border be(t=0.5,1){x=1-t; y=1;  label=5;};
 6 : @border bf(t=0.0,1){x=0;   y=1-t;label=6;};
 7 : @mesh Th = buildmesh (ba(6) + bb(4) + bc(4) +bd(4) + be(4) + bf(6));
 8 : @savemesh(Th,"th.msh");
 9 : @fespace Vh(Th,P2);
10 : @fespace Nh(Th,P0);
11 : Vh u,v;
12 : Nh rho;
13 : real[int] viso(21);
14 : @for (@int i=0;i<viso.n;i++)
15 :   viso[i]=10.^(+(i-16.)/2.);
16 : @real error=0.01;
17 : @func f=(x-y);
18 : @problem Probem1(u,v,solver=CG,eps=1.0e-6) =
19 :     @int2d(Th,qforder=5)( u*v*1.0e-10+  dx(u)*dx(v) + dy(u)*dy(v))
20 :   + @int2d(Th,qforder=5)( -f*v);
21 : /*************
\eFF
\index{jump}\index{intalledges}\index{square}\index{lenEdge}\index{hTriangle}%\index{area}
Now, the local  error indicator $\eta_{T}$ is:
\def\Th{\mathcal{T}_{h}}
\def\AK{\mathcal{E}_{K}}

$$\eta_{T} =\left(  h_{T}^{2} || f + \Delta u_{{h}} ||_{L^{2}(T)}^{2} +\sum_{e\in \AK} h_{e} \,||\, [ \frac{\partial u_{h}}{\partial n_{k}}] \,||^{2}_{L^{2}(e)} \right)^{\frac{1}{2}}
   $$
where $h_{T}$ is the longest's edge of  $T$, ${\cal E}_T$ is the set of $T$ edge not on 
$\Gamma=\partial \Omega$, $n_{T}$ is the  outside unit normal to $K$, $h_{e}$ is the length of edge $e$,
$[ g ]$ is the jump of the function $g$ across edge (left value minus rigth value). 

Of coarse, we can use a variational form to compute $\eta_{T}^{2}$,
with test function constant function in each triangle.
\bFF
29 : *************/
30 :
31 : @varf indicator2(uu,chiK) =
32 :      @intalledges(Th)(chiK*lenEdge*square(jump(N.x*dx(u)+N.y*dy(u))))
33 :     +@int2d(Th)(chiK*square(hTriangle*(f+dxx(u)+dyy(u))) );
34 : for (int i=0;i< 4;i++)
35 : {
36 :   Probem1;
37 :    @cout << u[].min << " " << u[].max << endl;
38 :    @plot(u,wait=1);
39 :    @cout << " indicator2 " << endl;
40 :
41 :    rho[] = indicator2(0,Nh);
42 :    rho=sqrt(rho);
43 :    @cout << "rho =   min " << rho[].min << " max=" << rho[].max << @endl;
44 :    @plot(rho,fill=1,wait=1,cmm="indicator density ",ps="rhoP2.eps",
                                       value=1,viso=viso,nbiso=viso.n);
45 :    @plot(Th,wait=1,cmm="Mesh ",ps="ThrhoP2.eps");
46 :    Th=@adaptmesh(Th,[dx(u),dy(u)],err=error,anisomax=1);
47 :    @plot(Th,wait=1);
48 :    u=u;
49 :    rho=rho;
50 :   error = error/2;
51 : } ;
\eFF
If the method is correct, we expect to look the graphics by an almost constant function $\eta$ on your computer as in Fig. \ref{fig:rhoP2}.
\begin{figure}[hbt]
\begin{center}
\label{fig:rhoP2}
\includegraphics[height=8cm]{rhoP2} \includegraphics[height=8cm]{ThrhoP2}
\end{center}
\caption{Density of the error indicator  with isotropic $P^{2}$ metric }
\end{figure}
\end{example}


\subsection{Elasticity}

Consider an elastic plate with undeformed shape $\Omega\times ]-h,h[$ 
in $\R^3$, $\Omega\subset\R^2$.
By the deformation of the plate, 
we assume that a point $P(x_1,x_2,x_3)$ moves to 
${\cal P}(\xi_1,\xi_2,\xi_3)$.
The vector $\vec u=(u_1,u_2,u_3)=(\xi_1-x_1,\xi_2-x_2,\xi_3-x_3)$ is called 
\key{displacement vector}.
By the deformation, 
the line segment 
$\overline{\mathbf{x},\mathbf{x}+\tau\Delta\mathbf{x}}$ moves approximately to
$\overline{\mathbf{x}+u(\mathbf{x}),\mathbf{x}+\tau\Delta\mathbf{x}
+u(\mathbf{x}+\tau\Delta\mathbf{x})}$ for small $\tau$,
where 
$\mathbf{x}=(x_1,x_2,x_3),\, \Delta\mathbf{x}
=(\Delta x_1,\Delta x_2,\Delta x_3)$.
We now calculate the ratio between two segments
\[
\eta(\tau)=\tau^{-1}|\Delta\mathbf{x}|^{-1}
\left(|u(\mathbf{x}+\tau\Delta\mathbf{x})
-u(\mathbf{x})+\tau\Delta\mathbf{x}|-\tau|\Delta\mathbf{x}|\right)
\]
then we have (see e.g. \cite[p.32]{Necas})
\begin{eqnarray*}
\lim_{\tau\to 0}\eta(\tau)=(1+2e_{ij}\nu_i\nu_j)^{1/2}-1,
\quad 2e_{ij}=\frac{\partial u_k}{\partial x_i}\frac{\partial u_k}{\partial x_j}+\left(\frac{\partial u_i}{\partial x_j}+
\frac{\partial u_j}{\partial x_i}\right)
\end{eqnarray*}
where $\nu_i=\Delta x_i|\Delta\mathbf{x}|^{-1}$. If the deformation is
\emph{small}, then we may consider that 
\[
(\partial u_k/\partial x_i)(\partial u_k/\partial x_i)\approx 0
\]
and the following is called \emph{small \key{strain tensor}}
\[
\varepsilon_{ij}(u)=\frac{1}{2}\left(\frac{\partial u_i}{\partial x_j}+
\frac{\partial u_j}{\partial x_i}\right)
\]
The tensor $e_{ij}$ is called \emph{finite strain tensor}.

Consider the small plane $\Delta \Pi(\mathbf{x})$
centered at $\mathbf{x}$ with the
unit normal direction $\vec n=(n_1,n_2,n_3)$, then the surface 
on $\Delta \Pi(\mathbf{x})$ at $\mathbf{x}$ is
\[
(\sigma_{1j}(\mathbf{x})n_j, \sigma_{2j}(\mathbf{x})n_j, \sigma_{3j}(\mathbf{x})n_j)
\]
where $\sigma_{ij}(\mathbf{x})$ is called \key{stress tensor} at $\mathbf{x}$.
Hooke's law is the assumption of a linear relation between $\sigma_{ij}$
and $\varepsilon_{ij}$ such as
\[
\sigma_{ij}(\mathbf{x})=c_{ijkl}(\mathbf{x})\varepsilon_{ij}(\mathbf{x})
\]
with the symmetry $c_{ijkl}=c_{jikl}, c_{ijkl}=c_{ijlk}, c_{ijkl}=c_{klij}$.

If Hooke's tensor $c_{ijkl}(\mathbf{x})$ do not depend on the choice of
coordinate system, the material is called \key{isotropic} at $\mathbf{x}$.
If $c_{ijkl}$ is constant, the material is called \emph{homogeneous}.
In homogeneous isotropic case, there is \emph{Lam\'{e} constants} 
$\lambda, \mu$ (see e.g. \cite[p.43]{Necas}) satisfying 
\begin{eqnarray}
\label{eqn:isotropic}
\sigma_{ij}=\lambda\delta_{ij}\textrm{div}u+2\mu \varepsilon_{ij}
\end{eqnarray}
where $\delta_{ij}$ is Kronecker's delta.
We assume that 
the elastic plate is fixed 
on $\Gamma_D\times ]-h,h[,\, \Gamma_D\subset \partial\Omega$.
If the body force $f=(f_1,f_2,f_3)$ is given in $\Omega\times]-h,h[$
and surface force $g$ is given in $\Gamma_N\times]-h,h[,
\Gamma_N=\partial\Omega\setminus\overline{\Gamma_D}$,
then the equation of equilibrium is given as follows:
\begin{eqnarray}
\label{eqn:elasticity}
-\partial_j \sigma_{ij}&=&f_i~~\textrm{in }\Omega\times ]-h,h[,\quad
i=1,2,3\\
\sigma_{ij}n_j&=&g_i~~\textrm{on }\Gamma_N\times ]-h,h[,\quad
u_i=0~~\textrm{on }\Gamma_D\times ]-h,h[,\quad i=1,2,3
\end{eqnarray}

We now explain the plain elasticity.
\begin{description}
\item[Plain strain:]
On the end of plate, the contact condition $u_3=0,\, g_3=$ is satisfied.
In this case, we can suppose that $f_3=g_3=u_3=0$ and 
$\vec u(x_1,x_2,x_3)=\overline{u}(x_1,x_2)$ for all $-h<x_3<h$.
\item[Plain stress:] 
The cylinder is assumed to be very thin and subjected to no load on the 
ends $x_3=\pm h$, that is,
\[
\sigma_{3i}=0,\quad x_3=\pm h,\quad i~1,2,3
\]
The assumption leads that $\sigma_{3i}=0$ in $\Omega\times ]-h,h[$
and $\vec u(x_1,x_2,x_3)=\overline{u}(x_1,x_2)$ for all $-h<x_3<h$.
\item[Generalized plain stress:] 
The cylinder is subjected to no load on the ends $x_3=\pm h$.
Introducing the mean values with respect to thickness,
\[
\overline{u}_i(x_1,x_2)=\frac{1}{2h}
\int_{-h}^h u(x_1,x_2,x_3)dx_3
\]
and we derinde $\overline{u}_3\equiv 0$. Similary we define the mean
values $\overline{f},\overline{g}$ of the body force and surface force
as well as the mean values $\overline{\varepsilon}_{ij}$ and
$\overline{\sigma}_{ij}$ of the components of stress and strain, respectively.
\end{description}
In what follows we omit the overlines of 
$\overline{u}, \overline{f},\overline{g}, \overline{\varepsilon}_{ij}$ and
$\overline{\varepsilon}_{ij}$.
Then we obtain similar equation of equilibrium given in (\ref{eqn:elasticity})
replacing $\Omega\times ]-h,h[$ with $\Omega$ and changing $i=1,2$.
In the case of plane stress, 
$\sigma_{ij}=\lambda^* \delta_{ij}\textrm{div}u+2\mu\varepsilon_{ij},
\lambda^*=(2\lambda \mu)/(\lambda+\mu)$.

The equations of elasticity are naturally written in variational form
for the displacement vector $u(x)\in V$ as
\Blue{$$
\int_\Omega [2\mu\epsilon_{ij}(\vec u)\epsilon_{ij}(\vec v)
+\lambda \epsilon_{ii}(\vec{u})\epsilon_{jj}(\vec v)]
=\int_\Omega \vec f\cdot \vec v +\int_\Gamma \vec g\cdot \vec v,%\`{u}
\forall \vec v\in V
$$}
where $V$ is the linear closed subspace of $H^1(\Omega)^2$.

\begin{example}[Beam.edp]
\index{tutorial!beam.edp}
Consider  elastic plate with the undeformed rectangle shape 
$[0,10]\times [0,2]$.
The body force is the gravity force $\vec f$ and the
boundary force $\vec g$ is zero on lower and upper side.
On the two vertical sides of the beam are fixed.
\bFF
//   a weighting beam sitting on a

int bottombeam = 2;
@border a(t=2,0)  { x=0; y=t ;label=1;};        //  left beam
@border b(t=0,10) { x=t; y=0 ;label=bottombeam;};        //  bottom of beam
@border c(t=0,2)  { x=10; y=t ;label=1;};       //  rigth beam
@border d(t=0,10) { x=10-t; y=2; label=3;};     //  top beam 
@real E = 21.5;
@real sigma = 0.29;
@real mu = E/(2*(1+sigma));
@real lambda = E*sigma/((1+sigma)*(1-2*sigma));
@real gravity = -0.05;
@mesh th = buildmesh( b(20)+c(5)+d(20)+a(5));
@fespace Vh(th,[P1,P1]);
Vh [uu,vv], [w,s];
@cout << "lambda,mu,gravity ="<<lambda<< " " << mu << " " << gravity << endl;
// deformation of a beam under its own weight 
@solve  bb([uu,vv],[w,s])  = 
    @int2d(th)(
          2*mu*(dx(uu)*dx(w)+dy(vv)*dy(s)+ ((dx(vv)+dy(uu))*(dx(s)+dy(w)))/2 )
          + lambda*(dx(uu)+dy(vv))*(dx(w)+dy(s))
    ) 
  + @int2d(th) (-gravity*s)
  + @on(1,uu=0,vv=0)
 ;

@plot([uu,vv],wait=1);
@plot([uu,vv],wait=1,bb=[[-0.5,2.5],[2.5,-0.5]]); 
@mesh th1 = movemesh(th, [x+uu, y+vv]);
@plot(th1,wait=1);
\eFF
\end{example}

\subsubsection{Fracture Mechanics}
Consider the plate with the crack whose undeformed shape is 
a curve $\Sigma$ with the two edges $\gamma_1,\, \gamma_2$.
We assume the stress tensor $\sigma_{ij}$ is the state of
plate stress regarding $(x,y)\in \Omega_{\Sigma}=\Omega\setminus \Sigma$.
Here $\Omega$ stands for the undeformed shape of elastic plate
without crack.
If the part $\Gamma_N$ of the boundary $\partial\Omega$ is fixed
and a load ${\cal L}=(\vec f,\vec g)\in
L^2(\Omega)^2\times L^2(\Gamma_N)^2$  is given,
then the displacement $\vec u$ is the minimizer of the potential energy
functional 
\[
{\cal E}(\vec v;{\cal L},\Omega_{\Sigma})
=\int_{\Omega_{\Sigma}}
\{w(x,\vec v)-\vec f\cdot \vec v\}
-\int_{\Gamma_N}\vec g\cdot \vec v\
\] 
over the functional space $V(\Omega_{\Sigma})$,
\[
V(\Omega_{\Sigma})
=\left\{ \vec v\in H^1(\Omega_{\Sigma})^2;\;
\vec v=0\quad \hbox{\rm on }
\Gamma_D=\partial\Omega\setminus\overline{\Gamma_N}\right\},
\]
where $w(x,\vec v)=\sigma_{ij}(\vec v)\varepsilon_{ij}(\vec v)/2$,
\[
\sigma_{ij}(\vec v)=C_{ijkl}(x)\varepsilon_{kl}(\vec v),\quad
\varepsilon_{ij}(\vec v)=(\partial v_i/\partial x_j+
\partial v_j/\partial x_i)/2,
\qquad (C_{ijkl}:\quad \hbox{\rm Hooke's tensor}).
\]
If the elasticity is homogeneous isotropic, then the 
displacement $\vec u(x)$ is decomposed in an open neighborhood $U_k$ 
of $\gamma_k$ as in (see e.g. \cite{Ohtsuka})
\begin{equation}
\label{eqn:SIF} 
\vec u(x) = 
\sum_{l=1}^2 K_l(\gamma_k) r_k^{1/2} S^C_{kl}(\theta_k) 
+ \vec u_{k,R}(x)
\quad \mbox{for }x\in \Omega_{\Sigma}\cap U_k,\, k=1,2
\end{equation}
with $\vec u_{k,R} \in H^2(\Omega_\Sigma\cap U_k)^2$, where 
$U_k,\, k=1,2$ are open neighborhoods of $\gamma_k$ such that
$\partial L_1\cap U_1=\gamma_1,\, \partial L_m\cap U_2=\gamma_2$,
and
\begin{eqnarray}
\label{eqn:SIF2}
 S^C_{k1}(\theta_k) & = & \frac 1 {4\mu} \frac 1 {(2\pi)^{1/2}} 
    \left[ \begin{array}{c} 
    [2\kappa-1]\cos(\theta_k/2)-\cos(3\theta_k/2)\\ 
    -[2\kappa+1]\sin(\theta_k/2)+\sin(3\theta_k/2)
    \end{array}\right],\\
 S^C_{k2}(\theta_k) & = & \frac 1 {4\mu} \frac 1 {(2\pi)^{1/2}} 
    \left[ \begin{array}{c} 
    -[2\kappa-1]\sin(\theta_k/2)+3\sin(3\theta_k/2)\\ 
    -[2\kappa+1]\cos(\theta_k/2)+\cos(3\theta_k/2)
    \end{array}\right]. \nonumber
\end{eqnarray}
where $\mu$ is the shear modulus of elasticity,
$\kappa=3-4\nu$ ($\nu$ is the Poisson's ratio) for 
plane strain and $\kappa=\frac {3-\nu} {1+\nu}$ for plane stress.

The coefficients $K_1(\gamma_i)$ and $K_2(\gamma_i),$ which are important parameters in fracture mechanics,  
are called stress intensity factors of the opening mode (mode I)
and the sliding mode (mode II), respectively.

For simlicity, we consider the following simple crack
\[
\Omega=\{(x,y):\; -1<x<1, -1<y<1\},\qquad
\Sigma=\{(x,y):\; -1\le x\le 0, y=0\}
\]
with only one crack tip $\gamma=(0,0)$.
Unfortunately, \freefempp cannot treat crack, so we use the modification
of the domain with U-shape channel (see Fig. \ref{U-shape})
with $d=0.0001$. The undeformed crack $\Sigma$ is approximated by
\begin{eqnarray*}
\Sigma_d&=&\{(x,y):\; -1\le x\le -10*d, -d\le y\le d\}\\
&&\cup\{(x,y):\; -10*d\le x\le 0, -d+0.1*x\le y\le d-0.1*x\}
\end{eqnarray*}
and $\Gamma_D=\ttCC{R}$ in Fig. \ref{U-shape}.
In this example, we use three technique:
\begin{itemize}
\item 
Fast Finite Element Interpolator from the mesh \ttCC{Th}
to \ttCC{Zoom} for the scale-up of 
near $\gamma$.
\item
After obtaining the displacement vector $\vec u=(u,v)$, we shall watch
the deformation of the crack near $\gamma$ as follows,
\bT
mesh Plate = movemesh(Zoom,[x+u,y+v]);
plot(Plate);
\eT
\item
Important technique is adaptive mesh, because the large singularity occur at 
$\gamma$
as shown in (\ref{eqn:SIF}).
\end{itemize}
First example create mode I deformation by the opposed surface force 
on \ttCC{B} and \ttCC{T}
in the vertical direction of $\Sigma$, and
the displacement is fixed on \ttCC{R}.

In a laboratory, fracture engineer use 
photoelasticity to make stress field visible, which 
shows the principal stress difference
\begin{eqnarray}
\sigma_1-\sigma_2=\sqrt{(\sigma_{11}-\sigma_{22})^2+4\sigma_{12}^2}
\end{eqnarray}
where $\sigma_1$ and $\sigma_2$ are the principal stresses.
In opening mode, the photoelasticity make symmetric pattern concentrated at 
$\gamma$.
\begin{example}[Crack Opening, $K_2(\gamma)=0$]
\bFF{CrackOpen.edp}
@real d = 0.0001;
@int n = 5;
@real cb=1, ca=1, tip=0.0;
@border L1(t=0,ca-d) { x=-cb; y=-d-t; } 
@border L2(t=0,ca-d) { x=-cb; y=ca-t; }
@border B(t=0,2) { x=cb*(t-1); y=-ca; } 
@border C1(t=0,1) { x=-ca*(1-t)+(tip-10*d)*t; y=d; }
@border C21(t=0,1) { x=(tip-10*d)*(1-t)+tip*t; y=d*(1-t); }  
@border C22(t=0,1) { x=(tip-10*d)*t+tip*(1-t); y=-d*t; }  
@border C3(t=0,1) { x=(tip-10*d)*(1-t)-ca*t; y=-d; }
@border C4(t=0,2*d) { x=-ca; y=-d+t; }
@border R(t=0,2) { x=cb; y=cb*(t-1); }  
@border T(t=0,2) { x=cb*(1-t); y=ca; }
@mesh Th = @buildmesh (L1(n/2)+L2(n/2)+B(n)
                       +C1(n)+C21(3)+C22(3)+C3(n)+R(n)+T(n));
cb=0.1; ca=0.1;
@plot(Th,@wait=1);
@mesh Zoom = @buildmesh (L1(n/2)+L2(n/2)+B(n)+C1(n)
                         +C21(3)+C22(3)+C3(n)+R(n)+T(n));
@plot(Zoom,@wait=1);
@real E = 21.5;
@real sigma = 0.29;
@real mu = E/(2*(1+sigma));
@real lambda = E*sigma/((1+sigma)*(1-2*sigma));
@fespace Vh(Th,[P2,P2]);
@fespace zVh(Zoom,P2);
Vh [u,v], [w,s];
@solve  Problem([u,v],[w,s])  = 
    @int2d(Th)(
             2*mu*(dx(u)*dx(w)+ ((dx(v)+dy(u))*(dx(s)+dy(w)))/4 )
             + lambda*(dx(u)+dy(v))*(dx(w)+dy(s))/2 
             ) 
    -@int1d(Th,T)(0.1*(4-x)*s)+@int1d(Th,B)(0.1*(4-x)*s)
    +@on(R,u=0)+on(R,v=0);                // fixed
;

zVh Sx, Sy, Sxy, N;
@for (@int i=1; i<=5; i++) 
{
  @mesh Plate = @movemesh(Zoom,[x+u,y+v]); // deformation near $\gamma$
  Sx = lambda*(dx(u)+dy(v)) + 2*mu*dx(u);
  Sy = lambda*(dx(u)+dy(v)) + 2*mu*dy(v);
  Sxy = mu*(dy(u) + dx(v));
  N = 0.1*1*sqrt((Sx-Sy)^2+4*Sxy^2); //principal stress difference
  @if (i==1) {
     @plot(Plate,ps="1stCOD.eps",bw=1); // Fig. \ref{1stMode1}
     @plot(N,ps="1stPhoto.eps",bw=1);   // Fig. \ref{1stMode1}
  } @else @if (i==5) {
     @plot(Plate,ps="LastCOD.eps",bw=1); // Fig. \ref{LastMode1}
     @plot(N,ps="LastPhoto.eps",bw=1);   // Fig. \ref{LastMode1}
     @break;
  }
  Th=@adaptmesh(Th,[u,v]);
  Problem;
}
\eFF
\end{example}

\begin{figure}[hbt]
\begin{multicols}{2}
\begin{center}
\includegraphics*[height=3cm]{1stCOD}\includegraphics*[height=3cm]{1stPhoto}
    \caption{\label{1stMode1} Crack open displacement (COD) and Principal stress difference in the first mesh}
\end{center}
\begin{center}
\includegraphics*[height=3cm]{LastCOD}\includegraphics*[height=3cm]{LastPhoto}
    \caption{\label{LastMode1} COD and Principal stress difference in the last adaptive mesh}
\end{center}
\end{multicols}
\end{figure}
It is difficult to create mode II deformation by the opposed shear force 
on \ttCC{B} and \ttCC{T} that is observed in a laboratory.
So we use the body shear force along $\Sigma$, that is, the $x$-component $f_1$
of the body force $\vec f$ is given by
\[
f_1(x,y)=H(y-0.001)*H(0.1-y)-H(-y-0.001)*H(y+0.1) 
\]
where $H(t)=1$ if $t>0$; $= 0$ if $t<0$.

\begin{example}[Crack Sliding, $K_2(\gamma)=0$]
\bFF
(use the same mesh Th)
cb=0.01; ca=0.01;
@mesh Zoom = @buildmesh (L1(n/2)+L2(n/2)+B(n)+C1(n)
                         +C21(3)+C22(3)+C3(n)+R(n)+T(n));
(use same FE-space Vh and elastic modulus)
@fespace Vh1(Th,P1);
Vh1 fx = ((y>0.001)*(y<0.1))-((y<-0.001)*(y>-0.1)) ;

@solve  Problem([u,v],[w,s])  = 
    @int2d(Th)(
             2*mu*(dx(u)*dx(w)+ ((dx(v)+dy(u))*(dx(s)+dy(w)))/4 )
             + lambda*(dx(u)+dy(v))*(dx(w)+dy(s))/2 
             ) 
    -@int2d(Th)(fx*w)
    +@on(R,u=0)+@on(R,v=0);        // fixed
;

@for (@int i=1; i<=3; i++) 
{
  @mesh Plate = @movemesh(Zoom,[x+u,y+v]); // deformation near $\gamma$
  Sx = lambda*(dx(u)+dy(v)) + 2*mu*dx(u);
  Sy = lambda*(dx(u)+dy(v)) + 2*mu*dy(v);
  Sxy = mu*(dy(u) + dx(v));
  N = 0.1*1*sqrt((Sx-Sy)^2+4*Sxy^2); //principal stress difference
  @if (i==1) {
     @plot(Plate,ps="1stCOD2.eps",bw=1); // Fig. \ref{LastMode2}
     @plot(N,ps="1stPhoto2.eps",bw=1);   // Fig. \ref{1stMode2}
  } else if (i==3) {
     @plot(Plate,ps="LastCOD2.eps",bw=1); // Fig. \ref{LastMode2}
     @plot(N,ps="LastPhoto2.eps",bw=1);   // Fig. \ref{LastMode2}
     break;
  }
  Th=@adaptmesh(Th,[u,v]);
  Problem;
}
\eFF
\end{example}
\begin{figure}[hbt]
\begin{multicols}{2}
\begin{center}
\includegraphics*[height=3cm]{1stCOD2}\includegraphics*[height=3cm]{1stPhoto2}
    \caption{\label{1stMode2} (COD) and Principal stress difference in the first mesh}
\end{center}
\begin{center}
\includegraphics*[height=3cm]{LastCOD2}\includegraphics*[height=3cm]{LastPhoto2}
    \caption{\label{LastMode2} COD and Principal stress difference in the last adaptive mesh}
\end{center}
\end{multicols}
\end{figure}


\subsection{Nonlinear Static Problems}
We propose how to solve the following non-linear academic  problem of minimization
of a functional $$J(u) = \int_\Omega f(|\nabla u|^2) - u*b $$
where $u$ is function of $H^1_0(\Omega)$
and $f$ defined by
$$
f(x) = a*x + x-ln(1+x), \quad f'(x) = a+\frac{x}{1+x}, \quad f''(x) =  \frac{1}{(1+x)^2}
$$

\subsubsection{Newton Ralphson algorithm}


Now, we solve the Euler problem $ \nabla J (u) = 0$ 
with Newton Ralphson algorithm, that is,
$$ 
u^{n+1} = u^n - ( \nabla^2 J (u^{n}))^{-1}*dJ(u^n) 
$$ 

\index{Newton}
First we introduice the two variational form \texttt{vdJ} and \texttt{vhJ} to
compute respectively $ \nabla J$ and $ \nabla^2 J$
\bFF
//   methode of  Newton Ralphson to solve dJ(u)=0; \hfilll
//    $$ u^{n+1} = u^n - (\frac{\partial dJ}{\partial u_i})^{-1}*dJ(u^n) $$ \hfilll
//   --------------------------------------------- \hfilll
  Ph dalpha ; //to store = $f''( |\nabla u|^2) $  optimisation


  // the variational form of evaluate  dJ = $ \nabla J$ \hfilll
  // -------------------------------------- \hfilll
  //  dJ =  f'()*( dx(u)*dx(vh) + dy(u)*dy(vh) \hfilll
  @varf vdJ(uh,vh) =  int2d(Th)( alpha*( dx(u)*dx(vh) + dy(u)*dy(vh) ) - b*vh)
  + on(1,2,3,4, uh=0);


  // the variational form of evaluate  ddJ   $= \nabla^2 J$ \hfilll
  // hJ(uh,vh) =  f'()*( dx(uh)*dx(vh) + dy(uh)*dy(vh) \hfilll
  //            + f''()( dx(u)*dx(uh) + dy(u)*dy(uh) ) * (dx(u)*dx(vh) + dy(u)*dy(vh)) \hfilll
  @varf vhJ(uh,vh) = int2d(Th)( alpha*( dx(uh)*dx(vh) + dy(uh)*dy(vh) )
   +  dalpha*( dx(u)*dx(vh) + dy(u)*dy(vh)  )*( dx(u)*dx(uh) + dy(u)*dy(uh) ) )
   + on(1,2,3,4, uh=0);
   
 // the Newton algorithm \hfilll
  Vh v,w; 
  u=0;
  @for (int i=0;i<100;i++)
   {
    alpha = df( dx(u)*dx(u) + dy(u)*dy(u) ) ; // optimization
    dalpha = ddf( dx(u)*dx(u) + dy(u)*dy(u) ) ; // optimization
    v[]= vdJ(0,Vh);  // $ v = \nabla J(u) $
    real res= v[]'*v[]; // the dot product 
    cout << i <<  " residu^2 = " <<  res  << endl;
    @if( res< 1e-12) @break;
    @matrix H= vhJ(Vh,Vh,factorize=1,solver=LU); //\index{matrix!factorize=}
    w[]=H^-1*v[];
    u[] -= w[];
   }
   plot (u,wait=1,cmm="solution with Newton Ralphson");
\eFF

\subsection{Eigenvalue Problems}

This section depend on your FreeFem++ compilation process (see \texttt{README\_arpack}),
of this tools.  
This tools is available in \texttt{FreeFem++}  if the word ``eigenvalue'' appear in line ``Load:'', like:
\bFF
-- FreeFem++ v1.28 (date Thu Dec 26 10:56:34 CET 2002)
 file : LapEigenValue.edp
 Load: lg_fem lg_mesh @eigenvalue 
\eFF
This tools is based on the \texttt{arpack++} \footnote{\url{http://www.caam.rice.edu/software/ARPACK/}}
the object-oriented version of ARPACK eigenvalue package \cite{arpack}.

The function EigenValue compute the generalized eigenvalue 
of  $ A u = \lambda B u $ where sigma =$\sigma$ is the shift of the method.
The matrix  $ OP$ is defined with $ A - \sigma B $.
The return value is the number of converged eigenvalue (can be greater than the number of eigen value nev=)

\bFF
@int k=@EigenValue(OP,B,nev= , sigma= );
\eFF
where the matrix $OP=  A - \sigma B $ with a solver and boundary condition,
and the matrix $B$.

\begin{description}
          \item[\texttt{sym=}]    the problem is symmetric (all the eigen value are real) 
          \item[\texttt{nev=}]    the number desired eigenvalues (nev)  close to the shift.
        \item[\texttt{value=}]    the array to store the real part of the eigenvalues
         \item[\texttt{ivalue=}]     the array to store the imag. part of the eigenvalues 
         \item[\texttt{vector=}]    the array to store the eigenvectors. 
 For real nonsymmetric problems, complex eigenvectors are given as two consecutive vectors, so if eigenvalue $k$ and $k+1$ are complex conjugate eigenvalues, the $k$th vector will contain the real part and the $k+1$th vector the imaginary part of the corresponding complex conjugate eigenvectors. 

         \item[\texttt{tol=}]        the relative accuracy to which eigenvalues are to be determined;
         \item[\texttt{sigma=}]    the shift value;
         \item[\texttt{maxit=}]    the maximum number of iterations allowed;
          \item[\texttt{ncv=}]     the number of Arnoldi vectors generated at each iteration of ARPACK.
 \end{description}


\begin{example}[lapEignenValue.edp]
\label{exm:lapEigenValue}
In the first example, we compute   the eigenvalue and the eigenvector of the 
 Dirichlet problem  on square $\Omega=]0,\pi[^2$. 

The problem is find:   $\lambda$, and $\nabla u_{\lambda}$  in $\mathbb{R} H^1_0(\Omega)$
$$ \int_\Omega \nabla u_{\lambda} \nabla v = \lambda \int_\Omega u  v \quad  \forall v \in H^1_0(\Omega)$$

The exact 
eigenvalues are $\lambda_{n,m} =(n^2+m^2), (n,m)\in {\mathbb{N}_*}^2$ with 
the associated eigenvectors are  $  u_{{m,n}}=sin(nx)*sin(my)$.



We use the generalized inverse shift mode of the \texttt{arpack++} library, to find 
20 eigenvalue and eigenvector close to the shift value $\sigma=20$.

\bFF
//  Computation of the eigen value and eigen vector of the \hfilll
//  Dirichlet problem  on square $]0,\pi[^2$ \hfilll
// ----------------------------------------\hfilll
// we use the inverse shift mode \hfilll
// the shift is given with the real sigma\hfilll
// -------------------------------------\hfilll
//  find $\lambda$ and $u_\lambda\in H^1_0(\Omega)$ such that: \hfilll
// \hfilll$\displaystyle  \int_{\Omega}  \nabla u_{\lambda} \nabla v = \lambda \int_{\Omega} u_{\lambda}   v , \forall v \in H^1_0(\Omega) $\hfilll
verbosity=10;
@mesh Th=square(20,20,[pi*x,pi*y]);
@fespace Vh(Th,@P2);
Vh u1,u2;


@real sigma = 20;  // value of the shift 

// OP = A - sigma B ;  //  the shifted matrix
@varf  op(u1,u2)= int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) - sigma* u1*u2 )
                    +  on(1,2,3,4,u1=0) ;  // Boundary condition
                   
@varf b([u1],[u2]) = int2d(Th)(  u1*u2 ) ; // no  Boundary condition

@matrix OP= op(Vh,Vh,solver=Crout,factorize=1);  // crout solver because the matrix in not positive
@matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 

// important remark:
// the boundary condition is make with exact penalisation:
//     we put 1e30=tgv  on the diagonal term of the lock degre of freedom.
//  So take dirichlet boundary condition just on $a$ variationnal form
// and not on  $b$ variationnanl form.
// because we solve $ w=OP^-1*B*v $

int nev=20;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store the  nev eigenvalue
Vh[int] eV(nev);   // to store the nev eigenvector \index{EigenValue}


@int k=@EigenValue(OP,B,sym=true,sigma=sigma,value=ev,vector=eV,
                   tol=1e-10,maxit=0,ncv=0);

//   tol= the tolerace \hfilll
//   maxit= the maximum iteration see arpack doc.\hfilll
//   ncv   see arpack doc. \url{http://www.caam.rice.edu/software/ARPACK/}\hfilll
//  the return value is number of converged eigen value.\hfilll

@for (@int i=0;i<k;i++)
{
  u1=eV[i];
  @real gg = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1));
  @real mm= int2d(Th)(u1*u1) ;
  @cout << " ---- " <<  i<< " " << ev[i]<< " err= " 
       <<int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1) - (ev[i])*u1*u1) << " --- "<<endl;
  @plot(eV[i],cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=1,value=1);
}

\eFF

The output of this example is:

\bFF

   Nb of edges on Mortars  = 0
   Nb of edges on Boundary = 80, neb = 80
 Nb Of Nodes = 1681
 Nb of DF = 1681
Real symmetric eigenvalue problem: A*x - B*x*lambda


Thanks to ARPACK++ class ARrcSymGenEig
Real symmetric eigenvalue problem: A*x - B*x*lambda
Shift and invert mode  sigma=20

Dimension of the system            : 1681
Number of 'requested' eigenvalues  : 20
Number of 'converged' eigenvalues  : 20
Number of Arnoldi vectors generated: 41
Number of iterations taken         : 2

Eigenvalues:
  lambda[1]: 5.0002
  lambda[2]: 8.00074
  lambda[3]: 10.0011
  lambda[4]: 10.0011
  lambda[5]: 13.002
  lambda[6]: 13.0039
  lambda[7]: 17.0046
  lambda[8]: 17.0048
  lambda[9]: 18.0083
  lambda[10]: 20.0096
  lambda[11]: 20.0096
  lambda[12]: 25.014
  lambda[13]: 25.0283
  lambda[14]: 26.0159
  lambda[15]: 26.0159
  lambda[16]: 29.0258
  lambda[17]: 29.0273
  lambda[18]: 32.0449
  lambda[19]: 34.049
  lambda[20]: 34.0492

 ---- 0 5.0002 err= -0.000225891 --- 
 ---- 1 8.00074 err= -0.000787446 --- 
 ---- 2 10.0011 err= -0.00134596 --- 
 ---- 3 10.0011 err= -0.00134619 --- 
 ---- 4 13.002 err= -0.00227747 --- 
 ---- 5 13.0039 err= -0.004179 --- 
 ---- 6 17.0046 err= -0.00623649 --- 
 ---- 7 17.0048 err= -0.00639952 --- 
 ---- 8 18.0083 err= -0.00862954 --- 
 ---- 9 20.0096 err= -0.0110483 --- 
 ---- 10 20.0096 err= -0.0110696 --- 
 ---- 11 25.014 err= -0.0154412 --- 
 ---- 12 25.0283 err= -0.0291014 --- 
 ---- 13 26.0159 err= -0.0218532 --- 
 ---- 14 26.0159 err= -0.0218544 --- 
 ---- 15 29.0258 err= -0.0311961 --- 
 ---- 16 29.0273 err= -0.0326472 --- 
 ---- 17 32.0449 err= -0.0457328 --- 
 ---- 18 34.049 err= -0.0530978 --- 
 ---- 19 34.0492 err= -0.0536275 --- 
\eFF

\twoplot[height=8cm]{eigen11}{eigen12}{Isovalue of 11th eigenvector $u_{4,3}-u_{3,4}$}{Isovalue of 12th eigenvector $u_{4,3}+u_{3,4}$}
\end{example}

\subsection{\setS{Evolution Problems}}
\freefempp also solve evolution problems such as the heat problem
\begin{eqnarray}
\label{prb:heat}
&&\frac{\partial u}{\partial t}-\mu\Delta u=f\quad \textrm{in }\Omega\times ]0,T[,\\
&&u(\vec x,0)=u_0(\vec x)\quad \textrm{in }\Omega; \qquad
\left(\partial u/\partial n\right)(\vec x,t)=0\quad\textrm{on }\partial\Omega\times ]0,T[.\nonumber
\end{eqnarray}
with a positive viscosity coefficient $\mu$ and homogeneous Neumann boundary conditions. 
We solve (\ref{prb:heat}) by FEM in space and finite differences in time.
We use the definition of the partial derivative of the solution in the time
derivative,
\[
\frac{\partial u}{\partial t}(x,y,t) = \lim_{\tau \to 0}
\frac{u(x,y,t)-u(x,y,t-\tau )}{\tau }
\]
which indicate that $u^m(x,y)=u(x,y,m\tau )$ imply
\[
\frac{\partial u}{\partial t}(x,y,m\tau )\simeq \frac{u^m(x,y)-u^{m-1}(x,y)}{\tau }
\]
The time descrezation of heat equation (\ref{eqn:heat}) is as follows:
\begin{eqnarray}
\label{eqn:heat}
&&\frac{u^{m+1}-u^{m}}{\tau }-\mu\Delta u^{m+1}=f^{m+1}
\quad \textrm{in }\Omega\\
&&u^0(\vec x)=u_0(\vec x)\quad \textrm{in }\Omega; \qquad
\partial u^{m+1}/\partial n(\vec x)=0\quad\textrm{on }\partial\Omega,\quad 
\textrm{for all }m=0,\cdots,[T/\tau ],\nonumber
\end{eqnarray}
which is so-called \key{backward Euler method} for (\ref{eqn:heat}).
Multiplying the test function $v$ both sides of the formula 
just above, we have 
\begin{equation*}
\int_{\Omega }\{u^{m+1}v-\tau \Delta u^{m+1}v\}
=\int_{\Omega }\{u^m+\tau  f^{m+1}\}v\, .
\end{equation*}%
By the divergence theorem, we have
\begin{equation*}
\int_{\Omega} \{u^{m+1}v+\tau \nabla u^{m+1}\cdot \nabla v\}
-\int_{\partial\Omega} \tau \left( \partial u^{m+1}/\partial n\right) v=\int_{\Omega }\{u^mv+\tau f^{m+1}v\}.
\end{equation*}%
By the boundary condition $\partial u^{m+1}/\partial n=0$, it follows that
\begin{equation}
\label{eqn:BackEuler}
\int_{\Omega} \{u^{m+1}v+\tau \nabla u^{m+1}\cdot \nabla v\}-
\int_{\Omega }\{u^mv+\tau f^{m+1}v\}=0.
\end{equation}%
Using the identity just above, we can calculate the finite element 
approximation $u_h^m$ of $u^m$ in a step-by-step manner with respect to $t$.

\begin{example}
We now solve the following example with the exact solution $u(x,y,t)=tx^4$.
\begin{eqnarray*}
&&\frac{{\partial u}}{{\partial t}} - \mu \Delta u = x^4 - \mu 12tx^2 ~
\textrm{in  } \Omega  \times ]0,3[,\, \Omega = ]0,1[^2 \\ 
&&u(x,y,0) = 0\quad\textrm{on }\Omega,\qquad \left. u \right|_{\partial\Omega}  = t*x^4
\end{eqnarray*}
\bFF
// heat equation  $\partial_t u = -\mu \Delta u = x^4 - \mu 12tx^2$
@mesh Th=@square(16,16);
@fespace Vh(Th,P1);

Vh u,v,uu,f,g;
@real dt = 0.1, mu = 0.01;
@problem dHeat(u,v) =
    @int2d(Th)( u*v + dt*mu*(@dx(u)*@dx(v) + @dy(u)*@dy(v))) 
    + @int2d(Th) (- uu*v - dt*f*v )
    + @on(1,2,3,4,u=g);

@real t = 0; // start from t=0
uu = 0;     // u(x,y,0)=0
@for (@int m=0;m<=3/dt;m++)
{
   t=t+dt;
   f = x^4-mu*t*12*x^2;
   g = t*x^4;
   dHeat;
   @plot(u,wait=true);
   uu = u;
   @cout <<"t="<<t<<"L^2-Error="<<@sqrt( @int2d(Th)((u-t*x^4)^2) ) << @endl;
}
\eFF
In the last statement, the $L^2$-error 
$\left(\int_{\Omega}\left| u-tx^4\right|^2\right)^{1/2}$ is calculated at 
$t=m\tau , \tau =0.1$. At $t=0.1$, the error is 0.000213269.
The errors increase with $m$ and 0.00628589 at $t=3$.

The iteration of the backward Euler (\ref{eqn:BackEuler}) is made by 
\textbf{for loop} (see \refSec{Loops}).
\end{example}

\begin{note}
The stiffness matrix in loop is used over and over again. 
\freefempp support reuses of stiffness matrix.
\end{note}

\subsubsection{Mathematical Theory on time difference}
In this section, we show the advantage of the backward Euler.
Let $V, H$ be separable Hilbert space and $V$ is dense in $H$.
Let $a$ be a continuous bilinear form over $V \times V$ with coercivity and
symmetry.
Then $\sqrt{a(v,v)}$ become equivalent to the norm $\| v\|$ of $V$.

\textbf{problem} Ev$(f,\Omega)$: For a given $f\in L^2(0,T;V'),\, u^0\in H$
\begin{eqnarray}
\label{eqn:Abstract}
\frac{d}{dt}(u(t),v)+a(u(t),v)&=&( f(t),v)\qquad \forall v\in V,,\quad a.e. \, t\in [0,T]\\
u(0)&=&u^0\nonumber
\end{eqnarray}
where $V'$ is the dual space of $V$.
Then, there is an unique solution  
$u\in L^{\infty}(0,T;H)\cap L^2(0,T;V)$.

Let us denote the time step by $\tau>0$, $N_T=[T/\tau]$.
For the discretization, we put $u^n = u(n\tau)$
and consider the time difference for each $\theta\in [0,1]$
\begin{eqnarray}
\label{eqn:t-method}
\frac{1}{\tau}\left( u_h^{n+1}-u_h^n,\phi_i\right)
+a\left( u_h^{n+\theta},\phi_i\right)=\langle f^{n+\theta},\phi_i\rangle\\
i=1,\cdots, m,\quad n=0,\cdots, N_T\nonumber\\
u_h^{n+\theta}=\theta u_h^{n+1}+(1-\theta)u_h^n,\quad
f^{n+\theta}=\theta f^{n+1}+(1-\theta)f^n\nonumber
\end{eqnarray}
Formula (\ref{eqn:t-method}) is the \emph{forward Euler scheme} if 
$\theta=0$, \emph{Crank-Nicolson scheme} if $\theta=1/2$, 
the \emph{backward Euler scheme} if $\theta=1$.

Unknown vectors $u^n=(u_h^1,\cdots,u_h^M)^T$ in
\[
u_h^n(x)=u^n_1\phi_1(x)+\cdots+u^n_m\phi_m(x),\quad u^n_1,\cdots,u^n_m\in \R
\]
are obtained from solving the matrix
\begin{eqnarray}
\label{eqn:Evolution-1}
(M+\theta\tau A)u^{n+1}=\{M-(1-\theta)\tau A\}u^n
+\tau\left\{\theta f^{n+1}+(1-\theta)f^n\right\}\\
M=(m_{ij}),\quad m_{ij}=(\phi_j,\phi_i),\qquad
A=(a_{ij}),\quad a_{ij}=a(\phi_j,\phi_i)\nonumber
\end{eqnarray}
Refer \cite[pp.70--75]{TA94} for solvability of (\ref{eqn:Evolution-1}).
The stability of (\ref{eqn:Evolution-1}) is in \cite[Theorem 2.13]{TA94}:
\begin{quotation}
Let $\{\mathcal{T}_h\}_{h\downarrow 0}$ be regular triangulations
(see \refSec{Regular Triangulation}).
Then there is a number $c_0>0$ independent of $h$ such that,
\begin{eqnarray}
|u_h^n|^2\le
\left\{
\begin{array}{lr}
\frac{1}{\delta}\left\{
|u^0_h|^2+\tau \sum_{k=0}^{n-1}\|f^{k+\theta}\|^2_{V_h'}
\right\}&\theta\in [0,1/2)\\
|u^0_h|^2+\tau \sum_{k=0}^{n-1}\|f^{k+\theta}\|^2_{V_h'}&\theta\in [1/2,1]
\end{array}
\right.
\end{eqnarray}
if the following are satisfied:
\begin{enumerate}
  \item When $\theta\in [0,1/2)$, then we can take a time step $\tau$ in 
such a way that
\begin{eqnarray}
\tau <\frac{2(1-\delta)}{(1-2\theta)c_0^2}h^2
\end{eqnarray}
for arbitrary $\delta\in (0,1)$.
  \item When $1/2\le \theta\le 1$, we can take $\tau$ arbitrary.
\end{enumerate}
\end{quotation}

\begin{example}~
\bFF
@mesh Th=square(12,12);
@fespace Vh(Th,P1);
@fespace Ph(Th,P0);

Ph h = hTriangle; // mesh sizes for each triangle
@real tau = 0.1, theta=0.;
@func @real f(@real t) {
   @return x^2*(x-1)^2 + t*(-2 + 12*x - 11*x^2 - 2*x^3 + x^4);
}
@ofstream out("err02.csv"); // file to store calculations
out << "mesh size = "<<h[].max<<", time step = "<<tau<<@endl;
@for (@int n=0;n<5/tau;n++) \\
   out<<n*tau<<",";
out << @endl;
Vh u,v,oldU;
Vh f1, f0;
@problem aTau(u,v) =
  @int2d(Th)( u*v + theta*tau*(dx(u)*dx(v) + dy(u)*dy(v) + u*v))
  - @int2d(Th)(oldU*v - (1-theta)*tau*(dx(oldU)*dx(v)+dy(oldU)*dy(v)+oldU*v))
  - @int2d(Th)(tau*( theta*f1+(1-theta)*f0 )*v );

@while (theta <= 1.0) {
  @real t = 0, T=3; // from t=0 to T
  oldU = 0;     // u(x,y,0)=0
  out <<theta<<",";
  @for (@int n=0;n<T/tau;n++) {
      t = t+tau;
      f0 = f(n*tau); f1 = f((n+1)*tau);
      aTau;
      oldU = u;
      @plot(u);
      Vh uex = t*x^2*(1-x)^2; // exact sol.$=tx^2(1-x)^2$ 
      Vh err = u - uex; // $err=$FE-sol - exact 
      out<< abs(err[].max)/abs(uex[].max) <<","; // $\|err \|_{L^\infty(\Omega )}/\|u_{ex} \|_{L^\infty(\Omega )}$
  }
  out << endl;
  theta = theta + 0.1;
}
\eFF
\begin{figure}[htbp]
\begin{center}
\includegraphics[height=6cm]{err02} 
\end{center}
\caption{$\max_{x\in \Omega}|u_h^n(\theta)-u_{ex}(n\tau)|/\max_{x\in \Omega}|u_{ex}(n\tau)|$ at $n=0,1,\cdots,29$}
\label{fig:err02}
\end{figure}
We can see in Fig. \ref{fig:err02} that $u_h^n(\theta)$ become unstable at $\theta=0.4$, and figures are omitted in the case $\theta<0.4$.
\end{example}

\subsubsection{Convection}
The hyperbolic equation
\begin{eqnarray}
\label{eqn:conv}
\partial_t u-\vec{\alpha} \cdot \nabla u=f;~~
\textrm{for a vector-valued function }\vec{\alpha},~
\partial_t=\frac{\partial}{\partial t},
\end{eqnarray}
appear frequently in scientific problems, for example, 
Navier-Stokes equation, Convection-Diffusion equation, etc.

In the case of 1-dimensional space, we can easily find the general solution 
$(x,t)\mapsto u(x,t)=u^0(x-\alpha t)$ of the following equation, if $\alpha$ is constant,
\begin{eqnarray}
\label{eqn:conv0}
\partial_t u +\alpha\partial_x u=0,\qquad u(x,0)=u^0(x),
\end{eqnarray}
because $\partial_t u +\alpha\partial_x u=-\alpha\dot{u}^0+a\dot{u}^0=0$,
where $\dot{u}^0=du^0(x)/dx$.
Even if $\alpha$ is not constant construction, the principle is similar.
One begins the ordinary differentielle equation 
(with convention which $\alpha$
is prolonged by zero apart from $(0,L)\times (0,T)$): 
\[
\dot{X}(\tau )=-\alpha(X(\tau ),\tau ),~~~\tau \in (0,t)\quad X(t)=x
\]%
In this equation $\tau$ is the variable and $x,t$ is parameters, 
and we denote the solution by $X_{x,t}(\tau )$.
Then it is noticed that $(x,t)\rightarrow v(X(\tau ),\tau )$ in
$\tau=t$ satisfy the equation
\[
\partial _{t}v+\alpha\partial _{x}v=\partial _{t}X\dot{v}+a\partial _{x}X\dot{v}%
=0
\]%
and by the definition $\partial _{t}X=\dot{X}=-\alpha$ and 
$\partial_{x}X=\partial _{x}x$ in $\tau=t$, because 
if $\tau =t$ we have $X(\tau )=x$. 
The general solution of (\ref{eqn:conv0}) is thus the value of the boundary condition in $X_{x, t}(0)$,
it is has to say $u(x,t)=u^{0}(X_{x,t}(0))$ if $X_{x,t}(0)$ is on the 
$x$ axis, $u(x,t)=u^{0}(X_{x,t}(0))$ if $X_{x,t}(0)$ is on the axis of 
$t$.

In higher dimension $\Omega \subset R^{d},~d=2,3$, the equation of the
convection is written 
\[
\partial _{t}u+\vec{\alpha}\cdot \nabla u=0\hbox{ in }\Omega \times (0,T)
\]%
where  $\vec{a}(x,t)\in R^{d}$. 
\freefempp implements the Characteristic-Galerkin method for convection operators. Recall that the equation (\ref{eqn:conv})
can be discretized as
\[
\frac{Du}{Dt} = f\;\;\textrm{i.e. }\frac{du}{dt}\left( {X(t),t} \right) = f\left(X( t ),t \right)\textrm{  where  }\frac{dX}{dt}( t ) = \vec \alpha( {X(t),t})
\]
where $D$  is  the total derivative operator. 
So a good scheme is one step of backward
convection by the method of Characteristics-Galerkin
\begin{eqnarray}
\label{eqn:Charac}
\frac{1}{{\tau }}\left(u^{m + 1}(x) - u^m(X^m(x))\right) = f^m (x)
\end{eqnarray}
where $X^m (x)$ is an approximation of the solution at $t = m\tau $
of the ordinary differential equation
\[
\frac{d\vec{X}}{dt}(t) = \vec{\alpha}^m(\vec{X}(t)),\, \vec{X}((m + 1)\tau ) = x.
\]
where $\vec{\alpha}^m(x)=(\alpha_1(x,m\tau ),\alpha_2(x,m\tau ))$.
Because, by Taylor's expansion, we have
\begin{eqnarray}
\label{eqn:conv1}
u^m(\vec {X}(m\tau ))&=&
u^m(\vec{X}((m+1)\tau )) -
\tau \sum_{i=1}^d \frac{\partial u^m}{\partial x_i}(\vec{X}((m+1)\tau ))
\frac{\partial X_i}{\partial t}((m+1)\tau )
+o(\tau )\nonumber\\
&=&u^m(x)-\tau \vec{\alpha}^m(x)\cdot \nabla u^m(x)+o(\tau )
\end{eqnarray}
where $X_i(t)$ are the i-th component of $\vec{X}(t)$,
$u^m(x)=u(x,m\tau )$ 
and we used the chain rule and $x=\vec{X}((m+1)\tau )$.
From (\ref{eqn:conv1}), it follows that
\begin{eqnarray}
u^m(X^m(x))=u^m(x)-\tau \vec{\alpha}^m(x)\cdot \nabla u^m(x)+o(\tau ).
\end{eqnarray}
Also we apply Taylor's expansion for 
$t\mapsto u^m(x-\vec{\alpha}^m(x)t),\, 0\le t\le \tau $, then 
\[
u^m(x-\vec{\alpha}\tau )=u^m(x)-\tau \vec{\alpha}^m(x)\cdot \nabla u^m(x)+o(\tau ).
\]
Putting 
\[
\ttCC{@convect}\left( {\vec{\alpha},\tau ,u^m } \right) 
= u^m \left(x - \vec{\alpha}^m\tau  \right),
\]
we can get the approximation
\[
u^m \left( {X^m( x )} \right) \approx 
{\ttCC{@convect}}\left( {[a_1^m ,a_2^m],\tau ,u^m } \right)\;\;
\textrm{by }x = X((m + 1)\tau ).
\]

A classical convection problem is that of the ``rotating bell''
(quoted from \cite{Lucquin}[p.16]).
Let $\Omega$ be the unit disk centered at 0, 
with its center rotating with speed 
$\alpha_1 = y,\, \alpha_2 = -x$
We consider the problem (\ref{eqn:conv}) with $f=0$ and the initial condition
$u(x,0)=u^0(x)$, that is, from (\ref{eqn:Charac})
\begin{eqnarray*}
u^{m + 1}(x) = u^m(X^m(x))\approx \texttt{convect}(\vec{\alpha},\tau ,u^m).
\end{eqnarray*}
The exact solution is $u(x, t) = u(\vec{X}(t))$ 
where $\vec{X}$ equals $x$
rotated around the origin by an angle $\theta = -t$ (rotate in clockwise). 
So, if $u^0$ in a 3D perspective
looks like a bell, then $u$ will have exactly the same shape, but rotated by the
same amount.
The program consists in solving the equation until $T = 2\pi$, that is for a full
revolution and to compare the final solution with the initial one; they should
be equal.
\begin{example}[convect.edp]
\index{tutotial!convect.edp}
\bFF
@border C(t=0, 2*pi) { x=cos(t);  y=sin(t); }; // the unit circle
@mesh Th = @buildmesh(C(70));   // triangulates the disk
@fespace Vh(Th,P1);
Vh u0 = @exp(-10*((x-0.3)^2 +(y-0.3)^2));    // give $u^0$

@real dt = 0.17,t=0;       // time step
Vh a1 = -y, a2 = x;                   // rotation velocity
Vh u; // $u^{m+1}$
@for (@int m=0; m<2*pi/dt ; m++) {
    t += dt;
    u=@convect([a1,a2],dt,u0);  // $u^{m+1}=u^m(X^m(x))$
    u0=u;                      // m++
    @plot(u,cmm="convection: t="+t + ", min=" + u[].min + ", max=" +  u[].max,wait=0);
};
\eFF
\end{example}
\begin{note}
The scheme \texttt{convect} is unconditionally stable, then
the bell become lower and lower (the maximum of $u^{37}$ is $0.406$ as shown in Fig. \ref{BellLast}).
\twoplot[height=5cm]{BellInit}{BellLast}{$u^0=e^{-10((x-0.3)^2 +(y-0.3)^2)}$}{The bell at $t=6.29$}
\end{note}


\subsubsection{Two-dimensional Black-Scholes equation}
In mathematical finance, an option on two assets is modeled by a Black-Scholes equations in two space variables, (see for example Wilmott's book : a student introduction to mathematical finance, Cambridge University Press). 
\begin{eqnarray}
\label{eqn:BS-1-1}
 &&\partial _t u + \frac{{\left( {\sigma _1 x } \right)^2 }}{2}\frac{{\partial ^2 u}}{{\partial x^2 }} + \frac{{\left( {\sigma _2 y } \right)^2 }}{2}\frac{{\partial ^2 u}}{{\partial y^2 }} \\ 
 &&{\rm{      }} + \rho x y \frac{{\partial ^2 u}}{{\partial x \partial y }} + rS_1 \frac{{\partial u}}{{\partial x }} + rS_2 \frac{{\partial u}}{{\partial y }} - rP = 0 \nonumber 
\end{eqnarray}
which is to be integrated in $\left( {0,T} \right) \times \R^ +   \times \R^ +$
subject to, in the case of a put
\begin{eqnarray}
\label{eqn:BS-1-2}
u\left( {x , y ,T} \right) = \left( {K - \max \left( {x ,y } \right)} \right)^ +  .
\end{eqnarray}
Boundary conditions for this problem may not be so easy to device.
As in the one dimensional case the PDE contains boundary conditions on the axis $x_1 = 0$ and on the axis $x_2 = 0$, namely two one dimensional Black-Scholes equations driven respectively by the data $u\left( {0, + \infty ,T} \right)$
and $u\left( { + \infty ,0,T} \right)$.
These will be automatically accounted for because they are embedded in the PDE. So if we do nothing in the variational form (i.e. if we take a Neuman boundary condition at these two axis in the strong form) there will be no disturbance to these.
At infinity in one of the variable, as in 1D, it makes sense to match the final condition:
\begin{eqnarray}
\label{eqn:BS-1-3}
u\left( {x ,y ,t} \right) \approx \left( {K - \max \left( {x ,y } \right)} \right)^ +  e^{r\left( {T - t} \right)} {\rm{    when  }}\left| {\rm{x}} \right| \to \infty 
\end{eqnarray}
For an American put we will also have the constraint
\begin{eqnarray}
\label{eqn:BS-1-4}
u\left( {x ,y ,t} \right) \ge \left( {K - \max \left( {x ,y } \right)} \right)^ +  e^{r\left( {T - t} \right)} .
\end{eqnarray}
We take
\begin{eqnarray}
\label{eqn:BS-1-5}
\sigma _1  = 0.3,\;\;\sigma _2  = 0.3,\;\;\rho  = 0.3,\;\;r = 0.05,\;\;K = 40,\;\;T = 0.5
\end{eqnarray}
An implicit Euler scheme with projection is used and a mesh adaptation is done every 10 time steps. The first order terms are treated by the Characteristic Galerkin method, which, roughly, approximates
\begin{eqnarray}
\label{eqn:BS-1-6}
\frac{{\partial u}}{{\partial t}} + a_1 \frac{{\partial u}}{{\partial x}} + a_2 \frac{{\partial u}}{{\partial y}} \approx \frac{1}{{\tau }}\left( {u^{n + 1} \left( x \right) - u^n \left( {x - \vec \alpha\tau } \right)} \right)
\end{eqnarray}
\begin{example}~
[blakschol.edp]\index{tutorial!blakschol.edp}
\bFF
// verbosity=1; 
int s=10; // y-scale
int m=30;
int L=80;
int LL=80;
@border aa(t=0,L){x=t;y=0;};
@border bb(t=0,LL){x=L;y=t;};
@border cc(t=L,0){x=t ;y=LL;};
@border dd(t=LL,0){x = 0; y = t;};

@mesh th = buildmesh(aa(m)+bb(m)+cc(m)+dd(m));
@fespace Vh(th,P1);

@real sigmax=0.3;
@real sigmay=0.3;
@real rho=0.3;
@real r=0.05;
@real K=40;
@real dt=0.01;

@real eps=0.3;

@func f = max(K-max(x,y),0.);

Vh u=f,v,w;

@func beta = 1;//(w<=f-eps)*eps + (w>=f) + (w<f)*(w>f-eps)*(eps+(w-f+eps)/eps)*(1-eps);

@plot(u,wait=1);

 th = adaptmesh(th,u,abserror=1,nbjacoby=2,
        err=0.004, nbvx=5000, omega=1.8,ratio=1.8, nbsmooth=3,
            splitpbedge=1, maxsubdiv=5,rescaling=1 ); 
 u=u;

Vh xveloc = -x*r+x*sigmax^2+x*rho*sigmax*sigmay/2;
Vh yveloc = -y*r+y*sigmay^2+y*rho*sigmax*sigmay/2;

@int j=0;
@int n;
@problem eq1(u,v,init=j,@solver=LU) = @int2d(th)(
                          u*v*(r+1/dt/beta) 
                        + @dx(u)*@dx(v)*(x*sigmax)^2/2. 
                        + @dy(u)*@dy(v)*(y*sigmay)^2/2.
      + @dy(u)*@dx(v)*rho*sigmax*sigmay*x*y/2.
                  + @dx(u)*@dy(v)*rho*sigmax*sigmay*x*y/2.   )
            + @int2d(th)( -v*convect([xveloc,yveloc],dt,w)/dt/beta) 
                  + @on(bb,cc,u=f)//*exp(-r*t);
;
int ww=1;
@for ( n=0; n*dt <= 1.0; n++) 
{
  @cout <<" iteration " << n   <<  " j=" << j << @endl; 
  w=u; 
  eq1; 
  v = @max(u-f,0.);
  plot(v,wait=ww);
  u = @max(u,f);
  ww=0;
 
  @if(j>10)  { cout << " adaptmesh " << endl;
    th = adaptmesh(th,u,verbosity=1,abserror=1,nbjacoby=2,
      err=0.001, nbvx=5000, omega=1.8, ratio=1.8, nbsmooth=3,
            splitpbedge=1, maxsubdiv=5,rescaling=1) ; 
        j=-1;
     xveloc = -x*r+x*sigmax^2+x*rho*sigmax*sigmay/2;
     yveloc = -y*r+y*sigmay^2+y*rho*sigmax*sigmay/2;
     u=u;
     ww=1;
    };
  j=j+1; 
  @cout << " j = " <<  j << endl;
};
v = @max(u-f,0.);
@plot(v,wait=1,value=1);
@plot(u,wait=1,value=1);
\eFF
\end{example}

\subsection{Navier-Stokes Equation}

\subsubsection{Stokes and Navier-Stokes}

The Stokes equations are: for a given $\vec{f}\in L^2(\Omega)^2$,
\index{stokes}
\Blue{
\begin{equation} \label{eqn:Stokes}
    \left.\begin{array}{cl}
 -\Delta \vec{u}+\nabla p & =\vec{f} \\
 \nabla\cdot \vec{u} &=0
 \end{array}\right\}\quad \hbox{ in }\Omega
\end{equation}}
where $\vec{u}=(u_1,u_2)$ is the velocity vector and $p$ the pressure.
For simplicity, let us choose Dirichlet boundary conditions
on the velocity,  $\vec{u}=\vec{u}_{\Gamma}$ on $\Gamma$.

In Teman[Theorem 2.2], there ia a weak form of (\ref{eqn:Stokes}):
Find $\vec{v}=(v_1,v_2)\in \vec{V}(\Omega)$
\[
\vec{V}(\Omega)=\{\vec{w}\in H^1_0(\Omega)^2|\; \textrm{div}\vec{w}=0\}
\]
which satisfy 
\[
\sum_{i=1}^2\int_{\Omega}\nabla u_i\cdot \nabla v_i=\int_{\Omega}\vec{f}\cdot \vec{w}
\quad \textrm{for all }v\in V
\]
Here it is used the existence 
$p\in H^1(\Omega)$ such that $\vec{u}=\nabla p$, if
\[
\int_{\Omega}\vec{u}\cdot \vec{v}=0\quad \textrm{for all }\vec{v}\in 
V
\]
\medskip

Another weak form is derived as follows: We put 
\begin{eqnarray*}
\vec{V}=H^1_0(\Omega)^2;\quad 
W=\left\{q\in L^2(\Omega)\left|\; \int_{\Omega}q=0\right.\right\}
\end{eqnarray*}
By multiplying the first equation in (\ref{eqn:Stokes}) with $v\in V$ and the
second with $q\in W$, subsequent integration over $\Omega$, and an 
application of Green's formula, we have
\begin{eqnarray*}
\int_{\Omega}\nabla\vec{u}\cdot \nabla\vec{v}-\int_{\Omega}\textrm{div}\vec{v}\, p
&=&\int_{\Omega}\vec{f}\cdot\vec{v}\\
\int_{\Omega}\textrm{div}\vec{u}\, q&=&0
\end{eqnarray*}
This yields the weak form of (\ref{eqn:Stokes}): 
Find $(\vec{u},p)\in \vec{V}\times W$ such that
\begin{eqnarray}
\label{eqn:wStokes-1}
a(\vec{u},\vec{v})+b(\vec{v},p)&=&(\vec{f},\vec{v})\\
\label{eqn:wStokes-2}
b(\vec{u},q)&=&0
\end{eqnarray}
for all $(\vec{v},q)\in V\times W$, where
\begin{eqnarray}
\label{eqn:Stokes-a}
a(\vec{u},\vec{v})&=&\int_{\Omega}\nabla \vec{u}\cdot \nabla\vec{v}
=\sum_{i=1}^2\int_{\Omega}\nabla u_i\cdot \nabla v_i\\
\label{eqn:Stokes-b}
b(\vec{u},q)&=&-\int_{\Omega}\textrm{div}\vec{u}\, q
\end{eqnarray}

Now, we consider finite element spaces $\vec{V}_h\subset \vec{V}$ and $W_h\subset W$,
and we assume the following basis functions
\begin{eqnarray*}
&&\vec{V}_h=V_h\times V_h,\quad 
V_h=\{v_h|\; v_h=v_1\phi_1+\cdots +v_{M_V}\phi_{M_V}\},\\
&&W_h=\{q_h|\; q_h=q_1\varphi_1+\cdots +q_{M_W}\varphi_{M_W}\}
\end{eqnarray*}
The discrete weak form is:
Find $(\vec{u}_{h},p_{h}) \in \vec{V}_{h} \times W_{h}$ such that 
\Blue{
\begin{equation} \label{eqn:vfStokes}
    \begin{array}{cll}
   a(\vec{u}_h,\vec{v}_h)+b(\vec{v}_h,p)  &= (\vec{f},\vec{v}_h) ,
      &\forall \vec{v}_{h} \in \vec{V}_{h} \\
    b(\vec{u}_h,q_h)&= 0,
     &\forall q_{h} \in W_{h}
    \end{array}
\end{equation}}
\begin{note}
Assume that:
\begin{enumerate}
  \item There is a constant $\alpha_h>0$ such that
  \[
  a(\vec{v}_h,\vec{v}_h)\ge \alpha\| \vec{v}_h\|_{1,\Omega}^2\quad \textrm{for all }\vec{v}_h\in Z_h
  \]
  where 
  \[
  Z_h=\{\vec{v}_h\in \vec{V}_h|\; b(\vec{w}_h,q_h)=0\quad \textrm{for all }q_h\in W_h\}
  \]
  \item There is a constant $\beta_h>0$ such that
  \[
  \sup_{\vec{v}_h\in \vec{V}_h}\frac{b(\vec{v}_h,q_h)}{\| \vec{v}_h\|_{1,\Omega}}
  \ge \beta_h\| q_h\|_{0,\Omega}\quad \textrm{for all }q_h\in W_h
  \]
\end{enumerate}
  Then we have an unique solution $(\vec{u}_h,p_h)$ of (\ref{eqn:vfStokes}) 
  satisfying
  \[
  \| \vec{u}-\vec{u}_h\|_{1,\Omega}+\| p-p_h\|_{0,\Omega}
  \le C\left(
  \inf_{\vec{v}_h\in \vec{V}_h}\| u-v_h\|_{1,\Omega}
  +\inf_{q_h\in W_h}\| p-q_h\|_{0,\Omega}\right)
  \]
  with a constant $C>0$ (see e.g. \cite[Theorem 10.4]{RT93}).
\end{note}
Let us denote that
\begin{eqnarray}
A&=&(A_{ij}),\, A_{ij}=\int_{\Omega}\nabla \phi_j\cdot \nabla \phi_i\qquad
i,j=1,\cdots,M_{\vec{V}}\\
\vec{B}&=&(Bx_{ij},By_{ij}),\, 
Bx_{ij}=-\int_{\Omega}\partial \phi_j/\partial x\, \varphi_i\qquad
By_{ij}=-\int_{\Omega}\partial \phi_j/\partial y\, \varphi_i\nonumber\\
&&\qquad i=1,\cdots,M_W;j=1,\cdots,M_V\nonumber
\end{eqnarray}
then (\ref{eqn:vfStokes}) is written by
\begin{eqnarray}
\left(
\begin{array}{cc}
\vec{A}&\vec{\vec{B}}^*\\
\vec{B}&0
\end{array}
\right)
\left(
\begin{array}{cc}
\vec{U}_h\\
\{p_h\}
\end{array}
\right)
=
\left(
\begin{array}{cc}
\vec{F}_h\\
0
\end{array}
\right)
\end{eqnarray}
where 
\begin{eqnarray*}
&&\vec{A}=\left(
\begin{array}{cc}
A&0\\
0&A
\end{array}
\right)
\qquad
\vec{B}^*=\left\{
\begin{array}{c}
Bx^T\\
By^T
\end{array}
\right\}
\qquad
\vec{U}_h=\left\{
\begin{array}{c}
\{u_{1,h}\}\\
\{u_{2,h}\}
\end{array}
\right\}
\qquad
\vec{F}_h=\left\{
\begin{array}{c}
\{\textstyle{\int_{\Omega}f_1\phi_i}\}\\
\{\textstyle{\int_{\Omega}f_2\phi_i}\}
\end{array}
\right\}
\end{eqnarray*}

\textbf{Penalty method:} This method consists of replacing (\ref{eqn:vfStokes}) by a more regular problem: Find 
$(\vec{v}_h^{\epsilon},p_h^{\epsilon})\in \vec{V}_h\times \tilde{W}_{h}$ satisfying
\Blue{
\begin{equation} \label{eqn:PvfStokes}
    \begin{array}{cll}
   a(\vec{u}_h^\epsilon,\vec{v}_h)+b(\vec{v}_h,p_h^{\epsilon})  &= (\vec{f},\vec{v}_h) ,
      &\forall \vec{v}_{h} \in \vec{V}_{h} \\
    b(\vec{u}_h^{\epsilon},q_h)-\epsilon(p_h^{\epsilon},q_h)&= 0,
     &\forall q_{h} \in \tilde{W}_{h}
    \end{array}
\end{equation}}
where $\tilde{W}_h\subset L^2(\Omega)$. Formally, we have
\[
\textrm{div}\vec{u}_h^{\epsilon}=\epsilon p_h^{\epsilon}
\]
and the corresponding algebraic problem 
\begin{eqnarray*}
\left(
\begin{array}{cc}
\vec{A}&B^*\\
B&-\epsilon I
\end{array}
\right)
\left(
\begin{array}{cc}
\vec{U}_h^{\epsilon}\\
\{p_h^{\epsilon}\}
\end{array}
\right)
=
\left(
\begin{array}{cc}
\vec{F}_h\\
0
\end{array}
\right)
\end{eqnarray*}
\begin{note}
We can eliminate $p_h^\epsilon=(1/\epsilon)BU_h^{\epsilon}$ to obtain
\begin{eqnarray}
\label{eqn:StiffPvfStokes}
(A+(1/\epsilon)B^*B)\vec{U}_h^{\epsilon}=\vec{F}_h^{\epsilon}
\end{eqnarray}
Since the matrix $A+(1/\epsilon)B^*B$ is symmetric, positive-definite, and sparse, (\ref{eqn:StiffPvfStokes}) can be solved by known technique.
There is a constant $C>0$ independent of $\epsilon$ such that
\[
\|\vec{u}_h-\vec{u}_h^\epsilon\|_{1,\Omega}+
\|p_h-p_h^{\epsilon}\|_{0,\Omega}\le C\epsilon
\]
(see e.g. \cite[17.2]{RT93})
\end{note}

\begin{example}[Cavity.edp]

The driven cavity flow problem is solved first at zero Reynolds number
(Stokes flow) and then at Reynolds 100.  \index{fluid}The
velocity pressure formulation is used first and then the calculation
is repeated with the stream function vorticity formulation.

We solve the driven cavity problem by the penalty method (\ref{eqn:PvfStokes}) \index{Stokes} where
 $\vec{u}_{\Gamma}\cdot \vec{n}=0$ and $\vec{u}_{\Gamma}\cdot \vec{s}
=1$ on the top boundary and zero elsewhere ( $\vec{n}$ is the unit normal to $\Gamma$, and $\vec{s}$ the unit tangent to $\Gamma$).
\\
The mesh is constructed by
\bFF
@mesh Th=@square(8,8);
\eFF

We use a classical Taylor-Hood element technic to solve the problem:
\\\\
The velocity is approximated with the $P_{2}$ FE ( $X_{h}$ space), and the
the pressure is approximated with the $P_{1}$ FE ( $M_{h}$ space),
\\\\
where
\Blue{
$$  X_{h} = \left\{ \vec{v} \in H^{1}(]0,1[^2) \left|\; \forall K \in \mathcal{T}_{h}
\quad v_{|K} \in
P_{2} \right.\right\}$$} and
\Blue{$$  M_{h} = \left\{ v \in H^{1}(]0,1[^2) \left|\; \forall K \in \mathcal{T}_{h}
\quad v_{|K} \in
P_{1} \right.\right\}$$}

The FE spaces and functions  are constructed by

\bFF
@fespace Xh(Th,@P2); //  definition of the velocity component space
@fespace Mh(Th,@P1);  //  definition of the pressure space
Xh u2,v2;
Xh u1,v1;
Xh p,q;
\eFF

The Stokes operator is implemented as a system-solve for the velocity
$(u1,u2)$ and the pressure $p$.  The test function  for the velocity is $(v1,v2)$
and $q$ for the pressure, so the variational form (\ref{eqn:vfStokes}) in freefem
language is:
\bFF
@solve Stokes (u1,u2,p,v1,v2,q,solver=Crout) =
    @int2d(Th)( ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +  dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            - p*q*(0.000001)
            - p*dx(v1) - p*dy(v2)
            - dx(u1)*q - dy(u2)*q
           )
  + @on(3,u1=1,u2=0)
  + @on(1,2,4,u1=0,u2=0); // see \refSec{Square} for labels 1,2,3,4
\eFF
Each unknown has its own boundary conditions.
\\\\

If the \index{streamlines}streamlines are required, they can be
computed by finding $\psi$ such that rot$\psi=u$ or better,
\Blue{$$-\Delta\psi=\nabla\times u$$}
\bFF
Xh psi,phi;

@solve streamlines(psi,phi) =
      @int2d(Th)( dx(psi)*dx(phi) + dy(psi)*dy(phi))
   +  @int2d(Th)( -phi*(dy(u1)-dx(u2)))
   +  @on(1,2,3,4,psi=0);
\eFF

\bigskip

Now the Navier-Stokes equations are solved
\eq{
    {\partial {u}\over\partial t} +u\cdot\nabla u-\nu \Delta u+\nabla p=0,~~~ \nabla\cdot u=0
}
with the same boundary conditions and with initial conditions $u=0$.

This is implemented by using the convection operator \texttt{convect} for the term
${\partial u\over\partial t} +u\cdot\nabla u$, giving a discretization in time
\Blue{\index{Navier-Stokes}
\begin{equation}
    \label{eq Navier Stokes carac}
\begin{array}{cl}
\frac{1}{\tau } (u^{n+1}-u^n\circ X^n) -\nu\Delta u^{n+1} + \nabla p^{n+1} &=0,\\
 \nabla\cdot u^{n+1} &= 0
 \end{array}
\end{equation}
}
The term $u^n\circ X^n(x)\approx u^n(x-u^n(x)\tau )$ will be
computed by the operator ``convect" \index{convect} , so we obtain
\bFF
int i=0;
@real  nu=1./100.;
@real dt=0.1;
@real alpha=1/dt;

Xh up1,up2;

@problem  NS (u1,u2,p,v1,v2,q,solver=Crout,init=i) =
    @int2d(Th)(
             alpha*( u1*v1 + u2*v2)
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +  dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            - p*q*(0.000001)
            - p*dx(v1) - p*dy(v2)
            - dx(u1)*q - dy(u2)*q
           )
  + @int2d(Th) ( -alpha*
       convect([up1,up2],-dt,up1)*v1 -alpha*convect([up1,up2],-dt,up2)*v2 )
  + @on(3,u1=1,u2=0)
  + @on(1,2,4,u1=0,u2=0)
;

@for (i=0;i<=10;i++)
 {
   up1=u1;
   up2=u2;
   NS;
   @if ( !(i % 10))  // plot every 10 iteration
    @plot(coef=0.2,cmm=" [u1,u2] and p  ",p,[u1,u2]);
 } ;
\eFF
Notice that the stiffness matrices are \index{Reusable matrices} 
reused (keyword
\texttt{init=i})
\end{example}

\subsubsection{\setS{Uzawa} Conjugate Gradient}
We solve Stokes problem without penalty.
The classical iterative method of Uzawa is described by the algorithm
(see e.g.\cite[17.3]{RT93}):
\begin{description}
  \item[Initialize:] Let $p_h^0$ be an arbitrary chosen element of 
  $L^2(\Omega)$.
  \item[Calculate $\vec{u}_h$:] Once $p_h^n$ is known, $\vec{v}_h^n$ is the solution of
  \[
  \vec{u}_h^n = A^{-1}(\vec{f}_h-\vec{B}^*p_h^n)
  \]
  \item[Advance $p_h$:] Let $p_h^{n+1}$ be defined by
  \[
  p_h^{n+1}=p_h^n+\rho_n\vec{B}\vec{u}_h^n
  \]
\end{description}
There is a constant $\alpha>0$ such that $\alpha\le \rho_n\le 2$ for each $n$,
then $\vec{u}_h^n$ converges to the solution $\vec{u}_h$, and then 
$B\vec{v}_h^n\to 0$ as $n\to \infty$ from the \emph{Advance $p_h$}.
This method in general converges quite slowly.

First we define mesh, and the Taylor-Hood \index{Taylor-Hood}  approximation.
So $X_{h}$  is the velocity space, and $M_{h}$ is the pressure space.
\begin{example}[StokesUzawa.edp]~
\index{tutorial!StokesUzawa.edp}
\bFF
@mesh Th=@square(10,10);
@fespace Xh(Th,@P2),Mh(Th,@P1);
Xh u1,u2,v1,v2;
Mh p,q,ppp;  //  ppp is a working pressure
\eFF

\bFF
@varf bx(u1,q) = @int2d(Th)( -(dx(u1)*q));
@varf by(u1,q) = @int2d(Th)( -(dy(u1)*q));
@varf a(u1,u2)= @int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) )
                    +  on(3,u1=1)  +  @on(1,2,4,u1=0) ;
//  remark:  put the \ttCC{@on(3,u1=1)} before  \ttCC{@on(1,2,4,u1=0)} 
//  because we want zero on intersection %\index{on!intersection}
 
@matrix A= a(Xh,Xh,solver=CG);
@matrix Bx= bx(Xh,Mh);  // $\vec{B}=(Bx\quad By)$
@matrix By= by(Xh,Mh);

Xh bc1; bc1[] = a(0,Xh);  //  boundary condition contribution  on u1
Xh bc2; bc2   = O ;       //  no boundary condition contribution on u2
Xh b;
\eFF

$p_h^n\to \vec{B}A^{-1}(-\vec{B}^*p_h^n)=-\textrm{div}\vec{u}_h$ 
is realized as 
the function \emph{\texttt{divup}}.
\bFF
@func @real[@int] divup(@real[@int] @& pp)
{
   //  compute u1(pp)
   b[]  = Bx'*pp; b[] *=-1; b[] += bc1[] ;    u1[] = A^-1*b[];
   //  compute u2(pp)
   b[]  = By'*pp; b[] *=-1; b[] += bc2[] ;    u2[] = A^-1*b[];
   //  $\vec{u}^n=A^{-1}(Bx^Tp^n\quad By^Tp^n)^T$ \hfilll
   ppp[] =   Bx*u1[];   // $  ppp= Bx u_{1} $ 
   ppp[] +=  By*u2[];   // $   \quad   +  By u_{2} $ 
   @return ppp[] ;
};
\eFF

 Call now the conjugate gradient algorithm:

\bFF
p=0;q=0; // $p_h^0 = 0$
@LinearCG(divup,p[],eps=1.e-6,nbiter=50); // $p_h^{n+1}=p_h^n+\vec{B}\vec{u}_h^n$
// if $n> 50$ or $|p_h^{n+1}-p_h^n|\le 10^{-6}$, then the loop end. \hfilll
divup(p[]); // compute the final solution

@plot([u1,u2],p,wait=1,value=true,coef=0.1);
\eFF
\end{example}

\subsubsection{NSUzawaCahouetChabart.edp}

 In this example we solve the Navier-Stokes \index{Navier-Stokes} equation,
 in the driven-cavity,
 with the Uzawa  algorithm preconditioned by the Cahouet-Chabart method.

 The idea of the preconditionner is that in a periodic domain, all
 differential operators commute and  the  Uzawa algorithm comes to solving the
 linear operator  $ \nabla. ( (\alpha Id + \nu \Delta)^{-1} \nabla$,
 where $ Id $ is the identity operator.
 So  the preconditioner suggested is $ \alpha \Delta^{-1} + \nu Id$.
\\\\
To implement this, we reuse the previous example, by including \index{include} a file.
Then we define the time step $ \Delta t$, viscosity, and new variational form and matrix.

\begin{example}[NSUzawaCahouetChabart.edp]~
\index{tutorial!NSUzawaCahouetChabart.edp}
\bFF
@include "StokesUzawa.edp" // include the Stokes part
@real dt=0.05, alpha=1/dt;  // $ \Delta t$

@cout << " alpha = " << alpha;
@real xnu=1./400; // viscosity $ \nu = {\hbox{Reynolds number}}^{-1} $

//  the new variational form with mass term \index{varf}
@varf at(u1,u2)= @int2d(Th)( xnu*dx(u1)*dx(u2)
                        + xnu*dy(u1)*dy(u2) + u1*u2*alpha  )
                        +  @on(1,2,4,u1=0)  + @on(3,u1=1) ;

A = at(Xh,Xh,solver=CG);  //  change the matrix \index{matrix!=}\index{matrix!solver=}

//  set the 2 convect variational form \index{qforder=} \index{convect}
@varf  vfconv1(uu,vv)  = @int2d(Th,qforder=5) (@convect([u1,u2],-dt,u1)*vv*alpha);
@varf  vfconv2(v2,v1)  = @int2d(Th,qforder=5) (@convect([u1,u2],-dt,u2)*v1*alpha);

@int idt;       // index of of time set
@real temps=0;  // current time

Mh pprec,prhs;
@varf vfMass(p,q) = int2d(Th)(p*q);
@matrix MassMh=vfMass(Mh,Mh,solver=CG);

@varf vfLap(p,q)  = int2d(Th)(dx(pprec)*dx(q)+dy(pprec)*dy(q) + pprec*q*1e-10);
@matrix LapMh= vfLap(Mh,Mh,solver=Cholesky);
\eFF

 The function to define the preconditioner

\bFF
@func real[int]  CahouetChabart(real[int] & xx)
{  //  xx = $ \int (div u) w_i$
   //   $ \alpha LapMh ^{-1}  + \nu MassMh^{-1} $ 
   pprec[]= LapMh^-1* xx; 
   prhs[] =  MassMh^-1*xx;
   pprec[] = alpha*pprec[]+xnu* prhs[];
   @return pprec[];
};
\eFF

The loop in time.
Warning with the stop test of the conjugate gradient, because
we start from the previous solution and the end the previous solution
is close to the final solution, don't take a relative  stop test to
the first residual, take an absolue stop test ( negative here)
\index{stop test!absolue}
\bFF
for (idt = 1; idt < 50; idt++)
 {
   temps += dt;
   cout << " --------- temps " << temps << " \n ";
   b1[] =  vfconv1(0,Xh);
   b2[] =  vfconv2(0,Xh);
   cout << "  min b1 b2  " << b1[].min << " " << b2[].min << endl;
   cout << "  max b1 b2  " << b1[].max << " " << b2[].max << endl;
   // call Conjugued Gradient with preconditioner '
   //  warning eps < 0 => absolue stop test \index{precon=}
   LinearCG(divup,p[],eps=-1.e-6,nbiter=50,precon=CahouetChabart);
   divup(p[]);   //  computed the velocity

   plot([u1,u2],p,wait=!(idt%10),value= 1,coef=0.1);
 }
\eFF
\end{example}


\subsection{Domain decomposition}
We present, three classique examples, of domain decomposition
technique:
first, Schwarz algorithm with overlapping, second 
Schwarz algorithm without  overlapping (also call Shur complement), and
last we show to use the conjugate gradient 
to solve the boundary problem of the Shur complement.
 
\subsubsection{Schwarz Overlap Scheme}
\label{schwarz-overlap}
To solve 
\eq{ -\Delta u =f,\; \hin\Omega=\Omega_1\cup\Omega_2\quad u|_\Gamma=0}
the Schwarz algorithm  runs like this
\Blue{
\begin{eqnarray*}
   -\Delta u^{n+1}_1&=&f\hin\Omega_1\quad
    u^{n+1}_1|_{\Gamma_1}=u^n_2\\
    -\Delta u^{n+1}_2&=&f\hin\Omega_2\quad
    u^{n+1}_2|_{\Gamma_2}=u^n_1
\end{eqnarray*}}
where $\Gamma_i$ is the boundary of $\Omega_i$ and on the
condition that $\Omega_1\cap\Omega_2\neq\emptyset$ and that $u_i$
are zero at iteration 1.
\\\\
Here we take $\Omega_1$ to be a quadrangle, $\Omega_2$ a disk and
we apply the algorithm starting from zero.
\begin{figure}[hbt]
\HLINE{\hss
\includegraphics[width=6cm]{schwarz-th} \hss}
\caption{ The 2 overlapping mesh \texttt{TH} and \texttt{th}  }
\end{figure}

\begin{example}[Schwarz-overlap.edp]~
\index{tutorial!Schwarz-overlap.edp}
 \bFF
@int inside = 2;  //  inside boundary
@int outside = 1; //  outside boundary
@border a(t=1,2){x=t;y=0;label=outside;};
@border b(t=0,1){x=2;y=t;label=outside;};
@border c(t=2,0){x=t ;y=1;label=outside;};
@border d(t=1,0){x = 1-t; y = t;label=inside;};
@border e(t=0, pi/2){ x= cos(t); y = sin(t);label=inside;};
@border e1(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=outside;};
@int n=4;
@mesh th = @buildmesh( a(5*n) + b(5*n) + c(10*n) + d(5*n));
@mesh TH = @buildmesh( e(5*n) + e1(25*n) );
@plot(th,TH,wait=1);  //  to see the 2 meshes
\eFF

The space  and problem definition is :   
\bFF
@fespace vh(th,@P1);
@fespace VH(TH,@P1);
vh u=0,v; VH U,V;
@int i=0;

@problem PB(U,V,init=i,solver=Cholesky) = 
    @int2d(TH)( dx(U)*dx(V)+dy(U)*dy(V) )
  + @int2d(TH)( -V) + on(inside,U = u)  + @on(outside,U= 0 ) ;
@problem pb(u,v,init=i,solver=Cholesky) =
    @int2d(th)( dx(u)*dx(v)+dy(u)*dy(v) )
  + @int2d(th)( -v) + on(inside ,u = U) + @on(outside,u = 0 ) ;
\eFF
 The  calculation loop: 
\bFF
@for ( i=0 ;i< 10; i++)
{
   PB;
   pb;
   @plot(U,u,wait=true);
};
\eFF
\end{example}

\begin{figure}[hbt]
\HLINE{\hss
\includegraphics[width=6cm]{schwarz-u0} 
\hss
\includegraphics[width=6cm]{schwarz-u} }
\caption{  Isovalues of the solution at  iteration 0  and iteration 9}
\end{figure}



\subsubsection{Schwarz non Overlap Scheme}

To solve\index{domain decomposition}\index{shurr}
\eq{ -\Delta u =f \hin\Omega=\Omega_1\cup\Omega_2\quad u|_\Gamma=0,}
the Schwarz algorithm for domain decomposition without overlapping  runs like this

\begin{figure}[hbt]
\HLINE{\hss
\includegraphics[width=6cm]{schwarz-no-th} \hss}
\caption{ The two none overlapping mesh \texttt{TH} and \texttt{th}  }
\end{figure}

Let introduce  $\Gamma_i$ is  common the boundary of $\Omega_1$ and
$\Omega_2$ and    $\Gamma_e^i= \partial \Omega_i \setminus \Gamma_i$.

The probem  find  $\lambda$ such that $ (u_1|_{\Gamma_i}=u_2|_{\Gamma_i}) $
where  $u_i$ is solution of the following Laplace problem:
\eq{
    -\Delta u_i=f\hin\Omega_i\quad
    u_i|_{\Gamma_i}=\lambda \quad
    u_i|_{\Gamma_e^i} = 0 
 }

To solve this problem we just make a loop
with upgrading$\lambda$ with
$$\lambda = \lambda  \frac{(u_1-u_2)}{2}$$
where the sign $+$ or $-$ of $$ is choose to have convergence.

\begin{example}[Schwarz-no-overlap.edp]~
\index{tutorial!Schwarz-no-overlap.edp}
\bFF
// schwarz1 without overlapping
@int inside = 2;
@int outside = 1;
@border a(t=1,2){x=t;y=0;label=outside;};
@border b(t=0,1){x=2;y=t;label=outside;};
@border c(t=2,0){x=t ;y=1;label=outside;};
@border d(t=1,0){x = 1-t; y = t;label=inside;};
@border e(t=0, 1){ x= 1-t; y = t;label=inside;};
@border e1(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=outside;}; 
@int n=4;
@mesh th = buildmesh( a(5*n) + b(5*n) + c(10*n) + d(5*n));
@mesh TH = buildmesh ( e(5*n) + e1(25*n) );
@plot(th,TH,wait=1,ps="schwarz-no-u.eps");
@fespace vh(th,P1);
@fespace VH(TH,P1);
vh u=0,v; VH U,V;
vh lambda=0;
@int i=0;

@problem PB(U,V,init=i,solver=Cholesky) = 
    @int2d(TH)( dx(U)*dx(V)+dy(U)*dy(V) )
  + @int2d(TH)( -V) 
  + @int1d(TH,inside)(-lambda*V) +    on(outside,U= 0 ) ;
@problem pb(u,v,init=i,solver=Cholesky) = 
    @int2d(th)( dx(u)*dx(v)+dy(u)*dy(v) )
  + @int2d(th)( -v) 
  + @int1d(th,inside)(+lambda*v) +    on(outside,u = 0 ) ;


@for ( i=0 ;i< 10; i++) 
{   
   PB; 
   pb;
   lambda = lambda - (u-U)/2;
   @plot(U,u,wait=true);
};

@plot(U,u,ps="schwarz-no-u.eps");

\eFF
\end{example}

\begin{figure}[hbt]
\HLINE{\hss
\includegraphics[width=6cm]{schwarz-no-u0} 
\hss
\includegraphics[width=6cm]{schwarz-no-u} }
\caption{  Isovalues of the solution at  iteration 0  and iteration 9 without overlapping }
\end{figure}

\subsubsection{Schwarz-gc.edp}
To solve\index{domain decomposition}\index{shurr}
\eq{ -\Delta u =f \hin\Omega=\Omega_1\cup\Omega_2\quad u|_\Gamma=0,}
the Schwarz algorithm for domain decomposition without overlapping  runs like this

Let introduce  $\Gamma_i$ is  common the boundary of $\Omega_1$ and
$\Omega_2$ and    $\Gamma_e^i= \partial \Omega_i \setminus  \Gamma_i$.

The probem  find  $\lambda$ such that $ (u_1|_{\Gamma_i}=u_2|_{\Gamma_i}) $
where  $u_i$ is solution of the following Laplace problem:
\eq{
    -\Delta u_i=f\hin\Omega_i\quad
    u_i|_{\Gamma_i}=\lambda \quad
    u_i|_{\Gamma_e^i} = 0 
 }

The version of this example for  Shur componant. The border problem
is solve with conjugate gradient. 

First, we construct the two domain 
\begin{example}[Schwarz-gc.edp]~
\index{tutorial!Schwarz-gc.edp}
\bFF
// Schwarz without overlapping (Shur complenement Neumann -> Dirichet)  
@real cpu=clock();
@int inside = 2; 
@int outside = 1; 

@border Gamma1(t=1,2){x=t;y=0;label=outside;};
@border Gamma2(t=0,1){x=2;y=t;label=outside;};
@border Gamma3(t=2,0){x=t ;y=1;label=outside;};

@border GammaInside(t=1,0){x = 1-t; y = t;label=inside;};

@border GammaArc(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=outside;}; 
int n=4;
//  build the mesh of $\Omega_1$ and $\Omega_2$
@mesh Th1 = buildmesh( Gamma1(5*n) + Gamma2(5*n) + GammaInside(5*n) + Gamma3(5*n));
@mesh Th2 = buildmesh ( GammaInside(-5*n) + GammaArc(25*n) );
@plot(Th1,Th2);

// defined the 2 FE space
@fespace Vh1(Th1,P1),      Vh2(Th2,P1);
\eFF
\begin{note}
It is impossible to 
define a function just on a part of boundary, so the $\ lambda $
function must be defined on the all domain $\Omega_1$
such as
\bFF
@Vh1 lambda=0;  // take $\lambda \in V_{h1}$
\eFF
\end{note}

The two Poisson problem:
\bFF
@Vh1 u1,v1;              Vh2 u2,v2;
@int i=0;  // for factorization optimization 
@problem Pb2(u2,v2,init=i,solver=Cholesky) = 
    int2d(Th2)( dx(u2)*dx(v2)+dy(u2)*dy(v2) )
  + int2d(Th2)( -v2) 
  + int1d(Th2,inside)(-lambda*v2) +    on(outside,u2= 0 ) ;
@problem Pb1(u1,v1,init=i,solver=Cholesky) = 
    int2d(Th1)( dx(u1)*dx(v1)+dy(u1)*dy(v1) )
  + int2d(Th1)( -v1) 
  + int1d(Th1,inside)(+lambda*v1) +    on(outside,u1 = 0 ) ;
\eFF
or, we define a border matrix , because the
 $\ lambda $ function is none zero inside the domain $\Omega_1$:
\bFF
@varf b(u2,v2,solver=CG) =int1d(Th1,inside)(u2*v2);
@matrix B= b(Vh1,Vh1,solver=CG);
\eFF

The boundary problem function,
  $$
  \lambda \longrightarrow  \int_{\Gamma_i }(u_1-u_2) v_{1}
$$
\bFF
@func @real[@int] BoundaryProblem(real[int] &l)
{ 
   lambda[]=l; // make FE function form l
   Pb1;     Pb2;
   i++;  //  no  refactorization i !=0
   v1=-(u1-u2); 
   lambda[]=B*v1[];
   @return lambda[] ;
};
\eFF
\begin{note}
The  difference between the two notations \ttCC{v1} and \ttCC{v1[]}  is: 
 \ttCC{v1} is the finite element  function and \ttCC{v1[]} 
is the vector in the canonical basis of the   finite element  function  \ttCC{v1} .
\index{[]@\verb=[]=}
\end{note}
\bFF
Vh1 p=0,q=0; 
//  solve the problem with Conjugue Gradient
LinearCG(BoundaryProblem,p[],eps=1.e-6,nbiter=100);
//  compute the final solution, because CG works with increment
BoundaryProblem(p[]); // solve again  to have right u1,u2

cout << " -- CPU time  schwarz-gc:" <<  clock()-cpu << endl;
plot(u1,u2); // plot 
\eFF
\end{example}


\subsection{Fluid/Structures Coupled Problem} 

This problem involves the Lam\'{e} system of elasticity
and the Stokes system for viscous fluids with velocity $\vec u$ and pressure $p$:
\begin{eqnarray*}\Blue
-\Delta \vec u +\vec\nabla p = 0, \,
%\`{u}
\nabla\cdot \vec u = 0,\hbox{~~in ~}\Omega,\,
\vec u=\vec u_\Gamma \hbox{~~on~~}\Gamma=\partial\Omega
\end{eqnarray*}\Black
where $u_\Gamma$ is the velocity of the boundaries. The
force  that the fluid applies to the boundaries is the normal stress
\Blue{$$
\vec h =(\nabla\vec u +\nabla\vec u^T)\vec n -p\vec n
$$}

Elastic solids subject to forces deform: a point in the solid,
originaly at (x,y)
goes to (X,Y) after.  When the displacement vector
$\vec v=(v_1,v_2) = (X-x, Y-y)$  is small, Hooke's
law relates the stress tensor $\sigma$ inside the solid to the
deformation tensor $\epsilon$:
\Blue{
 $$ \sigma_{ij} = \lambda \delta_{ij} \nabla.\vec v + 2\mu\epsilon_{ij},
\,
\epsilon_{ij} = {1\over 2}({\partial v_i\over\partial x_j} +
{\partial v_j\over\partial x_i} )$$
}
where $\delta$ is the Kronecker symbol
and where $\lambda, \mu$ are two constants describing the material mechanical
properties in terms of the modulus of
elasticity, and Young's modulus.

The equations of elasticity are naturally written in variational form
for the displacement vector $v(x)\in V$ as
\Blue{$$
\int_\Omega [2\mu\epsilon_{ij}(\vec v)\epsilon_{ij}(\vec w)
+\lambda \epsilon_{ii}(v)\epsilon_{jj}(\vec w)]
=\int_\Omega \vec g\cdot \vec w +\int_\Gamma \vec h\cdot \vec w,%\`{u}
\forall \vec w\in V
$$}
The data are the gravity force $\vec g$ and the
boundary stress $\vec h$.

\begin{example}[Fluidstruct.edp]
\index{tutorial!Fluidstruct.edp}
In our example the Lam\'{e} system and the Stokes system are coupled by a
common boundary on which
the fluid  stress creates a displacement of the boundary and hence
changes the shape of the domain where the Stokes problem is integrated.
The geometry is that of a vertical driven cavity with an elastic lid.
The lid is a beam with weight so it will
be deformed by its own weight and by the normal stress due to the fluid reaction.
The cavity is the $10 \times 10$ square and the lid is a rectangle of height $l=2$.
\\\\
A beam sits on a box full of fluid rotating because the left vertical side has velocity one.
The beam is bent by its own weight, but the pressure of the fluid modifies the bending.
\\
The bending displacement of the beam is given by (uu,vv) whose solution is 
given as follows.
\bFF
//  Fluid-structure interaction for a weighting beam sitting on a
// square cavity filled with a fluid.

@int bottombeam = 2; // label of bottombeam
@border a(t=2,0)  { x=0; y=t ;label=1;};        //  left beam
@border b(t=0,10) { x=t; y=0 ;label=bottombeam;};        //  bottom of beam
@border c(t=0,2)  { x=10; y=t ;label=1;};       //  rigth beam
@border d(t=0,10) { x=10-t; y=2; label=3;};     //  top beam
@real E = 21.5;
@real sigma = 0.29;
@real mu = E/(2*(1+sigma));
@real lambda = E*sigma/((1+sigma)*(1-2*sigma));
@real gravity = -0.05;
@mesh th = @buildmesh( b(20)+c(5)+d(20)+a(5));
@fespace Vh(th,@P1);
Vh uu,w,vv,s,fluidforce=0;
@cout << "lambda,mu,gravity ="<<lambda<< " " << mu << " " << gravity << @endl;
// deformation of a beam under its own weight
@solve  bb([uu,vv],[w,s])  =
    @int2d(th)(
                 2*mu*(dx(uu)*dx(w)+ ((dx(vv)+dy(uu))*(dx(s)+dy(w)))/4 )
               + lambda*(dx(uu)+dy(vv))*(dx(w)+dy(s))/2
             )
  + @int2d(th) (-gravity*s)
  + @on(1,uu=0,vv=0)
  + fluidforce[];
 ;

 @plot([uu,vv],wait=1);
 @mesh th1 = movemesh(th, [x+uu, y+vv]);
 @plot(th1,wait=1);
\eFF
Then Stokes equation for fluids ast low speed are solved in the box below the beam,
but the beam has deformed the box (see border h):
\bFF
//Stokes on square  b,e,f,g  driven cavite on left side g
@border e(t=0,10) { x=t; y=-10; label= 1; };      //  bottom
@border f(t=0,10) { x=10; y=-10+t ; label= 1; };   //  right
@border g(t=0,10) { x=0; y=-t ;label= 2;};       //  left
@border h(t=0,10) { x=t; y=vv(t,0)*( t>=0.001 )*(t <= 9.999); 
                    label=3;};   //  top of cavity deforme

@mesh sh = @buildmesh(h(-20)+f(10)+e(10)+g(10));
@plot(sh,wait=1);
\eFF
 We use the Uzawa conjugate gradient to solve the Stokes problem like in example \refSec{Uzawa}

\bFF
@fespace Xh(sh,P2),Mh(sh,P1);
Xh u1,u2,v1,v2;
Mh p,q,ppp;


@varf bx(u1,q) = @int2d(sh)( -(dx(u1)*q));

@varf by(u1,q) = @int2d(sh)( -(dy(u1)*q));

@varf Lap(u1,u2)= @int2d(sh)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) )
                    +  @on(2,u1=1) +  @on(1,3,u1=0)  ;

Xh bc1; bc1[] = Lap(0,Xh);
Xh brhs;

@matrix A= Lap(Xh,Xh,solver=CG);
@matrix Bx= bx(Xh,Mh);
@matrix By= by(Xh,Mh);
Xh bcx=0,bcy=1;

@func @real[@int] divup(@real[@int] & pp)
{
  @int verb=verbosity;
   verbosity=0;
   brhs[]  = Bx'*pp; brhs[] += bc1[] .*bcx[];
   u1[] = A^-1*brhs[];
   brhs[]  = By'*pp; brhs[] += bc1[] .*bcy[];
   u2[] = A^-1*brhs[];
   ppp[] =   Bx*u1[];
   ppp[] +=  By*u2[];
   verbosity=verb;
   @return ppp[] ;
};

 p=0;q=0;u1=0;v1=0;

 @LinearCG(divup,p[],eps=1.e-3,nbiter=50);
 divup(p[]);
\eFF
Now the beam will feel the stress constraint from the fluid:
\bFF
  Vh sigma11,sigma22,sigma12;
  Vh uu1=uu,vv1=vv;

  sigma11([x+uu,y+vv]) = (2*dx(u1)-p);
  sigma22([x+uu,y+vv]) = (2*dy(u2)-p);
  sigma12([x+uu,y+vv]) = (dx(u1)+dy(u2));
\eFF
which comes as a boundary condition to the PDE of the beam:
\bFF
@varf fluidf([uu,vv],[w,s]) fluidforce =
@solve  bbst([uu,vv],[w,s],init=i)  =
    @int2d(th)(
                 2*mu*(dx(uu)*dx(w)+ ((dx(vv)+dy(uu))*(dx(s)+dy(w)))/4 )
               + lambda*(dx(uu)+dy(vv))*(dx(w)+dy(s))/2
             )
  + @int2d(th) (-gravity*s)
  + @int1d(th,bottombeam)( -coef*(   sigma11*N.x*w + sigma22*N.y*s 
                                   + sigma12*(N.y*w+N.x*s) )  )
  + @on(1,uu=0,vv=0);
 @plot([uu,vv],wait=1);
 @real  err = sqrt(@int2d(th)( (uu-uu1)^2 + (vv-vv1)^2 ));
 @cout <<  " Erreur L2 = " << err << "----------\n";
\eFF

Notice that the matrix generated by bbst is reused (see \ttCC{init=i}).
Finally we deform the beam
\bFF
 th1 = @movemesh(th, [x+0.2*uu, y+0.2*vv]);
 @plot(th1,wait=1);
\eFF
\end{example}

\subsection{\setS{Transmission Problem}}
Consider an elastic plate whose displacement change vertically,
which is made up of three plates of different materials, 
welded on each other.
Let $\Omega_i,\, i=1,2,3$ be the domain occupied by $i$-th material
with tension $\mu_i$ (see \refSec{Soap Film}). 
The computational domain $\Omega$ is the interior of 
$\overline{\Omega_1}\cup \overline{\Omega_2}\cup \overline{\Omega_3}$.
The vertical displacement $u(x,y)$ is obtained from
\begin{eqnarray}
\label{eqn:transm-1}
-\mu_i\Delta u&=&f~\textrm{in }\Omega_i\\
\label{eqn:transm-2}
\mu_i\partial_n u|_{\Gamma_{i}}&=&-\mu_j\partial_n u|_{\Gamma_{j}}
\quad \textrm{on }\overline{\Omega_{i}}\cap\overline{\Omega_{j}}
\qquad \textrm{if }1\le i< j\le 3
\end{eqnarray}
where $\partial_n u|_{\Gamma_{i}}$ denotes the value of 
the normal derivative $\partial_n u$ on the boundary $\Gamma_i$ of
the domain $\Omega_i$.

By introducing the characteristic function $\chi_i$ of $\Omega_i$, that is,
\begin{equation}
\chi_i(x)=1\quad\textrm{if }x\in \Omega_i;\qquad
\chi_i(x)=0\quad\textrm{if }x\not\in \Omega_i
\end{equation}
we can easily rewrite (\ref{eqn:transm-1}) and (\ref{eqn:transm-2})
to the weak form. Here we assume that $u=0$ on $\Gamma=\partial\Omega$.

problem Transmission: For a given function $f$, find $u$ such that
\begin{eqnarray}
\label{eqn:transmission}
a(u,v)&=&\ell(f,v)\quad \textrm{for all }v\in H^1_0(\Omega)\\
a(u,v)=\int_{\Omega}\mu \nabla u\cdot \nabla v,\quad
\ell(f,v)=\int_{\Omega}fv\nonumber
\end{eqnarray}
where $\mu=\mu_1\chi_1+\mu_2\chi_2+\mu_3\chi_3$.
Here we notice that $\mu$ become the discontinuous function.

With dissipation, and at the thermal equilibrium, the temperature equation
is:

This example explains the definition and manipulation of \emph{region}, i.e.
\index{subdomains} subdomains of the whole domain.

Consider this L-shaped domain with 3 diagonals as internal boundaries, defining
4 subdomains:

\bFF
//   example using region keywork
// construct a mesh with 4 regions (sub-domains)
border a(t=0,1){x=t;y=0;};
border b(t=0,0.5){x=1;y=t;};
border c(t=0,0.5){x=1-t;y=0.5;};
border d(t=0.5,1){x=0.5;y=t;};
border e(t=0.5,1){x=1-t;y=1;};
border f(t=0,1){x=0;y=1-t;};
//  internal boundary 
border i1(t=0,0.5){x=t;y=1-t;};
border i2(t=0,0.5){x=t;y=t;};
border i3(t=0,0.5){x=1-t;y=t;};
   
mesh th = buildmesh (a(6) + b(4) + c(4) +d(4) + e(4) + 
    f(6)+i1(6)+i2(6)+i3(6));
fespace Ph(th,P0);  // constant discontinuous functions / element
fespace Vh(th,P1);  // $P_1$ ontinuous functions / element

Ph reg=region; //  defined the $P_0$ function  associed to region number 
plot(reg,fill=1,wait=1,value=1);
\eFF
\twoplot[height=8cm]{region}{region_nu}{the function \texttt{reg}}{the function \texttt{nu} }

\index{region} \texttt{region}  is a keyword of freefem++ which is in fact a variable depending of 
the current position (is not a function today, use \texttt{Ph reg=region;} to  set  a function).  This variable value returned is the number of the
subdomain of the current position.  This number is defined by "buildmesh" which scans while building the mesh all
its connected component.  So to get the number of a region containing a particular point
one does:
\bFF

int nupper=reg(0.4,0.9); // get the region number of point (0.4,0.9)
int nlower=reg(0.9,0.1);  // get the region number of point (0.4,0.1)
cout << " nlower " <<  nlower << ", nupper = " << nupper<< endl;
//  defined the characteristics functions of upper and lower region
Ph nu=1+5*(region==nlower) + 10*(region==nupper);
plot(nu,fill=1,wait=1);
\eFF
This is particularly useful to define \index{discontinuous functions}discontinuous functions such as might occur
when one part of the domain is copper and the other one is iron, for example.
\\
We this in mind we proceed to solve a Laplace equation with discontinuous coefficients
($\nu$ is 1, 6 and 11 below).
\bFF
Ph nu=1+5*(region==nlower) + 10*(region==nupper);
plot(nu,fill=1,wait=1);
problem lap(u,v) =   int2d(th)( nu*( dx(u)*dx(v)*dy(u)*dy(v) )) + int2d(-1*v) + on(a,b,c,d,e,f,u=0);
plot(u);
\eFF
\plot[height=8cm]{region_u}{the isovalue of the solution $u$}
\newpage

\subsection{Free Boundary Problem}

The domain $\Omega$ is defined with:

\bFF
@real L=10;        //longueur du domaine                                    
@real h=2.1;      // hauteur du bord gauche
@real h1=0.35;    // hauteur du bord droite

//  maillage d'un tapeze
@border a(t=0,L){x=t;y=0;};       // bottom:  $\Gamma_a$ \hfill              
@border b(t=0,h1){x=L;y=t;};      // right:  $\Gamma_b$ \hfill    
@border f(t=L,0){x=t;y=t*(h1-h)/L+h;}; //  free surface:  $\Gamma_f$ \hfill    
@border d(t=h,0){x=0;y=t;};      // left:  $\Gamma_d$ \hfill 

@int n=4;
@mesh Th=@buildmesh (a(10*n)+b(6*n)+f(8*n)+d(3*n));
@plot(Th,ps="dTh.eps");
\eFF


\begin{figure}[hbt]
\includegraphics[width=15cm]{dTh}
\caption{The mesh of the domain $\Omega$}
\end{figure}

The free boundary problem is: 
 
Find $u$ and $\Omega$ such that:

 $$ \left\{\begin{array}{cl} 
 \displaystyle - \Delta u = 0  & \mbox{in } \Omega\\
 \displaystyle      u = y         &\mbox{on } \Gamma_b \\
 \displaystyle      {\partial u  \over \partial n} = 0   &\mbox{on } \Gamma_d \cup \Gamma_a \\
 \displaystyle    {\partial u  \over \partial n} = { q\over K} n_x  
          \mbox{\ and \ } {u = y}  &\mbox{on\ } \Gamma_ f
\end{array}\right. $$


We use a fixed point method;
$\Omega^0 = \Omega$

in two step, fist we solve the classical following problem:
$$ \left\{\begin{array}{rll} 
 \displaystyle - \Delta u &= 0  & \mbox{in } \Omega^n\\
 \displaystyle      u &= y         &\mbox{on } \Gamma^n_b \\
 \displaystyle      {\partial u  \over \partial n} &= 0   &\mbox{on } \Gamma^n_d \cup \Gamma^n_a\\
 \displaystyle    u &= y        &\mbox{on\ } \Gamma^n_ f
\end{array}\right. $$

The varitional formulation is:

find $u$ on $V=H^1(\Omega^n)$, such than  $u=y$ on $\Gamma^n_b$ and $\Gamma^n_f$
$$
 \int_{\Omega^n}  \nabla u \nabla u' = 0,  \quad \forall u' \in V  \mbox{ with }  u' =0 \mbox{ on } 
\Gamma^n_b \cup \Gamma^n_f
$$


and secondly to construte a domain deformation $\mathcal{F}(x,y)=[x,y-v(x,y)]$ 

where $v$ is  solution of  the following problem: 

 $$ \left\{\begin{array}{rll} 
 \displaystyle - \Delta v &= 0  & \mbox{in } \Omega^n\\
 \displaystyle      v  &= 0         &\mbox{on } \Gamma^n_a \\
 \displaystyle      {\partial v \over \partial n} &= 0   &\mbox{on } \Gamma^n_b \cup \Gamma^n_d \\
 \displaystyle    {\partial v  \over \partial n}  &=  \displaystyle {\partial u  \over \partial n} - { q\over K} n_x  
            &\mbox{on\ } \Gamma^n_ f
\end{array}\right. $$

The varitional formulation is:

find $v$ on $V$, such than  $v=0$ on $\Gamma^n_a$ 
$$
 \int_{\Omega^n}  \nabla v \nabla v' = \int_{\Gamma_f^n}  ({\partial u  \over \partial n} - { q\over K} n_x )v',  \quad \forall v' \in V  \mbox{ with }  v' =0 \mbox{ on } 
\Gamma^n_a 
$$

finaly the new domain 
$\Omega^{n+1} = \mathcal{F}(\Omega^n)$



\begin{example}[freeboundary.edp]
\index{tutorial!freeboundary.edp}
The  \texttt{FreeFem++} :implementation is:

\bFF
@real q=0.02;      //flux entrant
@real K=0.5;           //permeabilit

@fespace Vh(Th,P1);
@int j=0;

Vh u,v,uu,vv;

@problem Pu(u,uu,solver=CG) = @int2d(Th)( dx(u)*dx(uu)+dy(u)*dy(uu)) 
  + @on(b,f,u=y) ;

@problem Pv(v,vv,solver=CG) = @int2d(Th)( dx(v)*dx(vv)+dy(v)*dy(vv)) 
  +  @on (a, v=0) + @int1d(Th,f)(vv*((q/K)*N.y- (dx(u)*N.x+dy(u)*N.y))); 
  

@real errv=1;
@real erradap=0.001;
verbosity=1;
@while(errv>1e-6)
{
  j++;       
  Pu;
  Pv;
  @plot(Th,u,v ,wait=0);
  errv=int1d(Th,f)(v*v);
   real coef=1;

//  
  real mintcc = @checkmovemesh(Th,[x,y])/5.; 
  real mint = @checkmovemesh(Th,[x,y-v*coef]); 
  
  if (mint<mintcc ||  j%10==0) {  // mesh to bad => remeshing
    Th=@adaptmesh(Th,u,err=erradap ) ;
    mintcc = @checkmovemesh(Th,[x,y])/5.;     
  }
  
  @while (1) 
  {       
    real mint = @checkmovemesh(Th,[x,y-v*coef]); 
    
    if (mint>mintcc) break;
    
    cout << " min |T]  " << mint << endl;    
    coef /= 1.5;
  }
  
  Th=@movemesh(Th,[x,y-coef*v]); // calcul de la deformation 
  cout << "\n\n"<<j <<"------------ errv = " << errv << "\n\n";

}
@plot(Th,ps="d_Thf.eps");
@plot(u,wait=1,ps="d_u.eps");
\eFF
\end{example}

\begin{figure}[hbt]
\includegraphics[width=15cm]{d_u}
\caption{The final solution on  the new  domain $\Omega^{72}$}
\end{figure}
\begin{figure}[hbt]
\includegraphics[width=15cm]{d_Thf}
\caption{The adapted mesh of the domain $\Omega^{72}$}
\end{figure}

\textBlack\subsection{nolinear-elas.edp}
\textBlack
The nonlinear elasticity  problem is find  the deplacement $(u_{1},u_{2})$  minimizing  $J$
$$ \min J(u_{1},u_{2}) = \int_{\Omega} f(F2) -  \int_{\Gamma_{p}} P_{a} \,  u_{2} $$
where  $F2(u_{1},u_{2}) =  A(E[u_{1},u_{2}],E[u_{1},u_{2}])$ and $A(X,Y)$ is bilinear sym. positive form with respect two matrix $X,Y$.
where $f$ is a given $\mathcal{C}^2$  function, and $E[u_{1},u_{2}] = (E_{ij})_{i=1,2,\,j=1,2}$ is the Green-Saint Venant deformation tensor defined  with: 
$$  E_{ij} = 0.5 ( \partial_i u_j + \partial_j u_i ) + \sum_k \partial_i u_k  \partial_j u_k  $$ 



The differential of $J$ is 
  $$ DJ(u_{1},u_{2})(v_{1},v_{2}) = \int 2 A(E[u_{1},u_{2}],DE[u_{1},u_{2}](v_{1},v_{2})) f'(F2(u_{1},u_{2}))) -  \int_{\Gamma_{p}} P_{a}  u_{2}  $$

denote $\mathbf{u}=u_{1},u_{2}$, $\mathbf{v}=v_{1},v_{2}$, $\mathbf{w}=(w_{1},w_{2})$ and  
the second order differential is
 {\begin{eqnarray*}
 D^2 J(\mathbf{u})((\mathbf{v}),(\mathbf{w}))  &= & A(E[\mathbf{u}],DE[\mathbf{u}](\mathbf{v})) A(E[\mathbf{u}],DE[\mathbf{u}](\mathbf{w})) f''(F2(\mathbf{u}))) \\
 & + &  A(DE[\mathbf{u}](\mathbf{v}),DE[\mathbf{u}](\mathbf{w})) f'(F2(\mathbf{u}))) \\
 &+&  A(DE[\mathbf{u}],D^{2}E[\mathbf{u}]((\mathbf{v}),(\mathbf{w}))) f'(F2(\mathbf{u}))) 
\end{eqnarray*}}
 where $DE$ and $D^{2}E$ are the first and second differential of $E$.
 
 \medskip
 

The Newton Method is

choose $ n=0$,and $u_O,v_O$ the initial displacement 
\begin{itemize}
\item loop: \par
\item  \hspace{1cm}    find $(du,dv)$ :  solution of 
$$ D^2J(u_n,v_n)((w,s),(du,dv)) =  DJ(u_n,v_n)(w,s) , \quad \forall w,s $$
\item  \hspace{1cm}      $un =un - du,\quad vn =vn - dv$ 
\item  \hspace{1cm}      until $(du,dv)$ small is enough
\end{itemize}

\color{black}The way to implement this algorithme in \freefempp is
use a macro tool to implement  $A$ and $F2$, $f$, $f'$,$f''$.

A macro\label{macro}\index{macro} is like is \texttt{ccp} preprocessor of \Cpp, but this begin by 
\texttt{macro} and the end of the macro definition is the begin of the comment $//$.
In this case the macro is very useful because the type of parameter can be change. 
And  it is easy to make automatic differentiation.

\bFF  
//  non linear elasticity model \hfilll
//   \hfilll
//  -------------------------------\hfilll
//  with huge utilisation of  macro\hfilll
// ---------------------------\hfilll
//   optimize version \hfilll
// ------------\hfilll
//  @problem is  find $(uu,vn)$  minimizing  $J$\hfilll
//  $ min J(un,vn) = @int f(F2) -  @int Pa * un $\hfilll
//   $ dJ(u,u,uu,vv) = @int dF2(u,v,uu,vv) df(F2(u,v))$ \hfilll
//   where $F2 =  (^t {E}  A {E} )$ , \hfilll
//   $E(U) =  1/2 (\nabla U + \nabla U^t + \nabla U^t  \nabla U) $ \hfilll
//         ($u_1$) \hfilll
//  with U=(   )\hfilll
//         ($u_2$)\hfilll
// so: \hfilll
// \hfilll$$ E_{ij} = 0.5 ( d_i u_j + d_j u_i ) + \sum_k d_i u_k * d_j*u_k  \leqno(1)$$ 
//  the 3 componantes of the Green Saint Venant deformation tensor: \hfilll
//  $E1(u1,u2) =    E_{11} $\hfilll
//  $E2(u1,u2) =    E_{12} = E_21 $\hfilll
//  $E3(u1,u2) =    E_{22}  $\textBlack\hfilll
\eFF
~
\bFF
// remark : we can parametrize E1,E2,E3 with:\hfilll
//  EE(da,db,a,b,u1,u2) \hfilll
//   where $da,db$ correspond to $d_i, d_j$ in (1)\hfilll
//   where  $a,b$  correspond to $u_i, u_j$ in (1)\hfilll
//   where $u1,u2$  correspond to $u_1, u_2$ in (1)\hfilll
//  ----------------------------------------------

//  first the linear part of EE linear elasticite\hfilll
// remark a macro end with a // comment \hfilll
@macro EEL(di,dj,ui,uj) ( (di(uj)+dj(ui))*0.5 )    // 11

// non linear par of EE (bilinear)  simple to differential \hfilll
@macro bEENL(di,dj,u1,u2,v1,v2) (di(u1)*dj(v1)*.5+di(u2)*dj(v2)*0.5) 
// 
@macro EENL(di,dj,u1,u2) bEENL(di,dj,u1,u2,u1,u2) // 
@macro dEENL(di,dj,u1,u2,du1,du2) ( bEENL(di,dj,du1,du2,u1,u2) 
                                  + bEENL(di,dj,u1,u2,du1,du2) )   
//   ------------ \hfilll
@macro EE(di,dj,ui,uj,u1,u2) (EEL(di,dj,u1,uj) + EENL(di,dj,u1,u2)) //
@macro dEE(di,dj,dui,duj,u1,u2,du1,du2) (EEL(di,dj,du1,duj) 
                                         + dEENL(di,dj,u1,u2,du1,du2)) //
@macro ddEE(di,dj,du1,du2,ddu1,ddu2) ( dEENL(di,dj,du1,du2,ddu1,ddu2)) 
//
// remark  : \hfilll
// $ dEE(di,dj,dui,duj,u1,u2,du1,du2)$  is "the formal differential of EE" \hfilll
// where $du1=\delta u1$ ,$du2=\delta u2$ \hfilll
// $ ddEE(di,dj,dui,duj,u1,u2,du1,du2)$  is "the formal differential of dEE" \hfilll
// where $ddu1=\delta^2 u1$ ,$ddu2=\delta^2 u2$ \hfilll
// --- \hfilll

//  the macro corresponding to the 3 componante of E \hfilll
@macro E1(u,v)  /*E11*/EE(dx,dx,u,u,u,v)  //
@macro E2(u,v)  /*E12*/EE(dx,dy,u,v,u,v)  //
@macro E3(u,v)  /*E22*/EE(dy,dy,v,v,u,v)  //

@macro dE1(u,v,uu,vv) /*dE11*/dEE(dx,dx,uu,uu,u,v,uu,vv) // 
@macro dE2(u,v,uu,vv) /*dE12*/dEE(dx,dy,uu,vv,u,v,uu,vv) //
@macro dE3(u,v,uu,vv) /*dE22*/dEE(dy,dy,vv,vv,u,v,uu,vv) //
@macro ddE1(u,v,uu,vv,uuu,vvv) /*ddE11*/ddEE(dx,dx,uu,vv,uuu,vvv) //
@macro ddE2(u,v,uu,vv,uuu,vvv) /*ddE12*/ddEE(dx,dy,uu,vv,uuu,vvv) //
@macro ddE3(u,v,uu,vv,uuu,vvv) /*ddE22*/ddEE(dy,dy,uu,vv,uuu,vvv) 
//
//  a formal bilinear term \hfilll
@macro PP(A,B,u,v) (A(u,v)*B(u,v)) 
// 
// a formal diff  bilinear term \hfilll
@macro dPP(A,B,dA,dB,u,v,uu,vv) (dA(u,v,uu,vv)*B(u,v) + A(u,v)*dB(u,v,uu,vv)) 
//
// a formal $diff^2$ bilinear term \hfilll
@macro ddPP(A,B,dA,dB,ddA,ddB,u,v,uu,vv,uuu,vvv) (
  dA(u,v,uu,vv)*dB(u,v,uuu,vvv) + dA(u,v,uuu,vvv)*dB(u,v,uu,vv) 
  +  ddA(u,v,uu,vv,uuu,vvv)*B(u,v) + A(u,v)*ddB(u,v,uu,vv,uuu,vvv) 
  ) //
// so the @matrix A is 6 coef \hfilll
//      
//     a11 a12 a13 \hfilll
//     a12 a22 a23 \hfilll
//     a13 a23 a33 \hfilll
@macro F2(u,v)  /* F2 */  (
     a11*PP(E1,E1,u,v)
  +  a22*PP(E2,E2,u,v)
  +  a33*PP(E3,E3,u,v)
  +  a13*PP(E1,E3,u,v)
  +  a13*PP(E3,E1,u,v)
  +  a12*PP(E1,E2,u,v)
  +  a12*PP(E2,E1,u,v)
  +  a23*PP(E2,E3,u,v)
  +  a23*PP(E3,E2,u,v)
)  // end macro F2

@macro dF2(u,v,uu,vv)  /* dF2 */  (
       a11*dPP(E1,E1,dE1,dE1,u,v,uu,vv)
     + a12*dPP(E1,E2,dE1,dE2,u,v,uu,vv)
     + a13*dPP(E1,E3,dE1,dE3,u,v,uu,vv)
     + a21*dPP(E2,E1,dE2,dE1,u,v,uu,vv)
     + a22*dPP(E2,E2,dE2,dE2,u,v,uu,vv)
     + a23*dPP(E2,E3,dE2,dE3,u,v,uu,vv)
     + a31*dPP(E3,E1,dE3,dE1,u,v,uu,vv)
     + a32*dPP(E3,E2,dE3,dE2,u,v,uu,vv)
     + a33*dPP(E3,E3,dE3,dE3,u,v,uu,vv)
) // end macro dF2 ($D F2$)

@macro ddF2(u,v,uu,vv,uuu,vvv)  /* ddF2 */  (
       a11*ddPP(E1,E1,dE1,dE1,ddE1,ddE1,u,v,uu,vv,uuu,vvv)
     + a12*ddPP(E1,E2,dE1,dE2,ddE1,ddE2,u,v,uu,vv,uuu,vvv)
     + a13*ddPP(E1,E3,dE1,dE3,ddE1,ddE3,u,v,uu,vv,uuu,vvv)
     + a21*ddPP(E2,E1,dE2,dE1,ddE2,ddE1,u,v,uu,vv,uuu,vvv)
     + a22*ddPP(E2,E2,dE2,dE2,ddE2,ddE2,u,v,uu,vv,uuu,vvv)
     + a23*ddPP(E2,E3,dE2,dE3,ddE2,ddE3,u,v,uu,vv,uuu,vvv)
     + a31*ddPP(E3,E1,dE3,dE1,ddE3,ddE1,u,v,uu,vv,uuu,vvv)
     + a32*ddPP(E3,E2,dE3,dE2,ddE3,ddE2,u,v,uu,vv,uuu,vvv)
     + a33*ddPP(E3,E3,dE3,dE3,ddE3,ddE3,u,v,uu,vv,uuu,vvv)
) // end macro ddF2  ($D^{2}  F2$)

//  differential of J: \hfilll

//  @for hyper elasticity @problem  \hfilll
//  ------------------------------ \hfilll

@macro f(u) (u) // end of macro  
@macro df(u) (1) // end of macro  $df=f'$
@macro ddf(u) (0) // end of macro $ddf=f''$

//  -- du caouchouc --- CF cours de Herve Le Dret. \hfilll
// ------------------------------- \hfilll
@real mu = 0.012e5; //  $kg/cm^2$
@real lambda =  0.4e5; //  $kg/cm^2$
//  \hfilll
//   $  \sigma = 2 \mu E + \lambda tr(E) Id $  \hfilll
//    \hfilll
//   ( a b )  \hfilll
//   ( b c )  \hfilll
//  \hfilll
//  tr*Id : (a,b,c) -> (a+c,0,a+c)  \hfilll
// so the associed @matrix is:  \hfilll
//   ( 1 0 1 )  \hfilll
//   ( 0 0 0 )  \hfilll
//   ( 1 0 1 )  \hfilll
// ------------------ the coef \hfilll
@real a11= 2*mu +  lambda  ;
@real a22= 2*mu ;
@real a33= 2*mu +   lambda ;
@real a12= 0 ;
@real a13= lambda ;
@real a23= 0 ;
//  symetric part
@real a21= a12 ;
@real a31= a13 ;
@real a32= a23 ;
@real Pa=1e2; //  a pressure of 100 Pa
// ----------------

@int n=30,m=10;
@mesh Th= square(n,m,[x,.3*y]); // label: 1 bottom, 2 right, 3 up, 4 left;
@int bottom=1, right=2,upper=3,left=4;

@plot(Th);
 
@fespace Wh(Th,P1dc);
@fespace Vh(Th,[P1,P1]);
@fespace Sh(Th,P1);

Wh e2,fe2,dfe2,ddfe2; // optimisation 
Wh ett,ezz,err,erz; // optimisation 

Vh [uu,vv], [w,s],[un,vn];
[un,vn]=[0,0];//  intialisation 
[uu,vv]=[0,0];

@varf vmass([uu,vv],[w,s],solver=CG) =  @int2d(Th)( uu*w + vv*s );
@matrix M=vmass(Vh,Vh);

@problem NonLin([uu,vv],[w,s],solver=LU)=
 @int2d(Th,qforder=1)( // $(D^2 J(un))$ part
               ddF2(un,vn,uu,vv,w,s)* dfe2 
       + dF2(un,vn,uu,vv)*dF2(un,vn,w,s)*ddfe2        
        )
   -@int2d(Th,<1)( // $(D J(un))$ part
           dF2(un,vn,w,s) * dfe2  )
   - @int1d(Th,3)(Pa*s) 
   + @on(right,left,uu=0,vv=0);
;
// Newton's method
// ---------------
Sh u1,v1;
@for (@int i=0;i<10;i++)
{
  @cout << "Loop " << i << @endl;
  e2 = F2(un,vn);
  dfe2 = df(e2) ;
  ddfe2 = ddf(e2);
  @cout << "  e2 max " <<e2[].max << " , min" << e2[].min << @endl;
  @cout << " de2 max "<< dfe2[].max << " , min" << dfe2[].min << @endl;
  @cout << "dde2 max "<< ddfe2[].max << " , min" << ddfe2[].min << @endl;
  NonLin; //  compute $[uu,vv] = (D^2 J(un))^{-1}(D J(un))$
  
  w[]   = M*uu[];
  @real res = sqrt(w[]' * uu[]); //  norme $ L^2 of [uu,vv]$
  u1 = uu;
  v1 = vv;
  @cout << " L^2 residual = " << res << @endl;
  @cout << " u1 min =" <<u1[].min << ", u1 max= " << u1[].max << @endl;
  @cout << " v1 min =" <<v1[].min << ", v2 max= " << v1[].max << @endl;
  @plot([uu,vv],wait=1,cmm=" uu, vv " );
  un[] -= uu[]; 
  @plot([un,vn],wait=1,cmm=" deplacement " );
  @if (res<1e-5) @break;
}

@plot([un,vn],wait=1);
@mesh th1 = @movemesh(Th, [x+un, y+vn]);
@plot(th1,wait=1); //  see figure \ref{fig nl-elas}
\eFF

\begin{figure}[hbt]
\begin{center}\includegraphics[width=16cm]{nl-elas}\end{center}
\caption{\label{fig nl-elas} The deformated domain}
\end{figure}



\section{Parallel version experimental}
A first test of parallisation of \texttt{FreeFem++} is make under mpi.
We add three word in the language:
\begin{description}
\itemtt[mpisize] The total number of  processes\index{mpisize}
\itemtt[mpirank]  the number of my current process in $\{0,..., mpisize-1\}$.\index{mpirank}
\itemtt [processor] a function to set the possessor to send or receive data 
\itemtt [broadcast] a function to broadcast from a processor to all other a data \index{broadcast}\index{processor}
\bFF
    processor(10) << a ; // send to the process 10 the data a;
    processor(10) >> a ; // receive from the process 10 the data a;

\eFF
\end{description}
\subsection{Schwarz in parallel}
If example is just the rewritting of example \texttt{schwarz-overlap} 
in section \ref{schwarz-overlap}.\index{schwarz}\index{broadcast}\index{processor}
\index{array!mesh}

How to use 
\bFF
[examples++-mpi] hecht%lamboot

LAM 6.5.9/MPI 2 C++/ROMIO - Indiana University


[examples++-mpi] hecht% mpirun -np 2 FreeFem++-mpi schwarz-c.edp
\eFF

\bFF
//  a new coding verion c,   methode de schwarz in parallele \hfilll
// with 2 proc. \hfilll
//  ------------------------------- \hfilll
// F.Hecht december 2003 \hfilll
// ---------------------------------- \hfilll
//  to test the broadcast instruction \hfilll
//  and array of mesh  \hfilll
//  add add the stop test \hfilll
//  --------------------------------- \hfilll

@if ( mpisize != 2 ) {
  @cout << " sorry number of processeur !=2 " << endl;
  exit(1);}
@verbosity=3;
@real pi=4*atan(1);
@int inside = 2;
@int outside = 1;
@border a(t=1,2){x=t;y=0;label=outside;};
@border b(t=0,1){x=2;y=t;label=outside;};
@border c(t=2,0){x=t ;y=1;label=outside;};
@border d(t=1,0){x = 1-t; y = t;label=inside;};
@border e(t=0, pi/2){ x= cos(t); y = sin(t);label=inside;};
@border e1(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=outside;}; 
@int n=4;
@mesh[int]  Th(mpisize);
@if (mpirank == 0) 
 Th[0] = buildmesh( a(5*n) + b(5*n) + c(10*n) + d(5*n));
@else
 Th[1] = buildmesh ( e(5*n) + e1(25*n) );

@broadcast(@processor(0),Th[0]);
@broadcast(@processor(1),Th[1]);

@fespace Vh(Th[mpirank],P1);
@fespace Vhother(Th[1-mpirank],P1);

Vh u=0,v;
Vhother U=0;
@int i=0;

@problem pb(u,v,init=i,solver=Cholesky) = 
    @int2d(Th[mpirank])( dx(u)*dx(v)+dy(u)*dy(v) )
  - @int2d(Th[mpirank])( v) 
  + @on(inside,u = U)  +  @on(outside,u= U ) ;

@for ( i=0 ;i< 20; i++) 
{ 
  @cout << mpirank << " looP " << i << endl;
   pb; 
   //  send u  to the other proc, receive in U
   @processor(1-mpirank) << u[];   @processor(1-mpirank) >> U[];
   @real err0,err1;
   err0 = int1d(Th[mpirank],inside)(square(U-u)) ;
   // send err0  to the other proc, receive in err1
   @processor(1-mpirank)<<err0;   @processor(1-mpirank)>>err1;
   @real err= sqrt(err0+err1);
   @cout <<" err = " << err << " err0 = " << err0 << ", err1 = " << err1 << endl;
   @if(err<1e-3) @break;
};
@if (mpirank==0)  
    @plot(u,U,ps="uU.eps");

\eFF

\include{docFFGUI}

\section{\setS{Mesh Files}}
 \def\Chars#1{{\tt (C*)}  #1}
 \def\Char#1{{\tt (C)}  #1}
 \def\Int#1{ {\tt(I)} #1}
 \def\Real#1{{\tt(R)} #1}
 \def\Bool#1{{\tt(B)} #1}
 \def\Vertex#1{{{\tt @@Vertex}#1}}
 \def\Edge#1{{{\tt @@Edge}#1}}
 \def\Triangle#1{{{\tt @@Tria}#1}}
 \def\Quadrangle#1{{{\tt @@Quad}#1}}
 \def\Tetrahedron#1{{{\tt @@Tetra}#1}}
 \def\Hexahedron#1{{{\tt @@Hexa}#1}}
 \def\Pentahedron#1{{{\tt @@Penta}#1}}
 \def\Loop#1#2{{\bf\Large(}\,#1\,{\bf\Large{,\,\,}}\,#2\,{\bf\Large)}}
 \def\requis{\hfill {\it  requis}}
 \def\facultatif{\quad\quad facultatif}
 \def\need#1{\hfill{\it  requiert le champ\,:\,#1}}

\subsection{File mesh data structure}
\index{file!data base}\index{file!bamg}
The mesh data structure, output of a mesh generation algorithm, 
refers to the geometric data structure and in some case to another
mesh data structure.

In this case, the fields are

\small
\begin{itemize}
\item {\tt MeshVersionFormatted 0}
\end{itemize}
\normalsize

\small
\begin{itemize}
\item {\tt Dimension} 
  \Int{dim} 

\item {\tt Vertices} 
  \Int{NbOfVertices}\\
  \Loop{\,\,\Loop{\Real{x$_i^j$}}{j=1,dim}\,\,,\,\Int{$Ref \phi_i^v$}}{i=1\,,\,NbOfVertices}

\item {\tt Edges} 
  \Int{NbOfEdges} \\
  \Loop{\Vertex{$^1_i$}\,,\,\Vertex{$^2_i$}\,,\,\Int{$Ref \phi_i^e$}}{i=1\,,\,NbOfEdges}

\item {\tt Triangles} 
  \Int{NbOfTriangles} \\
    \Loop{\Loop{\Vertex{$_i^j$}}{j=1,3}\,,\,\Int{$Ref \phi_i^t$} }{ i=1\,,\,NbOfTriangles}

\item {\tt Quadrilaterals} 
  \Int{NbOfQuadrilaterals} \\
    \Loop{\Loop{\Vertex{$_i^j$}}{j=1,4}\,,\,\Int{$Ref \phi_i^t$} }{ i=1\,,\,NbOfQuadrilaterals}

\item {\tt Geometry} \\
\Chars{FileNameOfGeometricSupport} \\

\begin{itemize}
\item {\tt VertexOnGeometricVertex} \\
   \Int{NbOfVertexOnGeometricVertex}\\
\Loop{\Vertex{$_i$}\,,\,\Vertex{$_i^{geo}$}}{i=1,NbOfVertexOnGeometricVertex}

\item {\tt EdgeOnGeometricEdge} \\
   \Int{NbOfEdgeOnGeometricEdge}\\
\Loop{\Edge{$_i$}\,,\,\Edge{$_i^{geo}$}}{i=1,NbOfEdgeOnGeometricEdge}
\end{itemize}

\item {\tt CrackedEdges} 
  \Int{NbOfCrackedEdges}\\
  \Loop{\Edge{$_i^1$}\,,\,\Edge{$_i^2$}}{i=1\,,\,{NbOfCrackedEdges}}

\end{itemize}
\normalsize

When the current mesh refers to a previous mesh, we have in addition

\small
\begin{itemize}
\item {\tt MeshSupportOfVertices} \\
\Chars{FileNameOfMeshSupport} \\
\begin{itemize}

\item {\tt VertexOnSupportVertex} \\
   \Int{NbOfVertexOnSupportVertex}\\
\Loop{\Vertex{$_i$}\,,\,\Vertex{$_i^{supp}$}}{i=1,NbOfVertexOnSupportVertex}

\item {\tt VertexOnSupportEdge} \\
   \Int{NbOfVertexOnSupportEdge}\\
\Loop{\Vertex{$_i$}\,,\,\Edge{$_i^{supp}$}\,,\,  \mbox{\Real{$u_i^{supp}$}}  }{i=1,NbOfVertexOnSupportEdge}

\item {\tt VertexOnSupportTriangle} \\
   \Int{NbOfVertexOnSupportTriangle}\\
\Loop{\Vertex{$_i$}\,,\,\Triangle{$_i^{supp}$}\,,\,
  \mbox{\Real{$u_i^{supp}$}}\,,\,  \mbox{\Real{$v_i^{supp}$}}  }
{\\ \hbox to 3cm {} i=1\,,\,{NbOfVertexOnSupportTriangle}}


\item {\tt VertexOnSupportQuadrilaterals} \\
   \Int{NbOfVertexOnSupportQuadrilaterals}\\
\Loop{\Vertex{$_i$}\,,\,\Quadrangle{$_i^{supp}$}\,,\,
  \mbox{\Real{$u_i^{supp}$}}\,,\,  \mbox{\Real{$v_i^{supp}$}}  }
{\\ \hbox to 3cm {} i=1\,,\,{NbOfVertexOnSupportQuadrilaterals}}


\end{itemize}

\end{itemize}
\normalsize



\subsection {bb File type for Store Solutions}
The file is formatted such that:
{\tt \obeylines
   2 nbsol nbv 2 
  $\left(\left(\mathtt{U}_{ij}, \quad \forall i \in \{1,...,\mathtt{nbsol}\}\right), \quad \forall j \in \{1,...,\mathtt{nbv}\}\right)$
 } 

where 
\begin{itemize}
\item {\tt  nbsol} is a integer equal to  the number of solutions.
\item  {\tt nbv} is  a integer equal to the number of vertex .
\item  {\tt U$_{ij}$} is a real equal the value of the $i$ solution at vertex $j$
on the associated mesh background if read file, generated if write file.
\end{itemize}
 
\subsection {BB File Type for Store Solutions}
The file is formatted such that:
{\tt \obeylines
  $ \mathtt{ \quad 2 \quad n \quad typesol^1 \quad ... \quad typesol^n \quad  nbv \quad 2}  $
  $\left(\left(\left( \mathtt{U}_{ij}^k, \quad \forall i \in \{1,...,\mathtt{typesol}^k\}\right), %
\quad \forall k \in \{1,...\mathtt{n}\}\right) %
 \quad \forall j \in \{1,...,\mathtt{nbv}\}\right)$
 } 

where 
\begin{itemize}
\item {\tt  n} is a integer equal to  the number of solutions 
\item $\mathtt{  typesol^k}$, type of the solution  number $ k$, is
  \begin{itemize}
   \item $\mathtt{typesol^k = 1}$ the solution {\tt k} is scalare  (1  value per vertex)
   \item $\mathtt{typesol^k = 2}$ the solution {\tt k} is vectorial  (2 values per unknown)
   \item $\mathtt{typesol^k = 3}$ the solution {\tt k} is a  $2 2$ symmetric matrix  (3 values per vertex)
   \item $\mathtt{typesol^k = 4}$ the solution  {\tt k} is a  $2 2$ matrix  (4 values per vertex)
   \end{itemize}

\item  {\tt nbv} is  a integer equal to the number of vertices
\item  {\tt U$_{ij}^k$} is a real equal the value of the component  $i$ of the solution  $k$ at vertex $j$
on the associated mesh background if read file, generated if write file.
\end{itemize}


\subsection{Metric File}
 A metric file can be of two types, isotropic or anisotropic.
\label{Metric file}

the isotrope file is such that  
{\tt \obeylines
   nbv  1 
   h$_i \quad \forall i \in \{1,...,\mathtt{nbv}\}$
}


where
\begin{itemize}
\item {\tt  nbv} is  a integer equal to the number of vertices.
\item   {\tt h$_i$} is the wanted mesh size near the vertex $i$ on background mesh,
the metric is $\mathcal{M}_i=h_i^{-2} Id$, where $ Id $ is the identity matrix.
\end{itemize}

The metric anisotrope
{\tt \obeylines
   nbv  3 
   a11$_i$,a21$_i$,a22$_i \quad \forall i \in \{1,...,\mathtt{nbv}\}$
}


where
\begin{itemize}
\item   {\tt nbv} is  a integer equal to the number of vertices,
\item  a11$_i$, a12$_i$, a22$_i$ is metric 
$\mathcal{M}_i = \left(\begin{smallmatrix} a11_i & a12_i \\ a12_i & a22_i \end{smallmatrix}\right)$ which define the wanted mesh size 
in a vicinity of  the vertex $i$
such that $h$ in direction $u \in \R^2$ is equal to $ |u|/\sqrt{u\cdot\mathcal{M}_i\, u}$ , where $\cdot$ is the dot product
in $\R^2$, and $|\cdot|$ is the classical norm.

\end{itemize}

\subsection{List of  AM\_FMT, AMDBA Meshes}
 \index{file!am}\index{file!am\_fmt}\index{file!amdba}
 The mesh is only composed of triangles and can be defined with the help of
the following two integers and four arrays:

  \begin{ttlist}
  \item [nbt] is the number of triangles.
  \item [nbv] is the number of vertices.
  
  \item [nu(1:3,1:nbt)] is an integer array giving the three vertex numbers
  
counterclockwise for each triangle.
 
  \item [c(1:2,nbv)]    is a real array giving the two coordinates of each vertex.
  \item [refs(nbv)]     is an integer array giving the reference numbers of the
vertices. 
  \item [reft(nbv)]     is an integer array giving the reference numbers of the 
triangles.
  \end{ttlist}

\paragraph{AM\_FMT Files}\label{AMFMT}
\index{file!am\_fmt}
In fortran the  {\tt am\_fmt}  files are read as follows:

\begin{verbatim}
     open(1,file='xxx.am_fmt',form='formatted',status='old')
       read (1,*) nbv,nbt
       read (1,*)  ((nu(i,j),i=1,3),j=1,nbt)
       read (1,*)  ((c(i,j),i=1,2),j=1,nbv)
       read (1,*)  ( reft(i),i=1,nbt)
       read (1,*)  ( refs(i),i=1,nbv)
     close(1)
\end{verbatim}

\paragraph{AM Files}\label{AM}
\index{file!am}
In fortran the  {\tt am}  files are read as follows:

\begin{verbatim}
     open(1,file='xxx.am',form='unformatted',status='old')
       read (1,*) nbv,nbt
       read (1)  ((nu(i,j),i=1,3),j=1,nbt),
     &   ((c(i,j),i=1,2),j=1,nbv),
     &   ( reft(i),i=1,nbt),
     &   ( refs(i),i=1,nbv)
     close(1)
\end{verbatim}
\paragraph{AMDBA Files}\label{AMDBA}
\index{file!amdba}
In fortran the  {\tt amdba}  files are read as follows:
\begin{verbatim}
     open(1,file='xxx.amdba',form='formatted',status='old')
       read (1,*) nbv,nbt
       read (1,*) (k,(c(i,k),i=1,2),refs(k),j=1,nbv)
       read (1,*) (k,(nu(i,k),i=1,3),reft(k),j=1,nbt)
     close(1)
\end{verbatim}
\paragraph{msh Files}\label{MSH}
\index{file!msh}
First, we add the notions of boundary edges
  \begin{ttlist}
  \item [nbbe] is the number of boundary edge.
  \item [nube(1:2,1:nbbe)] is an integer array giving the two vertex numbers
  \item [refbe(1:nbbe)] is an integer array giving the two vertex numbers
  \end{ttlist} 
In fortran the  {\tt msh}  files are read as follows:
\begin{verbatim}
     open(1,file='xxx.msh',form='formatted',status='old')
       read (1,*) nbv,nbt,nbbe
       read (1,*) ((c(i,k),i=1,2),refs(k),j=1,nbv)
       read (1,*) ((nu(i,k),i=1,3),reft(k),j=1,nbt)
       read (1,*) ((ne(i,k),i=1,2), refbe(k),j=1,nbbe)
     close(1)
\end{verbatim}
\paragraph{ftq Files}\label{FTQ}
\index{file!ftq}
In fortran the  {\tt ftq}  files are read as follows:
\begin{verbatim}
     open(1,file='xxx.ftq',form='formatted',status='old')
      read (1,*) nbv,nbe,nbt,nbq
      read (1,*) (k(j),(nu(i,j),i=1,k(j)),reft(j),j=1,nbe)
      read (1,*) ((c(i,k),i=1,2),refs(k),j=1,nbv)
     close(1)
\end{verbatim}
where   if {\tt  k(j) = 3} then the element $j$  is  a triangle and if {\tt k = 4}
the the element $j$   is a quadrilateral.

\include{addfe}

\appendix
\section{Table of Notations}
Here mathematical expressions and corresponding \freefempp commands are noted.
\subsection{Generalities}
\begin{description}
  \item[$\delta_{ij}$] Kronecker delta ($0$ if $i\neq j$, 1 if $i=j$ for integers $i,j$)
  \item[$\forall$] for all
  \item[$\exists$] there exist
  \item[i.e.] that is
  \item[PDE] partial differential equation (with boundary conditions)
  \item[$\emptyset$] the empty set
  \item[$\N$] the set of integers ($a\in \N\Leftrightarrow \texttt{int a}$);
  ``\texttt{int}'' means \emph{long integer} inside \freefempp
  \item[$\R$] the set of real numbers ($a\in \R\Leftrightarrow \texttt{real a}$)  ;\emph{double} inside \freefempp
  \item[$\C$] the set of complex numbers ($a\in \C\Leftrightarrow \texttt{complex a}$);
  \emph{complex<double>}
  \item[$\R^d$] $d$-dimensional Euclidean space
\end{description}
\subsection{Sets, Mappings, Matrices, Vectors}
Let $E,\, F,\, G$ be three sets and $A$ subset of $E$.
\begin{description}
  \item[$\{x\in E|\; P\}$] the subset of $E$ consisting of the elements possessing the property $P$
  \item[$E\cup F$] the set of elements belonging to $E$ or $F$
  \item[$E\cap F$] the set of elements belonging to $E$ and $F$
  \item[$E\setminus A$] the set $\{x\in E|\; x\not\in A\}$
  \item[$E+F$] $E\cup F$ with $E\cap F=\emptyset$
  \item[$E\times F$] the cartesian product of $E$ and $F$
  \item[$E^n$] the $n$-th power of $E$ ($E^2=E\times E$, $E^n=E\times E^{n-1}$)
  \item[$f:\; E\to F$] the mapping form $E$ into $F$, i.e., 
  $E\ni x\mapsto f(x)\in F$
  \item[$I_E$ or $I$] the identity mapping in $E$,i.e., $I(x)=x\quad \forall x\in E$
  \item[$f\circ g$] for $f:\; F\to G$ and $g:\; E\to F$, 
  $E\ni x\mapsto (f\circ g)(x)=f(g(x))\in G$ (see \refSec{One Variable Functions})
  \item[$f|_A$] the restriction of $f:\; E\to F$ to the subset $A$ of $E$
  \item[$\{a_k\}$] column vector with components $a_k$
  \item[$(a_k)$] row vector with components $a_k$
  \item[$(a_{k})^T$] denotes the transpose of a matrix $(a_{k})$, and 
  is $\{a_{k}\}$
  \item[$\{a_{ij}\}$] matrix with components $a_{ij}$, and $(a_{ij})^T=(a_{ji})$
\end{description}

\subsection{Numbers}
For two real numbers $a,b$
\begin{description}
  \item[\quad]$[a,b]$ is the interval $\{x\in \R|\; a\le x\le b\}$
  \item[\quad]$]a,b]$ is the interval $\{x\in \R|\; a< x\le b\}$
  \item[\quad]$[a,b[$ is the interval $\{x\in \R|\; a\le x< b\}$
  \item[\quad]$]a,b[$ is the interval $\{x\in \R|\; a< x< b\}$
\end{description}

\subsection{Differential Calculus}
\begin{description}
  \item[$\partial f/\partial x$] the partial derivative of $f:\R^d\to \R$ with respect to $x$ (\ttCC{@dx(f)})
  \item[$\nabla f$] the gradient of $f:\Omega\to \R$,i.e., $\nabla f=(\partial f/\partial x,\, \partial f/\partial y)$
  \item[div$\vec{f}$ or $\nabla.\vec{f}$] the divergence of $\vec{f}:\Omega\to \R^d$, i.e., div$\vec{f}=\partial f_1/\partial x+\partial f_2/\partial y$
  \item[$\Delta f$] the Laplacian of $f:\; \Omega\to \R$, i.e.,
  $\Delta f=\partial^2f/\partial x^2+\partial^2 f/\partial y^2$
\end{description}

\subsection{Meshes}
\begin{description}
  \item[$\Omega$] usually denotes a domain on which PDE is defined
  \item[$\Gamma$] denotes the boundary of $\Omega$,i.e., $\Gamma=\partial\Omega
$ (keyword \ttCC{@border}, see \refSec{Border})
  \item[$\mathcal{T}_h$] the triangulation of $\Omega$, i.e., the set of triangles $T_k$, where $h$ stands for mesh size (keyword \ttCC{@mesh}, \ttCC{@buildmesh}, see \refSec{Mesh Generation})
  \item[$n_t$] the number of triangles in $\mathcal{T}_h$ (get by \texttt{Th.nt}, see ``mesh.edp'')
  \item[$\Omega_h$] denotes the approximated domain $\Omega_h=\cup_{k=1}^{n_t}T_k$ of $\Omega$. If $\Omega$ is polygonal domain, then it will be $\Omega=\Omega_h$
  \item[$\Gamma_h$] the boundary of $\Omega_h$
  \item[$n_v$] the number of vertices in $\mathcal{T}_h$ (get by \texttt{Th.nv})
  \item[[$q^iq^j$]] the segment connecting $q^i$ and $q^j$
  \item[$q^{k_1},q^{k_2},q^{k_3}$] the vertices of a triangle $T_k$ with anti-clock direction (get the coordinate of $q^{k_j}$ by 
  (\texttt{Th[k-1][j-1].x, Th[k-1][j-1].y}))
  \item[$I_{\Omega}$] the set $\{i\in \N|\; q^i\not\in \Gamma_h\}$
\end{description}

\subsection{Finite Element Spaces}
\begin{description}
\item[$L^2(\Omega)$] the set 
$\displaystyle{
\left\{w(x,y)\left|\; \int_{\Omega}|w(x,y)|^2dxdy<\infty\right.\right\}
}$
\begin{eqnarray*}
&&\textrm{norm:}\; \| w\|_{0,\Omega}=\left(\int_{\Omega}|w(x,y)|^2dxdy\right)^{1/2}\\
&&\textrm{scalar product:}\; (v,w)=\int_{\Omega}vw
\end{eqnarray*}
\item[$H^1(\Omega)$] the set
$\displaystyle{
\left\{w\in L^2(\Omega)\left|\; \int_{\Omega}
\left(|\partial w/\partial x|^2+|\partial w/\partial y|^2\right)dxdy<\infty\right.\right\}
}$
\begin{eqnarray*}
&&\textrm{norm:}\; \| w\|_{1,\Omega}=\left(\| w\|_{0,\Omega}^2+\|\nabla u\|_{0.\Omega}^2\right)^{1/2}
\end{eqnarray*}
\item[$H^m(\Omega)$] the set
$\displaystyle{
\left\{w\in L^2(\Omega)\left|\; \int_{\Omega}
\frac{\partial^{|\alpha|} w}{\partial x^{\alpha_1}\partial y^{\alpha_2}}\in L^2(\Omega)\quad
\forall \alpha=(\alpha_1,\alpha_2)\in \N^2,\, |\alpha|=\alpha_1+\alpha_2\right.
\right\}
}$
\begin{eqnarray*}
&&\textrm{scalar product:}\; (v,w)_{1,\Omega}=
\sum_{|\alpha|\le m}\int_{\Omega} D^{\alpha}v D^{\alpha}w
\end{eqnarray*}
\item[$H^1_0(\Omega)$]
the set $\left\{w\in H^1(\Omega)\left|\; u=0\quad \textrm{on }\Gamma\right.\right\}$
\item[$L^2(\Omega)^2$] denotes $L^2(\Omega)\times L^2(\Omega)$, and also
$H^1(\Omega)^2=H^1(\Omega)\times H^1(\Omega)$
  \item[$V_h$] denotes the finite element space created by 
  ``\ttCC{@fespace} Vh(Th,*)'' in \freefempp (see \refSec{Finite Elements} for ``*'')
  \item[$\Pi_h f$] the projection of the function $f$ into $V_h$ 
  (``\ttCC{@func f=x\^{}2*y\^{}3; Vh v = f;}'' means \ttCC{v} = $\Pi_h$\ttCC{f})  \item[$\{v\}$] 
  for FE-function $v$ in $V_h$ means the column vector $(v_1,\cdots,v_M)^T$ if
  $v=v_1\phi_1+\cdots+v_M\phi_M$, which is shown by 
  ``\ttCC{@fespace Vh(Th,P2); Vh v; cout << v[] << endl;}''  
\end{description}

\section{Grammar}
\subsection{Keywords}
\bFF
      Cmatrix
      R3  
      bool 
      border 
      break 
      complex 
      continue 
      element
      else
      end 
      fespace
      for 
      func 
      if 
      ifstream 
      include 
      int 
      load      
      macro
      matrix
      mesh 
      ofstream
      problem
      real
      return
      solve
      string 
      vertex
      varf 
      while

\eFF
\subsection{The bison grammar}
\bFF

start:   input @ENDOFFILE;

input:   instructions ;
         
instructions:  instruction   
        | instructions  instruction   ;

list_of_id_args:   
            | id                      
            | id '=' no_comma_expr   
            | @FESPACE id             
            | type_of_dcl id         
            | type_of_dcl '&' id      
            | '[' list_of_id_args ']' 
            | list_of_id_args ',' id                     
            | list_of_id_args ',' '[' list_of_id_args ']' 
            | list_of_id_args ',' id '=' no_comma_expr  
            | list_of_id_args ',' FESPACE id            
            | list_of_id_args ',' type_of_dcl id        
            | list_of_id_args ',' type_of_dcl '&' id ;    

list_of_id1:  id                     
            | list_of_id1 ',' id   ;
         
id: @ID | @FESPACE ; 

list_of_dcls:    @ID                          
              |  @ID '='   no_comma_expr     
              |  @ID  '(' parameters_list ')' 
              |  list_of_dcls ',' list_of_dcls  ;


parameters_list:
           no_set_expr  
        |  @FESPACE  @ID  
        |  @ID '=' no_set_expr        
        | parameters_list ',' no_set_expr
        | parameters_list ',' id '=' no_set_expr ; 

type_of_dcl:   @TYPE 
             | @TYPE '[' @TYPE ']' ;

ID_space:
    @ID                                 
 |  @ID '[' no_set_expr ']'              
 |  @ID '=' no_set_expr                  
 |  '[' list_of_id1 ']'                
 |  '[' list_of_id1 ']' '[' no_set_expr ']'  
 |  '[' list_of_id1 ']' '=' no_set_expr ;
 
ID_array_space:
    @ID '(' no_set_expr ')'              
 |  '[' list_of_id1 ']' '(' no_set_expr ')' ;

fespace: @FESPACE ;

spaceIDa  :      ID_array_space
            |    spaceIDa ',' ID_array_space  ;
            
spaceIDb  :      ID_space 
            |    spaceIDb ',' ID_space ;

spaceIDs :    fespace               spaceIDb    
           |  fespace '[' @TYPE ']'  spaceIDa    ;

fespace_def: @ID '(' parameters_list ')' ;
     
fespace_def_list:  fespace_def
                 | fespace_def_list ',' fespace_def ;


declaration:   type_of_dcl list_of_dcls ';' 
             | 'fespace' fespace_def_list    ';' 
             | spaceIDs ';'
             | @FUNCTION @ID '=' Expr ';' 
             | @FUNCTION type_of_dcl @ID  '(' list_of_id_args ')'  '{' instructions'}'                     
             | @FUNCTION @ID '(' list_of_id_args ')'   '='   no_comma_expr  ';'     ;              

begin: '{'  ;
end:   '}'  ;

for_loop:    'for'   ;  
while_loop:  'while' ;

instruction:   ';' 
         | 'include'  @STRING  
         | 'load'  @STRING           
         |  Expr  ';' 
         |  declaration  
         |  for_loop  '(' Expr ';' Expr ';' Expr ')' instruction  
         |  while_loop '(' Expr ')' instruction 
         |  'if' '(' Expr ')'   instruction  
         |  'if' '(' Expr ')'   instruction  ELSE instruction 
         |  begin  instructions end 
         |  'border'  @ID   border_expr 
         |  'border'   @ID   '['  array ']' ';'                               
         |  'break'  ';' 
         |  'continue'  ';' 
         |  'return'  Expr ';'  ;


bornes: '(' @ID '=' Expr ',' Expr ')' ;

border_expr:   bornes instruction  ;

Expr:    no_comma_expr 
       | Expr ',' Expr ;

        
unop:     '-' 
        | '+' 
        | '!' 
        | '++'     
        | '--'  ;   

no_comma_expr:  
          no_set_expr 
        | no_set_expr '=' no_comma_expr     
        | no_set_expr '+=' no_comma_expr  
        | no_set_expr '-=' no_comma_expr 
        | no_set_expr '*=' no_comma_expr   
        | no_set_expr '/=' no_comma_expr ; 

no_set_expr:
          unary_expr 
        | no_set_expr '*' no_set_expr 
        | no_set_expr '.*' no_set_expr   
        | no_set_expr './' no_set_expr   
        | no_set_expr '/' no_set_expr 
        | no_set_expr '%' no_set_expr 
        | no_set_expr '+' no_set_expr 
        | no_set_expr '-' no_set_expr 
        | no_set_expr '<<' no_set_expr        
        | no_set_expr '>>' no_set_expr        
        | no_set_expr '&' no_set_expr 
        | no_set_expr '&&' no_set_expr        
        | no_set_expr '|' no_set_expr 
        | no_set_expr '||' no_set_expr      
        | no_set_expr '<' no_set_expr 
        | no_set_expr '<=' no_set_expr        
        | no_set_expr '>' no_set_expr 
        | no_set_expr '>=' no_set_expr         
        | no_set_expr '==' no_set_expr       
        | no_set_expr '!=' no_set_expr ;       

    
parameters:  
        |   no_set_expr 
        |   @FESPACE  
        |   id '=' no_set_expr 
        |   parameters ',' @FESPACE 
        |   parameters ',' no_set_expr 
        |   parameters ',' id '=' no_set_expr ; 

array:   no_comma_expr 
       | array ',' no_comma_expr ;
     
    
unary_expr:
    pow_expr   
  | unop  pow_expr %prec UNARY ;   

pow_expr: primary
  |      primary  '^' unary_expr   
  |      primary  '_' unary_expr  
  |      primary '\''  ;    //  transpose \index{transpose}

primary:  
           @ID           
  |        @LNUM         
  |        @DNUM         
  |        @CNUM         
  |        @STRING 
  |        primary '('  parameters ')'  
  |        primary '[' Expr ']'        
  |        primary '['  ']'        
  |        primary '.'  ID       
  |        primary '++'      
  |        primary '--'     
  |        TYPE '('  Expr ')' ;
  |        '(' Expr ')' 
  |        '[' array  ']' ;

\eFF
\subsection{The Types of the languages, and cast}
%\begin{verbatim}
% the types 
% --lgElement =  <lgElement>
%    [,  type :<Polymorphic>
%   operator : 
%   (    <lgVertex> :   <lgElement>, <long> )

%
% --lgVertex =  <lgVertex>
%    label,  type :<Polymorphic>
%   operator. : 
%   (    <long> :   <lgVertex> )

%    x,  type :<Polymorphic>
%   operator. : 
%   (    <double> :   <lgVertex> )

%    y,  type :<Polymorphic>
%   operator. : 
%   (    <double> :   <lgVertex> )

% --Add_KN_<double> =  <Add_KN_<double>>

% --Add_Mulc_KN_<double> * =  <Add_Mulc_KN_<double>>

% --AnyTypeWithOutCheck =  <AnyTypeWithOutCheck>

% --C_F0 =  <C_F0>

% --DotStar_KN_<double> =  <DotStar_KN_<double>>

% --E_Array =  <E_Array>

% --FEbase<double> * =  <FEbase<double>>
%    <FEbase<double>> :   <FEbase<double>> 
% --FEbase<double> ** =  <FEbase<double> **>

% --FEbaseArray<double> * =  <FEbaseArray<double>>

% --FEbaseArray<double> ** =  <FEbaseArray<double> **>
%    []  type :<Polymorphic>   operator : 
%   (    <FEbase<double> **> :   <FEbaseArray<double> **>, <long> )

%
% --Fem2D::Mesh * =  <Fem2D::Mesh>
%    <Fem2D::Mesh> :   <Fem2D::Mesh **> 
% --Fem2D::Mesh ** =  <Fem2D::Mesh **>
%    <-,  type :<Polymorphic>
%   (    <Fem2D::Mesh> :   <string> )
%   (    <long> :   <Fem2D::Mesh **>, <double>, <double> )

%    area,  type :<Polymorphic>   operator. : 
%   (    <double> :   <Fem2D::Mesh **> )

%    nt,  type :<Polymorphic>
%   operator. : 
%   (    <long> :   <Fem2D::Mesh **> )

%    nv,  type :<Polymorphic>   operator. : 
%   (    <long> :   <Fem2D::Mesh **> )

%
% --Fem2D::MeshPoint * =  <Fem2D::MeshPoint>
%    N,  type :<Polymorphic>   operator. : 
%   (    <Fem2D::R3> :   <Fem2D::MeshPoint> )

%    P,  type :<Polymorphic>   operator. : 
%   (    <Fem2D::R3> :   <Fem2D::MeshPoint> )

%
% --Fem2D::R2 * =  <Fem2D::R2>

% --Fem2D::R3 * =  <Fem2D::R3>
%    x,  type :<Polymorphic>   operator. : 
%   (    <double *> :   <Fem2D::R3> )

%    y,  type :<Polymorphic>   operator. : 
%   (    <double *> :   <Fem2D::R3> )

%    z,  type :<Polymorphic>   operator. : 
%   (    <double *> :   <Fem2D::R3> )

%
% --Fem2D::TypeOfFE * =  <Fem2D::TypeOfFE>

% --KN<double> =  <KN<double>>
%    []  type :<Polymorphic>   operator : 
%   (    <double *> :   <KN<double>>, <long> )

%
% --KN<double> * =  <KN<double> *>
%    <-,  type :<Polymorphic>   
%   (    <KN<double> *> :   <KN<double> *>, <long> )

%    []  type :<Polymorphic>   operator : 
%   (    <double *> :   <KN<double> *>, <long> )

%    max,  type :<Polymorphic>   operator. : 
%   (    <double> :   <KN<double> *> )

%    min,  type :<Polymorphic>   operator. : 
%   (    <double> :   <KN<double> *> )

%    n,  type :<Polymorphic>
%   operator. : 
%   (    <long> :   <KN<double> *> )

%    sum,  type :<Polymorphic>   operator. : 
%   (    <double> :   <KN<double> *> )

%
% --KN_<double> =  <KN_<double>>

% --KN_<double> * =  <KN_<double> *>

% --Matrice_Creuse<double> * =  <Matrice_Creuse<double>>
%    <Matrice_Creuse<double>> :   <Problem> 
% --Matrice_Creuse_Transpose<double> =  <Matrice_Creuse_Transpose<double>>

% --Matrice_Creuse_inv<double> =  <Matrice_Creuse_inv<double>>

% --Mulc_KN_<double> =  <Mulc_KN_<double>>

% --MyMap<String, double> * =  <MyMap<String, double>>
%    []  type :<Polymorphic>   operator : 
%   (    <double *> :   <MyMap<String, double>>, <string> )

%
% --Polymorphic * =  <Polymorphic>

% --Sub_KN_<double> =  <Sub_KN_<double>>

% --Transpose<KN<double>> =  <Transpose<KN<double>>>

% --TypeSolveMat * =  <TypeSolveMat>

% --VirtualMatrice<double>::plusAtx =  <VirtualMatrice<double>::plusAtx>

% --VirtualMatrice<double>::plusAx =  <VirtualMatrice<double>::plusAx>

% --VirtualMatrice<double>::solveAxeqb =  <VirtualMatrice<double>::solveAxeqb>

% --bool =  <bool>
%    <bool> :   <bool *> 
% --bool * =  <bool *>

% --char * =  <char>

% --const BC_set<double> * =  <BC_set<double>>

% --const CDomainOfIntegration * =  <CDomainOfIntegration>
%    ()  type :<Polymorphic>   operator : 
%   (    <FormBilinear> :   <CDomainOfIntegration>, <LinearComb<std::pair<MGauche, MDroit>, C_F0>> )
%   (    <double> :   <CDomainOfIntegration>, <double> )
%   (    <FormLinear> :   <CDomainOfIntegration>, <LinearComb<MDroit, C_F0>> )

%
% --const C_args * =  <C_args>
%    <C_args> :   <FormBilinear>     ()  type :<Polymorphic>   operator : 
%   (    <Call_FormLinear> :   <C_args>, <long>, <v_fes **> )
%   (    <Call_FormBilinear> :   <C_args>, <v_fes **>, <v_fes **> )

%
% --const Call_FormBilinear * =  <Call_FormBilinear>

% --const Call_FormLinear * =  <Call_FormLinear>

% --const E_Border * =  <E_Border>

% --const E_BorderN * =  <E_BorderN>

% --const Fem2D::QuadratureFormular * =  <Fem2D::QuadratureFormular>

% --const Fem2D::QuadratureFormular1d * =  <Fem2D::QuadratureFormular1d>

% --const FormBilinear * =  <FormBilinear>
%    ()  type :<Polymorphic>   operator : 
%   (    <Call_FormBilinear> :   <FormBilinear>, <v_fes **>, <v_fes **> )
%   (    <Call_FormLinear> :   <FormBilinear>, <long>, <v_fes **> )

%
% --const FormLinear * =  <FormLinear>
%    ()  type :<Polymorphic>   operator : 
%   (    <Call_FormLinear> :   <FormLinear>, <v_fes **> )

%
% --const IntFunction * =  <IntFunction>

% --const LinearComb<MDroit, C_F0> * =  <LinearComb<MDroit, C_F0>>

% --const LinearComb<MGauche, C_F0> * =  <LinearComb<MGauche, C_F0>>

% --const LinearComb<std::pair<MGauche, MDroit>, C_F0> * =  <LinearComb<std::pair<MGauche, MDroit>, C_F0>>

% --const Problem * =  <Problem>

% --const Solve * =  <Solve>

% --const char * =  <char>

% --double =  <double>
%    <double> :   <double *>     ()  type :<Polymorphic>   operator : 
%   (    <double> :   <double>, <double>, <double> )

%
% --double * =  <double *>

% --interpolate_f_X_1<double>::type =  <interpolate_f_X_1<double>::type>

% --long =  <long>
%    <long> :   <long *> 
% --long * =  <long *>

% --istream * =  <istream>
%    <istream> :   <istream **> 
% --istream ** =  <istream **>

% --ostream * =  <ostream>
%    <ostream> :   <ostream **> 
% --ostream ** =  <ostream **>
%    <-,  type :<Polymorphic>   operator( ): 
%   (    <ostream> :   <string> )

%
% --string * =  <string>
%    <string> :   <string **> 
% --string ** =  <string **>

% --std::complex<double> =  <complex>
%    <complex> :   <complex *> 
% --std::complex<double> * =  <complex *>

% --std::ios_base::openmode =  <std::ios_base::openmode>

% --std::pair<FEbase<double> *, int> =  <std::pair<FEbase<double> *, int>>
%    (),  type :<Polymorphic>   operator : 
%   (    <double> :   <std::pair<FEbase<double> *, int>>, <double>, <double> )
%   (    <interpolate_f_X_1<double>::type> :   <std::pair<FEbase<double> *, int>>, <E_Array> )

%    [],  type :<Polymorphic>  operator. : 
%   (    <KN<double> *> :   <std::pair<FEbase<double> *, int>> )

%    n,  type :<Polymorphic>   operator. : 
%   (    <long> :   <std::pair<FEbase<double> *, int>> )
% --std::pair<FEbaseArray<double> *, int> =  <std::pair<FEbaseArray<double> *, int>>
%    []  type :<Polymorphic>
%   operator : 
%   (    <std::pair<FEbase<double> *, int>> :   <std::pair<FEbaseArray<double> *, int>>, <long> )
% --std::pair<Fem2D::Mesh **, int> * =  <std::pair<Fem2D::Mesh **, int>>
% --v_fes * =  <v_fes>
%    <v_fes> :   <v_fes **> 
% --v_fes ** =  <v_fes **>

% --void =  <void>
%\end{verbatim}

\subsection{All the operators}
\begin{verbatim}
  - CG,  type :<TypeSolveMat>
  - Cholesky,  type :<TypeSolveMat>
  - Crout,  type :<TypeSolveMat>
  - GMRES,  type :<TypeSolveMat>
  - LU,  type :<TypeSolveMat>
  - LinearCG,  type :<Polymorphic>   operator() : 
   (    <long> :   <Polymorphic>, <KN<double> *>, <KN<double> *> )

  - N,  type :<Fem2D::R3>
  - NoUseOfWait,  type :<bool *>
  - P,  type :<Fem2D::R3>
  - P0,  type :<Fem2D::TypeOfFE>
  - P1,  type :<Fem2D::TypeOfFE>
  - P1nc,  type :<Fem2D::TypeOfFE>
  - P2,  type :<Fem2D::TypeOfFE>
  - RT0,  type :<Fem2D::TypeOfFE>
  - RTmodif,  type :<Fem2D::TypeOfFE>
  - abs,  type :<Polymorphic>  operator() : 
   (    <double> :   <double> )

  - acos,  type :<Polymorphic>   operator() : 
   (    <double> :   <double> )

  - acosh,  type :<Polymorphic>   operator() : 
   (    <double> :   <double> )

  - adaptmesh,  type :<Polymorphic>   operator() : 
   (    <Fem2D::Mesh> :   <Fem2D::Mesh>... )

  - append,  type :<std::ios_base::openmode>
  - asin,  type :<Polymorphic>   operator() : 
   (    <double> :   <double> )

  - asinh,  type :<Polymorphic>  operator() : 
   (    <double> :   <double> )

  - atan,  type :<Polymorphic>   operator() : 
   (    <double> :   <double> )
   (    <double> :   <double>, <double> )

  - atan2,  type :<Polymorphic>   operator() : 
   (    <double> :   <double>, <double> )

  - atanh,  type :<Polymorphic>   operator() : 
   (    <double> :   <double> )

  - buildmesh,  type :<Polymorphic>   operator() : 
   (    <Fem2D::Mesh> :   <E_BorderN> )

  - buildmeshborder,  type :<Polymorphic>   operator() : 
   (    <Fem2D::Mesh> :   <E_BorderN> )

  - cin,  type :<istream>
  - clock,  type :<Polymorphic>   
   (    <double> :   )

  - conj,  type :<Polymorphic>   operator() : 
   (    <complex> :   <complex> )

  - convect,  type :<Polymorphic>   operator() : 
   (    <double> :   <E_Array>, <double>, <double> )

  - cos,  type :<Polymorphic>  operator() : 
   (    <double> :   <double> )
   (    <complex> :   <complex> )

  - cosh,  type :<Polymorphic>   operator() : 
   (    <double> :   <double> )
   (    <complex> :   <complex> )

  - cout,  type :<ostream>
  - dumptable,  type :<Polymorphic>   operator() : 
   (    <ostream> :   <ostream> )

  - dx,  type :<Polymorphic>   operator() : 
   (    <LinearComb<MDroit, C_F0>> :   <LinearComb<MDroit, C_F0>> )
   (    <double> :   <std::pair<FEbase<double> *, int>> )
   (    <LinearComb<MGauche, C_F0>> :   <LinearComb<MGauche, C_F0>> )

  - dy,  type :<Polymorphic>   operator() : 
   (    <LinearComb<MDroit, C_F0>> :   <LinearComb<MDroit, C_F0>> )
   (    <double> :   <std::pair<FEbase<double> *, int>> )
   (    <LinearComb<MGauche, C_F0>> :   <LinearComb<MGauche, C_F0>> )

  - endl,  type :<char>
  - exec,  type :<Polymorphic>   operator() : 
   (    <long> :   <string> )

  - exit,  type :<Polymorphic>  operator() : 
   (    <long> :   <long> )

  - exp,  type :<Polymorphic>  operator() : 
   (    <double> :   <double> )
   (    <complex> :   <complex> )

  - false,  type :<bool>
  - imag,  type :<Polymorphic>   operator() : 
   (    <double> :   <complex> )

  - int1d,  type :<Polymorphic>   operator() : 
   (    <CDomainOfIntegration> :   <Fem2D::Mesh>... )

  - int2d,  type :<Polymorphic>   operator() : 
   (    <CDomainOfIntegration> :   <Fem2D::Mesh>... )

  - intalledges,  type :<Polymorphic>
   operator( : 
   (    <CDomainOfIntegration> :   <Fem2D::Mesh>... )

  - jump,  type :<Polymorphic>
   operator( : 
   (    <LinearComb<MDroit, C_F0>> :   <LinearComb<MDroit, C_F0>> )
   (    <double> :   <double> )
   (    <complex > :   <complex > )
   (    <LinearComb<MGauche, C_F0>> :   <LinearComb<MGauche, C_F0>> )

  - label,  type :<long *>
  - log,  type :<Polymorphic>   operator() : 
   (    <double> :   <double> )
   (    <complex> :   <complex> )

  - log10,  type :<Polymorphic>   operator() : 
   (    <double> :   <double> )

  - max,  type :<Polymorphic>   operator() : 
   (    <double> :   <double>, <double> )
   (    <long> :   <long>, <long> )

  - mean,  type :<Polymorphic>
   operator( : 
   (    <double> :   <double> )
   (    <complex> :   <complex> )

  - min,  type :<Polymorphic>  operator() : 
   (    <double> :   <double>, <double> )
   (    <long> :   <long>, <long> )

  - movemesh,  type :<Polymorphic>   operator() : 
   (    <Fem2D::Mesh> :   <Fem2D::Mesh>, <E_Array>... )

  - norm,  type :<Polymorphic>
   operator( : 
   (    <double> :   <std::complex<double>> )

  - nuTriangle,  type :<long>
  - nuEdge,  type :<long>
  - on,  type :<Polymorphic>   operator() : 
   (    <BC_set<double>> :   <long>... )

  - otherside,  type :<Polymorphic>
   operator( : 
   (    <LinearComb<MDroit, C_F0>> :   <LinearComb<MDroit, C_F0>> )
   (    <LinearComb<MGauche, C_F0>> :   <LinearComb<MGauche, C_F0>> )

  - pi,  type :<double>
  - plot,  type :<Polymorphic>   operator() : 
   (    <long> :  ... )

  - pow,  type :<Polymorphic>   operator() : 
   (    <double> :   <double>, <double> )
   (    <complex> :   <complex>, <complex> )

  - qf1pE,  type :<Fem2D::QuadratureFormular1d>
  - qf1pT,  type :<Fem2D::QuadratureFormular>
  - qf1pTlump,  type :<Fem2D::QuadratureFormular>
  - qf2pE,  type :<Fem2D::QuadratureFormular1d>
  - qf2pT,  type :<Fem2D::QuadratureFormular>
  - qf2pT4P1,  type :<Fem2D::QuadratureFormular>
  - qf3pE,  type :<Fem2D::QuadratureFormular1d>
  - qf5pT,  type :<Fem2D::QuadratureFormular>

  - readmesh,  type :<Polymorphic>   operator() : 
   (    <Fem2D::Mesh> :   <string> )

  - real,  type :<Polymorphic>   operator() : 
   (    <double> :   <complex> )

  - region,  type :<long *>
  - savemesh,  type :<Polymorphic>  operator() : 
   (    <Fem2D::Mesh> :   <Fem2D::Mesh>, <string>... )

  - sin,  type :<Polymorphic>   operator() : 
   (    <double> :   <double> )
   (    <complex> :   <complex> )

  - sinh,  type :<Polymorphic>   operator() : 
   (    <double> :   <double> )
   (    <complex> :   <complex> )

  - sqrt,  type :<Polymorphic>   operator() : 
   (    <double> :   <double> )
   (    <complex> :   <complex> )

  - square,  type :<Polymorphic>    operator() : 
   (    <Fem2D::Mesh> :   <long>, <long> )
   (    <Fem2D::Mesh> :   <long>, <long>, <E_Array> )

  - tan,  type :<Polymorphic>   operator() : 
   (    <double> :   <double> )

  - true,  type :<bool>
  - trunc,  type :<Polymorphic>   operator() : 
   (    <Fem2D::Mesh> :   <Fem2D::Mesh>, <bool> )

  - verbosity,  type :<long *>
  - wait,  type :<bool *>
  - x,  type :<double *>
  - y,  type :<double *>
  - z,  type :<double *>    
\end{verbatim}

%%%\subsection{History of the software}
%%%{\scriptsize
%%%\inputFF{../HISTORY}
%%%}

\begin{thebibliography}{xx}

\bibitem{arpack} R. B. Lehoucq, D. C. Sorensen, and C. Yang
{\it ARPACK Users' Guide: Solution of Large-Scale Eigenvalue Problems with Implicitly Restarted Arnoldi Methods}
SIAM,  ISBN 0-89871-407-9 //
 \url{http://www.caam.rice.edu/software/ARPACK/}

\bibitem{Babuska71} 
Babbu\v{s}ka, I: Error bounds for finite element method, Numer. Math. 16, 322-333.

\bibitem{freefemp} D. Bernardi, F.Hecht, K. Ohtsuka, O. Pironneau: {\it
freefem+ documentation}, on the web at  ftp://www.freefem.org/freefemplus.

\bibitem{freefem} D. Bernardi, F.Hecht, O. Pironneau, C. Prud'homme: {\it
freefem documentation}, on the web at  http://www.asci.fr


\bibitem{umfpack} 
Davis, T. A:  {Algorithm 8xx: UMFPACK V4.1, an unsymmetric-pattern multifrontal method}
TOMS, 
2003 (under submission)
 \url{ http://www.cise.ufl.edu/research/sparse/umfpack}

\bibitem{George}
George, P.L: {\it Automatic triangulation}, Wiley 1996.

\bibitem{bamg}
Hecht, F: The mesh adapting software: bamg. INRIA report 1998.

\bibitem{modulef}
Modulef  ?????????

\bibitem{Lions} 
J.L. Lions, O. Pironneau:
Parallel Algorithms for boundary value problems, Note CRAS. Dec 1998.
Also : Superpositions for composite domains (to appear)

\bibitem{Lucquin} B. Lucquin, O. Pironneau: {\it Introduction to Scientific Computing}
Wiley 1998.

\bibitem{Necas} J. Ne\v{c}as and L/ Hlav\'{a}\v{c}ek, 
Mathematical theory of elastic and elasto-plastic bodies:
An introduction, Elsevier, 1981.

\bibitem{Ohtsuka} K. Ohtsuka, O. Pironneau and F. Hecht: Theoretical and Numerical analysis of energy release rate in 2D fracture, INFORMATION \textbf{3} (2000), 303--315.

\bibitem{Preparata} F. Preparata, M. Shamos; {\it Computational Geometry}
Springer series in Computer sciences, 1984.

\bibitem{Franca}R. Rannacher: On Chorin's projection method for the incompressible
Navier-Stokes equations, in "Navier-Stokes Equations: Theory and Numerical Methods" (R.
Rautmann, et al., eds.), Proc. Oberwolfach Conf., August 19-23, 1991, Springer, 1992

\bibitem{RT93}
Roberts, J.E. and Thomas J.-M: Mixed and Hybrid Methods, Handbook of Numerical Anaysis, Vol.II, North-Holland, 1993

\bibitem{Steger} J.L. Steger: The Chimera method of flow simulation,
Workshop on applied CFD, Univ of Tennessee Space Institute, August 1991.

\bibitem{TA94}
Tabata, M: Numerical solutions of partial differential equations II 
(in Japanese), 
Iwanami Applied Math., 1994

\bibitem{Thomasset} 
Thomasset, F: Implementation of finite element methods
of Navier-Stokes Equations, Springer-Verlag, 1981

\bibitem{wirth} {\sc N. Wirth:} {\it Algorthims + Data Structures = Programs}, Prentice Hall,  1976


\bibitem{Bison}  Bison documentation 

\bibitem{cpp}  
Bjarne Stroustrup:
The \Cpp, programming language, Third edition, 
  Addison-Wesley 1997.
 
\bibitem{coool} COOOL: a package of tools for writing optimization code and solving optimization problems,

\bibitem{DGgirault}  B. Riviere, M.   Wheeler, V. Girault,
A priori error estimates for finite element
 methods based on discontinuous approximation spaces
 for elliptic problems.
  SIAM J. Numer. Anal. 39 (2001), no. 3, 902--931 (electronic).

\bibitem{COOLL} COOL package , \url{http://coool.mines.edu}
  
\bibitem{0501496} {\sc M. A. Taylor,  B. A. 
Wingate  , L. P. Bos},  Several new quadrature formulas for polynomial integration in the triangle , Report-no: SAND2005-0034J, 
 \url{http://xyz.lanl.gov/format/math.NA/0501496}
\end{thebibliography}
\printindex
\end{document}
\