\documentclass[twoside]{book}
\newif\ifpdf
\ifx\pdfoutput\undefined
\pdffalse % we are not running PDFLaTeX
\else
\pdfoutput=1 % we are running PDFLaTeX
\pdftrue
\fi
%\usepackage{times}
%\usepackage{amsmath}
\usepackage{calc}
\usepackage[latin1]{inputenc}
\usepackage{FFF}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{FFF}
\usepackage{makeidx}
\usepackage{color}
\usepackage{multicol}
\usepackage{graphicx}
%\usepackage{dessin}
\topmargin -1.54cm
\oddsidemargin 0cm   %marge a 2 cm
\evensidemargin 0cm  %marge a 2 cm
\newcommand{\indente}{\hbox to \parindent {\hss}}
\parindent 0cm
\headsep 0.5cm
\topskip .5cm
\footskip 1cm
\headheight 1.0cm
\textwidth  16.5cm
%  \parindent 0cm
\textheight 24cm
\def\freefempp{\texttt{freefem++ }}
\def\textRed{\color{red}}
\def\textBlack{\color{black}}
\def\Blue#1{\textcolor{blue}{#1}}
\def\Black#1{\textcolor{black}{#1}}
\def\Red#1{\textcolor{red}{#1}}
\def\Magenta#1{\textcolor{magenta}{#1}}
\def\hin{\hbox{ in }}
\def\hon{\hbox{ on }}
\def\Cpp{\texttt{C++~}}
\def\R{\mathrm{I\!R}}
\def\example{\textbf{Example:}}
\def\eq#1{\Blue{\[#1\]}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\itemtt[#1]{ \item[\texttt{#1}]}
\def\plot[#1]#2#3{\begin{figure}[hbt]
\begin{center}
    \includegraphics*[#1]{#2}
\end{center}
\caption{\label{#2} #3}
\end{figure}
}
\def\Ostream{\texttt{ostream}}
\def\Istream{\texttt{istream}}
\def\Bool{\texttt{bool}}
\def\Real{\texttt{real}}
\def\Int{\texttt{int}}
\def\vecttwo#1#2{\left|\begin{smallmatrix} #1 \\ #2 \end{smallmatrix}\right.}
\def\vdeux(#1,#2){\left|\begin{smallmatrix} #1 \\ #2 \end{smallmatrix}\right.}
\def\HLINE#1{\hbox to \hsize {#1}}
\def\twoplot[#1]#2#3#4#5{
\begin{figure}[hbt]
\begin{multicols}{2}
\begin{center}
    \includegraphics*[#1]{#2}
    \caption{\label{#2} #4}
\end{center}
\begin{center}
    \includegraphics*[#1]{#3}
    \caption{\label{#3} #5}
\end{center}
\end{multicols}
\end{figure}
}% end twoplot macro
\newtheorem{remark}{\textbf{Remark}}
\newtheorem{bug}{\textbf{Bug:}}
\newtheorem{proposition}{\textbf{Proposition}}
\newtheorem{algorithm}{\textbf{Algorithm}}
\newenvironment{ttlist}
   {\begin{list}{}{\renewcommand{\makelabel}[1]{\texttt{##1}\hfil}%
        \setlength{\labelwidth}{3cm}
        \setlength{\leftmargin}{\labelwidth+\labelsep}
    }}%
   {\end{list}}


\begin{document}
\graphicspath{{./}{plots/}}
\ifpdf
\DeclareGraphicsExtensions{.pdf, .jpg, .tif}
\else
\DeclareGraphicsExtensions{.eps,.ps, .jpg}
\fi

\let\subsubsection\subsection
\let\subsection\section
\let\section\chapter

\medskip



The driven cavity flow problem is solved first at zero Reynolds number
(Stokes flow) and then at Reynolds 100.  \index{fluid}The
velocity pressure formulation is used first and then the calculation
is repeated with the stream function vorticity formulation.


The driven cavity problem is the problem (\ref{eq Stokes}) \index{Stokes} where
 $u_{\Gamma}\cdot n=0$ and $u_{\Gamma}\cdot s
=1$ on the top boundary and zero elsewhere ( $n$ is  the $\Gamma$ normal, and
 $s$ is the $\Gamma$ tangent).
\\
The mesh is constructed by
\bFF

mesh Th=square(8,8);
\eFF

The labels assigned by \texttt{square}
to the bottom,right,up and left edges are respectively $1,2,3,4$.

We use a classical Taylor-Hood element technic to solve the problem:
\\\\
The velocity is approximated with the $P_{2}$ FE ( $X_{h}$ space), and the
the pressure is approximated with the $P_{1}$ FE ( $M_{h}$ space),
\\\\
where
\Blue{
$$  X_{h} = \{ v \in H^{1}(]0,1[^2) / \forall K \in \mathcal{T}_{h}
\quad v_{|K} \in
P_{2} \}$$} and
\Blue{$$  M_{h} = \{ v \in H^{1}(]0,1[^2) / \forall K \in \mathcal{T}_{h}
\quad v_{|K} \in
P_{1} \}$$}

The FE spaces and functions  are constructed by

\bFF

fespace Xh(Th,P2); //  definition of the velocity component space
fespace Mh(Th,P1);  //  definition of the pressure space
Xh u2,v2;
Xh u1,v1;
Xh p,q;
\eFF


The Stokes operator is implemented as a system-solve for the velocity
$(u1,u2)$ and the pressure $p$.  The test function  for the velocity is $(v1,v2)$
and $q$ for the pressure, so the variational form (\ref{eq vf Stokes}) in freefem
language is:
\bFF

solve Stokes (u1,u2,p,v1,v2,q,solver=Crout) =
    int2d(Th)( ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +  dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001)
            + p*dx(v1)+ p*dy(v2)
            + dx(u1)*q+ dy(u2)*q
           )
  + on(3,u1=1,u2=0)
  + on(1,2,4,u1=0,u2=0);
\eFF

Each unknown has its own boundary conditions.
\\\\
{\bf Technical Remark}
There is some arbitrary decision here as to where to affect the
boundary condition within the linear system. Basically the Dirichlet
operator \index{Dirichlet}
(\texttt{on})  should be
associated with the unknown  which contains it so that
the penalization appears on the diagonal
of the matrix of the underlying discrete linear system,
otherwise it will be ill conditioned.
\index{Neumann}

\begin{remark}
Notice the term \texttt{p*q*(0.000001)}  is added, because the  solver
Crout needs it: all the sub-matrices must be invertible.
\end{remark}

If the \index{streamlines}streamlines are required, they can be
computed by finding $\psi$ such that rot$\psi=u$ or better,
\Blue{$$-\Delta\psi=\nabla\times u$$}
\bFF

Xh psi,phi;

solve streamlines(psi,phi) =
      int2d(Th)( dx(psi)*dx(phi) + dy(psi)*dy(phi))
   +  int2d(Th)( -phi*(dy(u1)-dx(u2)))
   +  on(1,2,3,4,psi=0);
\eFF

\bigskip

Now the Navier-Stokes equations are solved
\eq{
    {\partial {u}\over\partial t} +u\cdot\nabla u-\nu \Delta u+\nabla p=0,~~~ \nabla\cdot u=0
}
with the same boundary conditions and with initial conditions $u=0$.

This is implemented by using the convection operator \texttt{convect} for the term
${\partial u\over\partial t} +u\cdot\nabla u$, giving a discretization in time
\Blue{\index{Navier-Stokes}
\begin{equation}
    \label{eq Navier Stokes carac}
\begin{array}{cl}
\frac{1}{\delta t} (u^{n+1}-u^n\circ X^n) -\nu\Delta u^{n+1} + \nabla p^{n+1} &=0,\\
 \nabla\cdot u^{n+1} &= 0
 \end{array}
\end{equation}
}
The term,$u^n\circ X^n(x)\approx u^n(x-u^n(x)\delta t)$ will be
computed by the operator ``convect" \index{convect} , so we obtain
\bFF

int i=0;
real  nu=1./100.;
real dt=0.1;
real alpha=1/dt;

Xh up1,up2;

problem  NS (u1,u2,p,v1,v2,q,solver=Crout,init=i) =
    int2d(Th)(
             alpha*( u1*v1 + u2*v2)
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +  dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001)
            + p*dx(v1)+ p*dy(v2)
            + dx(u1)*q+ dy(u2)*q
           )
  + int2d(Th) ( -alpha*
       convect([up1,up2],-dt,up1)*v1 -alpha*convect([up1,up2],-dt,up2)*v2 )
  + on(3,u1=1,u2=0)
  + on(1,2,4,u1=0,u2=0)
;

for (i=0;i<=10;i++)
 {
   up1=u1;
   up2=u2;
   NS;
   if ( !(i % 10))  // plot every 10 iteration
    plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2]);
 } ;
\eFF

Notice that the matrices are \index{Reusable matrices} reused (keyword
\texttt{init=i})

\subsubsection{StokesUzawa.edp}

In this example we have a full Stokes problem, solve also the cavity problem,
with the
classical \index{Uzawa}\label{Uzawa} Uzawa conjugate gradient.

The idea of the algorithm is very simple, in the first equation of the Stokes problem, if
we know the pressure, when we can compute the velocity $u(p)$, and to solve
the problem is to find $p$, such that $ \nabla. u(p) =0$. The last problem is
linear, symmetric negative, so we can use the conjugate gradient algoritm \index{LinearCG}
.

First we define mesh, and the Taylor-Hood \index{Taylor-Hood}  approximation.
So $X_{h}$  is the velocity space, and $M_{h}$ is the pressure space.

\bFF

mesh Th=square(10,10);
fespace Xh(Th,P2),Mh(Th,P1);
Xh u1,u2,v1,v2;
Mh p,q,ppp;  //  ppp is a working pressure
\eFF

\bFF

varf bx(u1,q) = int2d(Th)( -(dx(u1)*q));
varf by(u1,q) = int2d(Th)( -(dy(u1)*q));
varf a(u1,u2)= int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) )
                    +  on(3,u1=1)  +  on(1,2,4,u1=0) ;
//  remark:  put the on(3,u1=1) before  on(1,2,4,u1=0) 
//  because we want zero on intersection \index{on!intersection}
 
matrix A= a(Xh,Xh,solver=CG);
matrix Bx= bx(Xh,Mh);
matrix By= by(Xh,Mh);

Xh bc1; bc1[] = a(0,Xh);  //  boundary condition contribution  on u1
Xh bc2; bc2   = O ;       //  no boundary condition contribution on u2
Xh b;
\eFF

Construct the function \texttt{divup} $ p \longrightarrow \nabla. u(p) $.
\bFF

func real[int] divup(real[int] & pp)
{
   //  compute u1(pp)
   b[]  = Bx'*pp; b[] += bc1[] ;    u1[] = A^-1*b[];
   //  compute u2(pp)
   b[]  = By'*pp; b[] += bc2[] ;    u2[] = A^-1*b[];
   //  div(u1,u2) = Bx'*u1[] + By'*u2[];
   ppp[] =   Bx*u1[];   // $  ppp= {}^t B_{x} u_{1} $ 
   ppp[] +=  By*u2[];   // $   \quad   +  {}^t B_{y} u_{2} $ 
   return ppp[] ;
};
\eFF


 Call now the conjugate gradient algorithm:

\bFF

p=0;q=0;
LinearCG(divup,p[],eps=1.e-6,nbiter=50);
divup(p[]); // compute the final solution

plot([u1,u2],p,wait=1,value=true,coef=0.1);
\eFF


\end{document}