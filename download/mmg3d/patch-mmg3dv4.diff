>diff -r -u mmg3d4/build/sources/analarcutting.c mmg3d4-new/build/sources/analarcutting.c
--- mmg3d4/build/sources/analarcutting.c	2012-12-19 16:05:32.000000000 +0100
+++ mmg3d4-new/build/sources/analarcutting.c	2013-01-18 16:33:45.000000000 +0100
@@ -307,7 +307,7 @@
     printf("6 cut : %8d\n",n6);
     printf("---------------------------\n"); */
   if ( !na )  return(na);
-#warning check memory allocation
+  // #warning check memory allocation
 
   //printf("%d cut init --- nb tet %d\n",na,mesh->ne);
   return(na);
diff -r -u mmg3d4/build/sources/cutelt.c mmg3d4-new/build/sources/cutelt.c
--- mmg3d4/build/sources/cutelt.c	2012-12-19 16:05:32.000000000 +0100
+++ mmg3d4-new/build/sources/cutelt.c	2013-01-18 16:35:41.000000000 +0100
@@ -305,8 +305,7 @@
 //      }
 //      return(1);
 // }
-int ddebug=0;
-
+extern int ddebug; 
 int MMG_decouphex(pMesh mesh, pHedge hed,int k,int* p,int ref) {
   pTetra  pt;
   int     i,nu1,nu2;
diff -r -u mmg3d4/build/sources/dataff.h mmg3d4-new/build/sources/dataff.h
--- mmg3d4/build/sources/dataff.h	2013-01-18 21:52:48.000000000 +0100
+++ mmg3d4-new/build/sources/dataff.h	2013-01-18 18:50:04.000000000 +0100
@@ -0,0 +1,60 @@
+/*
+ *  dataff.h
+ *  
+ *
+ *  Created by Fr\E9d\E9ric Hecht on 19/06/11.
+ *  Copyright 2011 UPMC. All rights reserved.
+ *
+ 
+ */
+
+enum ff_data_type {
+    ff_id_vertex =0,
+    ff_id_seg =1,
+    ff_id_tria=2,
+    ff_id_tet =3,
+
+    ff_id_prism =5,
+    ff_id_hex =6,
+    ff_id_quad =7,
+    ff_id_corner=8
+} ;
+
+
+typedef struct  DataFF 
+{
+  const char  * meshname;
+  const char  * movename;
+  const char  * solname;
+  int imprim;
+  int memory;
+  int   np; //  nb of vertices  in/out 
+  int   typesol; //  1 iso , 6 : m11; m12,m13,m22,m23,m33
+  void * mesh;
+  double * sol; /* metric :size typesol*np  */
+  double * mov; /* displac. size :3*np  */ 
+  void (*set_mesh)(void *dataff,int *data,int ldata);
+  void (*end_mesh)(void *dataff);
+  void (*set_v)(void *dataff,int i,double *xyz,int lab);
+  void (*set_elmt)(void *dataff,int ff_id,int i,int *k,int lab);
+  void (*get_mesh)(void *dataff,int *data,int ldata);
+  void (*get_v3)(void *dataff,int i,double *xyz,int *lab);
+  void (*get_elmt)(void *dataff,int ff_id,int i,int *k,int *lab);
+} DataFF;
+
+#ifdef __cplusplus
+extern "C" {
+#endif  
+    int mainmmg3d(int argc,char *argv[],DataFF *dataff); 
+
+#ifdef __cplusplus
+}
+#endif 
+/*
+ m11 = met[0] 
+ m12 = met[1] 
+ m13 = met[2] 
+ m22 = met[3]
+ m23 = met[4] 
+ m33 = met[5]  
+*/
diff -r -u mmg3d4/build/sources/delaunay.c mmg3d4-new/build/sources/delaunay.c
--- mmg3d4/build/sources/delaunay.c	2012-12-19 16:05:32.000000000 +0100
+++ mmg3d4-new/build/sources/delaunay.c	2013-01-18 16:32:41.000000000 +0100
@@ -728,7 +728,7 @@
   if ( ppt->tag & M_UNUSED )  return(0);
 
   tref = mesh->tetra[list->tetra[1]/6].ref;
-#warning remove this test
+  // #warning remove this test
   for (k=1; k<=lon; k++)
     if(tref!=mesh->tetra[list->tetra[k]/6].ref)
       printf("pbs coquil %d %d tet %d\n",tref,mesh->tetra[list->tetra[k]/6].ref,list->tetra[k]/6);
diff -r -u mmg3d4/build/sources/libmmg3d.h mmg3d4-new/build/sources/libmmg3d.h
--- mmg3d4/build/sources/libmmg3d.h	2012-12-19 16:05:36.000000000 +0100
+++ mmg3d4-new/build/sources/libmmg3d.h	2013-01-18 16:32:41.000000000 +0100
@@ -118,12 +118,12 @@
 typedef MMG_Sol * MMG_pSol;
 
 /* inout */
-int  MMG_loadMesh(MMG_pMesh ,char *);
-int  MMG_loadSol(MMG_pSol ,char *,int );
-int  MMG_loadVect(MMG_pMesh ,char *,int );
-int  MMG_saveMesh(MMG_pMesh ,char *);
-int  MMG_saveSol(MMG_pMesh ,MMG_pSol ,char *);
-int  MMG_saveVect(MMG_pMesh ,char *);
+int  MMG_loadMesh(MMG_pMesh ,char *,void *);
+int  MMG_loadSol(MMG_pSol ,char *,int ,void *);
+int  MMG_loadVect(MMG_pMesh ,char *,int ,void *);
+int  MMG_saveMesh(MMG_pMesh ,char *,void *);
+int  MMG_saveSol(MMG_pMesh ,MMG_pSol ,char *,void *);
+int  MMG_saveVect(MMG_pMesh ,char *,void *);
 
 #ifdef  __cplusplus
 namespace mmg3d{
diff -r -u mmg3d4/build/sources/mesh.h mmg3d4-new/build/sources/mesh.h
--- mmg3d4/build/sources/mesh.h	2012-12-19 16:05:36.000000000 +0100
+++ mmg3d4-new/build/sources/mesh.h	2013-01-18 16:32:41.000000000 +0100
@@ -405,17 +405,17 @@
 
 /* function pointers */
 typedef int (*MMG_Swap)(pMesh ,pSol ,pList );
-MMG_Swap MMG_swpptr;
-double (*MMG_length)(double *,double *,double *,double *);
-double (*MMG_caltet)(pMesh ,pSol ,int );
-double (*MMG_calte1)(pMesh ,pSol ,int );
-int    (*MMG_caltet2)(pMesh ,pSol ,int ,int ,double ,double *);
-int    (*MMG_cavity)(pMesh ,pSol ,int ,int ,pList ,int );
-int    (*MMG_buckin)(pMesh ,pSol ,pBucket ,int );
-int    (*MMG_optlen)(pMesh ,pSol ,double ,int );
-int    (*MMG_interp)(double *,double *,double *,double );
-int    (*MMG_optlentet)(pMesh ,pSol ,pQueue ,double ,int ,int );
-int    (*MMG_movevertex)(pMesh ,pSol ,int ,int );
+extern MMG_Swap MMG_swpptr;
+extern double (*MMG_length)(double *,double *,double *,double *);
+extern double (*MMG_caltet)(pMesh ,pSol ,int );
+extern double (*MMG_calte1)(pMesh ,pSol ,int );
+extern int    (*MMG_caltet2)(pMesh ,pSol ,int ,int ,double ,double *);
+extern int    (*MMG_cavity)(pMesh ,pSol ,int ,int ,pList ,int );
+extern int    (*MMG_buckin)(pMesh ,pSol ,pBucket ,int );
+extern int    (*MMG_optlen)(pMesh ,pSol ,double ,int );
+extern int    (*MMG_interp)(double *,double *,double *,double );
+extern int    (*MMG_optlentet)(pMesh ,pSol ,pQueue ,double ,int ,int );
+extern int    (*MMG_movevertex)(pMesh ,pSol ,int ,int );
 
 
 #endif
diff -r -u mmg3d4/build/sources/mmg3d4.c mmg3d4-new/build/sources/mmg3d4.c
--- mmg3d4/build/sources/mmg3d4.c	2012-12-19 16:05:33.000000000 +0100
+++ mmg3d4-new/build/sources/mmg3d4.c	2013-01-18 18:28:05.000000000 +0100
@@ -3,32 +3,32 @@
 Co-auteurs : Cecile Dobrzynski et Pascal Frey.
 Propriétaires :IPB - UPMC -INRIA.
 
-Copyright © 2004-2005-2006-2007-2008-2009-2010-2011,
+Copyright © 2004-2005-2006-2007-2008-2009-2010-2011, 
 diffusé sous les termes et conditions de la licence publique générale de GNU
-Version 3 ou toute version ultérieure.
+Version 3 ou toute version ultérieure.  
 
 Ce fichier est une partie de MMG3D.
 MMG3D est un logiciel libre ; vous pouvez le redistribuer et/ou le modifier
 suivant les termes de la licence publique générale de GNU
 Version 3 ou toute version ultérieure.
-MMG3D est distribué dans l'espoir qu'il sera utile, mais SANS
-AUCUNE GARANTIE ; sans même garantie de valeur marchande.
+MMG3D est distribué dans l'espoir qu'il sera utile, mais SANS 
+AUCUNE GARANTIE ; sans même garantie de valeur marchande.  
 Voir la licence publique générale de GNU pour plus de détails.
-MMG3D est diffusé en espérant qu’il sera utile,
-mais SANS AUCUNE GARANTIE, ni explicite ni implicite,
-y compris les garanties de commercialisation ou
-d’adaptation dans un but spécifique.
+MMG3D est diffusé en espérant qu’il sera utile, 
+mais SANS AUCUNE GARANTIE, ni explicite ni implicite, 
+y compris les garanties de commercialisation ou 
+d’adaptation dans un but spécifique. 
 Reportez-vous à la licence publique générale de GNU pour plus de détails.
-Vous devez avoir reçu une copie de la licence publique générale de GNU
-en même temps que ce document.
+Vous devez avoir reçu une copie de la licence publique générale de GNU 
+en même temps que ce document. 
 Si ce n’est pas le cas, aller voir <http://www.gnu.org/licenses/>.
 /****************************************************************************
 Initial software: MMG3D Version 4.0
 Co-authors: Cecile Dobrzynski et Pascal Frey.
 Owners: IPB - UPMC -INRIA.
 
-Copyright © 2004-2005-2006-2007-2008-2009-2010-2011,
-spread under the terms and conditions of the license GNU General Public License
+Copyright © 2004-2005-2006-2007-2008-2009-2010-2011, 
+spread under the terms and conditions of the license GNU General Public License 
 as published Version 3, or (at your option) any later version.
 
 This file is part of MMG3D
@@ -41,26 +41,26 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
-along with MMG3D. If not, see <http://www.gnu.org/licenses/>.
+along with MMG3D. If not, see <http://www.gnu.org/licenses/>.  
 ****************************************************************************/
 #include "mesh.h"
 
-int MMG_npuiss,MMG_nvol,MMG_npres;
-int MMG_nlen,MMG_ncal,MMG_ntopo,MMG_nex;
-int MMG_npuisstot,MMG_nvoltot,MMG_nprestot;
-int MMG_npdtot;
-int MMG_nplen,MMG_npref,MMG_bouffe;
+extern int MMG_npuiss,MMG_nvol,MMG_npres;
+extern int MMG_nlen,MMG_ncal,MMG_ntopo,MMG_nex;
+extern int MMG_npuisstot,MMG_nvoltot,MMG_nprestot;
+extern int MMG_npdtot;
+extern int MMG_nplen,MMG_npref,MMG_bouffe;
 
 int ddebug;
 
 int MMG_mmg3d4(pMesh mesh,pSol sol,int *alert) {
   Hedge    hash;
-  pBucket        bucket;
+  pBucket	 bucket; 
   double   declic;
-  int              base,na,nd,ns,nna,nnd,nns,dd,it,nf,maxtou;
-  double   lmoy,LLLONG;
-  int k;
-  pTetra pt;
+  int		   base,na,nd,ns,nna,nnd,nns,dd,it,nf,maxtou; 
+  double   lmoy,LLLONG;                      
+	int k;
+	pTetra pt;
   if ( abs(mesh->info.imprim) > 3 )
     fprintf(stdout,"  ** SIZE OPTIMIZATION\n");
   if ( mesh->info.imprim < 0 ) {
@@ -73,82 +73,82 @@
   maxtou = 10;
   nna = nns = nnd = 0;
   it  = 0;
-  declic = 3. / ALPHAD;
+  declic = 3. / ALPHAD;  
   lmoy = 10.;
   LLLONG = 1.5;
-
+  
   nna = 10;
-  do {
-    na  = nd  = ns  = 0;
+  do { 
+    na  = nd  = ns  = 0; 
     if(0) ddebug = 1;
     else ddebug = 0;
-
+    
     if(it && !(it%2) ) {
       bucket = MMG_newBucket(mesh,M_MAX(mesh->info.bucksiz,BUCKSIZ));
       if ( !bucket )  return(0);
-      //MMG_saveMesh(mesh,"avtana.mesh");
-      MMG_analar(mesh,sol,bucket,&na,&nd,&nf,alert);
-      //MMG_saveMesh(mesh,"apresana.mesh");
-      if ( abs(mesh->info.imprim) > 5 )
-	fprintf(stdout,"     %7d INSERTED  %7d REMOVED   %7d FILTERED\n",na,nd,nf);
-
-      M_free(bucket->head);
-      M_free(bucket->link);
-      M_free(bucket);
-
+			//MMG_saveMesh(mesh,"avtana.mesh",0);
+      MMG_analar(mesh,sol,bucket,&na,&nd,&nf,alert);      
+			//MMG_saveMesh(mesh,"apresana.mesh",0);
+      if ( abs(mesh->info.imprim) > 5 ) 
+        fprintf(stdout,"     %7d INSERTED  %7d REMOVED   %7d FILTERED\n",na,nd,nf);  
+
+	    M_free(bucket->head);
+	    M_free(bucket->link);
+	    M_free(bucket);
+        
     } else {
-      ++mesh->flag;
+        ++mesh->flag;
     }
-    //printf("IT %d $$$$$$$$$$$ LLLONG  %9.3f\n",it,LLLONG);
-    nna = nns = nnd = 0;
-
+    //printf("IT %d $$$$$$$$$$$ LLLONG  %9.3f\n",it,LLLONG); 
+    nna = nns = nnd = 0; 
+      
     /*splitting*/
     if ( !mesh->info.noinsert && (!*alert)  ) {
       /* store points on edges */
       if ( !MMG_zaldy4(&hash,mesh->np) ) {
-	if ( mesh->info.ddebug )  fprintf(stdout,"  ## MEMORY ALLOCATION PROBLEM.\n");
-	*alert = 2;
-	break;
+        if ( mesh->info.ddebug )  fprintf(stdout,"  ## MEMORY ALLOCATION PROBLEM.\n"); 
+        *alert = 2;
+        break;
       }
-      nna = MMG_analarcutting(mesh,sol,&hash,alert,&lmoy,LLLONG);
+      nna = MMG_analarcutting(mesh,sol,&hash,alert,&lmoy,LLLONG); 
       if ( abs(mesh->info.imprim) > 5 ) { printf("lmoy %9.5f\n",lmoy); }
       /*puts("--------------------------------------");
-	puts("--------------------------------------");
-	puts("--------------------------------------");
-      */
+      puts("--------------------------------------");
+      puts("--------------------------------------");
+      */                             
       if ( *alert ) {
-	fprintf(stdout," \n\n ** UNABLE TO CUT (analarcutting)\n");
-	fprintf(stdout," ** RETRY WITH -m > %6d \n\n",mesh->info.memory);
-	MMG_saveMesh(mesh,"crash.mesh");
-	MMG_saveSol(mesh,sol,"crash.sol");
-	exit(0);
+        fprintf(stdout," \n\n ** UNABLE TO CUT (analarcutting)\n");
+        fprintf(stdout," ** RETRY WITH -m > %6d \n\n",mesh->info.memory);
+        MMG_saveMesh(mesh,"crash.mesh",0);
+        MMG_saveSol(mesh,sol,"crash.sol",0); 
+        exit(0);
       }
-      M_free(hash.item);
+      M_free(hash.item);        
     }
-    else if ( *alert )  nna = 0;
-    /* adjacencies */
+    else if ( *alert )  nna = 0;  
+    /* adjacencies */ 
     if ( nna /*|| it == (maxtou-1)*/ ) {
       mesh->nt = 0;
       if ( !MMG_hashTetra(mesh) )  return(0);
       if ( !MMG_markBdry(mesh) )   return(0);
     }
-    // printf("chkmsh\n");
-    // MMG_unscaleMesh(mesh,sol);
-    //     MMG_saveMesh(mesh,"chk.mesh");
+    // printf("chkmsh\n");   
+		// MMG_unscaleMesh(mesh,sol);
+		//     MMG_saveMesh(mesh,"chk.mesh",0);
     //MMG_chkmsh(mesh,1,-1);
-    //if(it==1)exit(0);
-    /* delaunization */
-    if ( !mesh->info.noswap && (nna || na) ) {
+		//if(it==1)exit(0);		
+     /* delaunization */
+    if ( !mesh->info.noswap && (nna || na) ) {  
       nns   =  MMG_cendel(mesh,sol,declic,base);
     }
 
     /* deletion */
     /*if ( 0 && nna ) {
       nnd   = MMG_colvert(mesh,sol,base);
-      } */
+    } */
     if ( nna+nnd+nns && abs(mesh->info.imprim) > 3 )
       fprintf(stdout,"     %7d INSERTED  %7d REMOVED   %7d FLIPPED\n",nna+na,nnd+nd,nns);
-
+    
   }
   while ( na+nd+nns+nna+nnd > 0 && ++it < maxtou && lmoy > 1.3);
 
@@ -161,80 +161,80 @@
     MMG_prilen(mesh,sol);
   }
 
-  //return(1);
-  //MMG_saveMesh(mesh,"aprescut.mesh");
-  fprintf(stdout,"    ---\n");
-
+	//return(1);
+	//MMG_saveMesh(mesh,"aprescut.mesh",0);
+	fprintf(stdout,"    ---\n");
+  
   /*analyze standard*/
-  base   = mesh->flag;
-  *alert = 0;
+    base   = mesh->flag;
+    *alert = 0;
 
-  nna = 0;
-  nnd = 0;
-  nf  = 0;
-  it  = 0;
-  maxtou = 100;
-  MMG_npdtot=0;
-  MMG_npuisstot=0;
-  MMG_nprestot=0;
-  MMG_nvoltot=0;
-
-  /* 2. field points */
-  if ( mesh->info.imprim < -4 ) {
-    MMG_prilen(mesh,sol);
-    fprintf(stdout,"  -- FIELD POINTS\n");
-  }
-
-  /* create filter */
-  bucket = MMG_newBucket(mesh,M_MAX(mesh->info.bucksiz,BUCKSIZ));
-  if ( !bucket )  return(0);
-
-  do {
-    MMG_analar(mesh,sol,bucket,&na,&nd,&nf,alert);
-    nna += na;
-    nnd += nd;
-    if ( *alert ) {
-      if ( nd < 1000 )  break;
-      else  *alert = 0;
-    }
-    if ( it > 5 ) {
-      dd = abs(nd-na);
-      if ( dd < 5 || dd < 0.05*nd )   break;
-      else if ( it > 12 && nd >= na )  break;
-    }
-    if ( na+nd && abs(mesh->info.imprim) > 3 )
-      fprintf(stdout,"     %7d INSERTED  %7d REMOVED   %7d FILTERED\n",na,nd,nf);
-    // MMG_saveMesh(mesh,"chk.mesh");
-    // //if(it==1) exit(0);
-  }
-  while ( na+nd > 0 && ++it < maxtou );
-
-  if ( nna+nnd && abs(mesh->info.imprim) < 3 ) {
-    fprintf(stdout,"     %7d INSERTED  %7d REMOVED  %7d FILTERED\n",na,nd,nf);
-  }
-
-  if(MMG_npdtot>0) {
-    fprintf(stdout,"    REJECTED : %5d\n",MMG_npdtot);
-    fprintf(stdout,"          VOL      : %6.2f %%    %5d \n",
-	    100*(MMG_nvoltot/(float)
-		 MMG_npdtot),MMG_nvoltot);
-    fprintf(stdout,"          PUISS    : %6.2f %%    %5d \n",
-	    100*(MMG_npuisstot/(float) MMG_npdtot),MMG_npuisstot);
-    fprintf(stdout,"         PROCHE    : %6.2f %%    %5d \n",
-	    100*(MMG_nprestot/(float) MMG_npuisstot),MMG_nprestot);
+    nna = 0;
+    nnd = 0;
+    nf  = 0;
+    it  = 0;
+    maxtou = 100;
     MMG_npdtot=0;
     MMG_npuisstot=0;
+    MMG_nprestot=0;
     MMG_nvoltot=0;
-  }
-  if ( mesh->info.imprim < 0 ) {
-    MMG_outqua(mesh,sol);
-    MMG_prilen(mesh,sol);
-  }
 
-  M_free(bucket->head);
-  M_free(bucket->link);
-  M_free(bucket);
+    /* 2. field points */
+    if ( mesh->info.imprim < -4 ) {
+      MMG_prilen(mesh,sol);
+      fprintf(stdout,"  -- FIELD POINTS\n");
+    }
+
+    /* create filter */
+    bucket = MMG_newBucket(mesh,M_MAX(mesh->info.bucksiz,BUCKSIZ));
+    if ( !bucket )  return(0);
+
+    do {
+      MMG_analar(mesh,sol,bucket,&na,&nd,&nf,alert);    
+      nna += na;
+      nnd += nd;
+      if ( *alert ) {
+        if ( nd < 1000 )  break;
+        else  *alert = 0;
+      }
+      if ( it > 5 ) {
+        dd = abs(nd-na);
+        if ( dd < 5 || dd < 0.05*nd )   break;
+        else if ( it > 12 && nd >= na )  break;
+      }
+      if ( na+nd && abs(mesh->info.imprim) > 3 )
+        fprintf(stdout,"     %7d INSERTED  %7d REMOVED   %7d FILTERED\n",na,nd,nf);    
+			// MMG_saveMesh(mesh,"chk.mesh",0);
+			// //if(it==1) exit(0);
+    }
+    while ( na+nd > 0 && ++it < maxtou );
+
+    if ( nna+nnd && abs(mesh->info.imprim) < 3 ) {
+      fprintf(stdout,"     %7d INSERTED  %7d REMOVED  %7d FILTERED\n",na,nd,nf);
+    }
+
+  if(MMG_npdtot>0) { 
+  fprintf(stdout,"    REJECTED : %5d\n",MMG_npdtot);
+  fprintf(stdout,"          VOL      : %6.2f %%    %5d \n",
+  	100*(MMG_nvoltot/(float)
+  MMG_npdtot),MMG_nvoltot); 
+  fprintf(stdout,"          PUISS    : %6.2f %%    %5d \n",
+  	100*(MMG_npuisstot/(float) MMG_npdtot),MMG_npuisstot);
+  fprintf(stdout,"         PROCHE    : %6.2f %%    %5d \n",
+  	100*(MMG_nprestot/(float) MMG_npuisstot),MMG_nprestot);	
+  MMG_npdtot=0;
+  MMG_npuisstot=0;
+  MMG_nvoltot=0;  
+  } 
+    if ( mesh->info.imprim < 0 ) {
+      MMG_outqua(mesh,sol);
+      MMG_prilen(mesh,sol);
+    }
 
+    M_free(bucket->head);
+    M_free(bucket->link);
+    M_free(bucket);
+  
 
   return(1);
 }
diff -r -u mmg3d4/build/sources/mmg3dConfig.h mmg3d4-new/build/sources/mmg3dConfig.h
--- mmg3d4/build/sources/mmg3dConfig.h	2012-12-19 16:05:36.000000000 +0100
+++ mmg3d4-new/build/sources/mmg3dConfig.h	2013-01-18 16:32:41.000000000 +0100
@@ -2,4 +2,4 @@
 #define Tutorial_VERSION_MAJOR 
 #define Tutorial_VERSION_MINOR 
 
-#define USE_SCOTCH
+/* #undef USE_SCOTCH */
diff -r -u mmg3d4/build/sources/mmg3dlib/mmg3dlib.c mmg3d4-new/build/sources/mmg3dlib/mmg3dlib.c
--- mmg3d4/build/sources/mmg3dlib/mmg3dlib.c	2012-12-19 16:06:03.000000000 +0100
+++ mmg3d4-new/build/sources/mmg3dlib/mmg3dlib.c	2013-01-18 16:32:41.000000000 +0100
@@ -385,7 +385,7 @@
   if ( !MMG_hashTetra(mesh) )    return(1);
   if ( !MMG_markBdry(mesh) )     return(1);
   if (abs(mesh->info.option)==10) {
-    MMG_saveMesh(mesh,"tetra.mesh");
+    MMG_saveMesh(mesh,"tetra.mesh",0);
     return(0);
   }           
   if ( !sol->np) {
@@ -431,7 +431,7 @@
     if ( abs(info->option) == 9 ) {  
       if(!MMG_mmg3d9(mesh,sol,&alert)) {
         if ( !MMG_unscaleMesh(mesh,sol) )  return(1);
-        MMG_saveMesh(mesh,"errormoving.mesh");
+        MMG_saveMesh(mesh,"errormoving.mesh",0);
 	      //MMG_saveSol(mesh,sol,mesh->outf);
 	      return(1);
       }
diff -r -u mmg3d4/build/sources/optlen.c mmg3d4-new/build/sources/optlen.c
--- mmg3d4/build/sources/optlen.c	2012-12-19 16:05:33.000000000 +0100
+++ mmg3d4-new/build/sources/optlen.c	2013-01-18 16:32:41.000000000 +0100
@@ -48,7 +48,7 @@
 #define  HQCOEF    0.9 
 #define  HCRIT     0.98
 
-double MMG_rao(pMesh mesh,int k,int inm);
+double MMG_rao(pMesh mesh,int k,FILE* );
 int MMG_optlen_ani(pMesh mesh,pSol sol,double declic,int base) {
   pTetra    pt,pt1;
   pPoint    ppa,ppb;
diff -r -u mmg3d4/build/sources/pattern.c mmg3d4-new/build/sources/pattern.c
--- mmg3d4/build/sources/pattern.c	2012-12-19 16:05:33.000000000 +0100
+++ mmg3d4-new/build/sources/pattern.c	2013-01-18 18:41:02.000000000 +0100
@@ -47,7 +47,7 @@
 
 
 unsigned char MMG_arfa[3][4] = { {2,0,1,3}, {1,2,0,3}, {0,1,2,3} };
-extern int MMG_permar[10][4];
+extern int MMG_permar[12][4];
 extern int MMG_pointar[64][2];
 extern int ddebug;
 //insert ip on ia-ib
diff -r -u mmg3d4/build/sources/quality.c mmg3d4-new/build/sources/quality.c
--- mmg3d4/build/sources/quality.c	2012-12-19 16:05:33.000000000 +0100
+++ mmg3d4-new/build/sources/quality.c	2013-01-18 16:32:41.000000000 +0100
@@ -46,7 +46,7 @@
 #include "mesh.h"  
 
 
-double MMG_rao(pMesh mesh,int k,int inm);
+double MMG_rao(pMesh mesh,int k,FILE* inm) ;
 double MMG_caltetrao(pMesh mesh,pSol sol,int iel) {
 	return(MMG_rao(mesh,iel,0));
 }
diff -r -u mmg3d4/build/sources/ratio.c mmg3d4-new/build/sources/ratio.c
--- mmg3d4/build/sources/ratio.c	2012-12-19 16:05:33.000000000 +0100
+++ mmg3d4-new/build/sources/ratio.c	2013-01-18 16:32:41.000000000 +0100
@@ -365,7 +365,7 @@
   fprintf(stdout,"           ELEMENT   %d (%d)   %d %d %d %d\n",
 	  iel,ielreal,pt->v[0],pt->v[1],pt->v[2],pt->v[3]);
 
-  if ( abs(mesh->info.imprim) < 5 )  return;
+  if ( abs(mesh->info.imprim) < 5 )  return (1) ;
 
   fprintf(stdout,"\n     HISTOGRAMM\n");
   for (k=1; k<9; k++) {
diff -r -u mmg3d4/build/sources/sproto.h mmg3d4-new/build/sources/sproto.h
--- mmg3d4/build/sources/sproto.h	2012-12-19 16:05:36.000000000 +0100
+++ mmg3d4-new/build/sources/sproto.h	2013-01-18 16:32:41.000000000 +0100
@@ -67,13 +67,13 @@
 int  MMG_inEdge(pHedge ,int *,int *,int *);
 int  MMG_markBdry(pMesh );
 
-/* inout */
-int  MMG_loadMesh(pMesh ,char *);
-int  MMG_loadSol(pSol ,char *,int );
-int  MMG_loadVect(pMesh ,char *,int );
-int  MMG_saveMesh(pMesh ,char *);
-int  MMG_saveSol(pMesh ,pSol ,char *);
-int  MMG_saveVect(pMesh ,char *);
+/* inout add param  F.H. june 2011 (dataff) */
+int  MMG_loadMesh(pMesh ,char *,void *);
+int  MMG_loadSol(pSol ,char *,int ,void *);
+int  MMG_loadVect(pMesh ,char *,int ,void *);
+int  MMG_saveMesh(pMesh ,char *,void *);
+int  MMG_saveSol(pMesh ,pSol ,char *,void *);
+int  MMG_saveVect(pMesh ,char *,void *);
 
 int  MMG_loctet(pMesh ,int ,int ,double *,double *);
 int  MMG_computeMetric(pMesh ,pSol ,int ,double * );
diff -r -u mmg3d4/build/sources/swapar.c mmg3d4-new/build/sources/swapar.c
--- mmg3d4/build/sources/swapar.c	2012-12-19 16:05:33.000000000 +0100
+++ mmg3d4-new/build/sources/swapar.c	2013-01-18 18:43:38.000000000 +0100
@@ -1,106 +1,107 @@
-/****************************************************************************
-Logiciel initial: MMG3D Version 4.0
-Co-auteurs : Cecile Dobrzynski et Pascal Frey.
-Propriétaires :IPB - UPMC -INRIA.
-
-Copyright © 2004-2005-2006-2007-2008-2009-2010-2011,
-diffusé sous les termes et conditions de la licence publique générale de GNU
-Version 3 ou toute version ultérieure.
-
-Ce fichier est une partie de MMG3D.
-MMG3D est un logiciel libre ; vous pouvez le redistribuer et/ou le modifier
-suivant les termes de la licence publique générale de GNU
-Version 3 ou toute version ultérieure.
-MMG3D est distribué dans l'espoir qu'il sera utile, mais SANS
-AUCUNE GARANTIE ; sans même garantie de valeur marchande.
-Voir la licence publique générale de GNU pour plus de détails.
-MMG3D est diffusé en espérant qu’il sera utile,
-mais SANS AUCUNE GARANTIE, ni explicite ni implicite,
-y compris les garanties de commercialisation ou
-d’adaptation dans un but spécifique.
-Reportez-vous à la licence publique générale de GNU pour plus de détails.
-Vous devez avoir reçu une copie de la licence publique générale de GNU
-en même temps que ce document.
-Si ce n’est pas le cas, aller voir <http://www.gnu.org/licenses/>.
-/****************************************************************************
-Initial software: MMG3D Version 4.0
-Co-authors: Cecile Dobrzynski et Pascal Frey.
-Owners: IPB - UPMC -INRIA.
-
-Copyright © 2004-2005-2006-2007-2008-2009-2010-2011,
-spread under the terms and conditions of the license GNU General Public License
-as published Version 3, or (at your option) any later version.
-
-This file is part of MMG3D
-MMG3D is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 3 of the License, or
-(at your option) any later version.
-MMG3D is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-You should have received a copy of the GNU General Public License
-along with MMG3D. If not, see <http://www.gnu.org/licenses/>.
-****************************************************************************/
-#include "mesh.h"
-
-int MMG_swapar(pMesh mesh,pSol sol,pQueue q,List *list,int lon,double crit,double declic) {
-  pTetra   pt;
-  int      i,l,jel,ncas,ddebug,iadr;
-
-  MMG_swpptr = 0;
-  ncas   = 0;
-  if ( !MMG_getnElt(mesh,10) )  return(-1);
-  if(0 && list->tetra[1]/6==2352) ddebug=1;
-  else ddebug=0;
-
-  switch(lon) {
-  case 3:
-    ncas = MMG_simu32(mesh,sol,list,crit);
-    break;
-  case 4:
-    ncas = MMG_simu44(mesh,sol,list,crit);
-    break;
-  case 5:
-    ncas = MMG_simu56(mesh,sol,list,crit);
-    break;
-  case 6:
-    ncas = MMG_simu68(mesh,sol,list,crit);
-    break;
-  case 7:
-    ncas = MMG_simu710(mesh,sol,list,crit);
-    break;
-  default:
-    return(0);
-  }
-  if(ddebug) printf("on fait swap %d\n",ncas);
-  if ( ncas && MMG_swpptr ) {
-    if(ddebug) MMG_saveMesh(mesh,"avt.mesh");
-    for (l=1; l<=lon; l++) {
-      jel = list->tetra[l]/6;
-      pt  = &mesh->tetra[jel];
-      if(ddebug) {
-	printf("tet %d : %d %d %d %d -- %d %d %d %d %d %d\n",jel,pt->v[0],pt->v[1],pt->v[2],pt->v[3],
-	       pt->bdryinfo[0],pt->bdryinfo[1],pt->bdryinfo[2],pt->bdryinfo[3],pt->bdryinfo[4],pt->bdryinfo[5]);
-
-      }
-      MMG_kiudel(q,jel);
-    }
-    lon = MMG_swpptr(mesh,sol,list);
-    assert(lon);
-    if(!lon) return(0);
-
-    for (l=1; l<=lon; l++) {
-      jel = list->tetra[l];
-      pt  = &mesh->tetra[jel];
-      if ( pt->qual >= declic )  MMG_kiuput(q,jel);
-      for (i=0; i<4; i++)  mesh->point[pt->v[i]].flag = mesh->flag;
-
-    }
-    if(ddebug) {MMG_saveMesh(mesh,"sw.mesh");    exit(0);}
-    return(1);
-  }
-
-  return(0);
-}
+/****************************************************************************
+Logiciel initial: MMG3D Version 4.0
+Co-auteurs : Cecile Dobrzynski et Pascal Frey.
+Propriétaires :IPB - UPMC -INRIA.
+
+Copyright © 2004-2005-2006-2007-2008-2009-2010-2011, 
+diffusé sous les termes et conditions de la licence publique générale de GNU
+Version 3 ou toute version ultérieure.  
+
+Ce fichier est une partie de MMG3D.
+MMG3D est un logiciel libre ; vous pouvez le redistribuer et/ou le modifier
+suivant les termes de la licence publique générale de GNU
+Version 3 ou toute version ultérieure.
+MMG3D est distribué dans l'espoir qu'il sera utile, mais SANS 
+AUCUNE GARANTIE ; sans même garantie de valeur marchande.  
+Voir la licence publique générale de GNU pour plus de détails.
+MMG3D est diffusé en espérant qu’il sera utile, 
+mais SANS AUCUNE GARANTIE, ni explicite ni implicite, 
+y compris les garanties de commercialisation ou 
+d’adaptation dans un but spécifique. 
+Reportez-vous à la licence publique générale de GNU pour plus de détails.
+Vous devez avoir reçu une copie de la licence publique générale de GNU 
+en même temps que ce document. 
+Si ce n’est pas le cas, aller voir <http://www.gnu.org/licenses/>.
+/****************************************************************************
+Initial software: MMG3D Version 4.0
+Co-authors: Cecile Dobrzynski et Pascal Frey.
+Owners: IPB - UPMC -INRIA.
+
+Copyright © 2004-2005-2006-2007-2008-2009-2010-2011, 
+spread under the terms and conditions of the license GNU General Public License 
+as published Version 3, or (at your option) any later version.
+
+This file is part of MMG3D
+MMG3D is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+MMG3D is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+You should have received a copy of the GNU General Public License
+along with MMG3D. If not, see <http://www.gnu.org/licenses/>.  
+****************************************************************************/
+#include "mesh.h"
+
+int MMG_swapar(pMesh mesh,pSol sol,pQueue q,List *list,int lon,double crit,double declic) {
+  pTetra   pt;
+  int      i,l,jel,ncas,ddebug,iadr;
+
+  MMG_swpptr = 0;
+  ncas   = 0;
+  if ( !MMG_getnElt(mesh,10) )  return(-1);
+	if(0 && list->tetra[1]/6==2352) ddebug=1;
+	else ddebug=0;
+	
+  switch(lon) {
+  case 3:
+	  ncas = MMG_simu32(mesh,sol,list,crit);
+    break;
+  case 4:
+	  ncas = MMG_simu44(mesh,sol,list,crit); 
+    break;
+  case 5:
+	ncas = MMG_simu56(mesh,sol,list,crit);
+    break;
+  case 6:
+	ncas = MMG_simu68(mesh,sol,list,crit); 
+    break;
+  case 7:
+	ncas = MMG_simu710(mesh,sol,list,crit);   
+    break;  
+  default:
+    return(0);
+  }
+	if(ddebug) printf("on fait swap %d\n",ncas);
+  if ( ncas && MMG_swpptr ) {
+		if(ddebug) MMG_saveMesh(mesh,"avt.mesh",0);
+    for (l=1; l<=lon; l++) {
+      jel = list->tetra[l]/6;
+      pt  = &mesh->tetra[jel]; 
+			if(ddebug) {
+				printf("tet %d : %d %d %d %d -- %d %d %d %d %d %d\n",jel,pt->v[0],pt->v[1],pt->v[2],pt->v[3],
+					pt->bdryinfo[0],pt->bdryinfo[1],pt->bdryinfo[2],pt->bdryinfo[3],pt->bdryinfo[4],pt->bdryinfo[5]);  
+				
+			} 
+			MMG_kiudel(q,jel);
+    }
+    lon = MMG_swpptr(mesh,sol,list);
+    assert(lon);
+    if(!lon) return(0); 
+    
+    for (l=1; l<=lon; l++) {
+      jel = list->tetra[l];
+      pt  = &mesh->tetra[jel]; 
+      if ( pt->qual >= declic )  MMG_kiuput(q,jel);
+      for (i=0; i<4; i++)  mesh->point[pt->v[i]].flag = mesh->flag;		 
+
+   }
+    if(ddebug) {MMG_saveMesh(mesh,"sw.mesh",0);    exit(0);}
+    return(1);
+  }
+
+  return(0);
+}
+
diff -u  mmg3d4/build/sources/inout.c mmg3d4-ok/build/sources/inout.c
--- mmg3d4/build/sources/inout.c	2012-12-19 16:05:32.000000000 +0100
+++ mmg3d4-ok/build/sources/inout.c	2013-07-11 11:43:47.000000000 +0200
@@ -44,6 +44,7 @@
 along with MMG3D. If not, see <http://www.gnu.org/licenses/>.
 ****************************************************************************/
 #include "mesh.h"
+#include "dataff.h"
 
 
 extern short           MMG_imprim;
@@ -100,35 +101,467 @@
   return(out);
 }
 
+
+int MMG_loadMeshff(pMesh mesh,char *filename,DataFF *dataff) {  
+   
+    
+    Hedge    				 hed,hed2;
+    pPoint       	   ppt;
+    pTetra           pt;
+    pTria            pt1;
+    int i,j,k; 
+    int nhex=0, npris=0, netmp=0,nq=0, pp[10] , ned=0, ncor=0;
+    int p0,p1,p2,p3,p4,p5,p6,ref ;
+    int data[10],ldata=10;
+    dataff->get_mesh(dataff,data,10);
+    mesh->np = data[ff_id_vertex];
+    ned = data[ff_id_seg];
+    mesh->nt = data[ff_id_tria];
+    mesh->ne = data[ff_id_tet];
+    netmp=mesh->ne;
+    nhex=data[ff_id_hex];
+    npris=data[ff_id_prism]; 
+    nq=data[ff_id_quad];
+    ncor= data[ff_id_corner];
+
+    if( nhex || npris) {
+	printf("mmg3d ff interface , hex or prism NOT SUPPORTED  to day (sorry  FH) \n");
+	goto L0; 
+    }
+    
+    mesh->ncor = 0; 
+    mesh->ver =1;
+    if ( abs(mesh->info.option)==10 ) {
+	fprintf(stdout,"  -- READING %8d HEXA %8d PRISMS\n",nhex,npris);  
+	if(!mesh->ne) netmp = 0;  
+	mesh->ne += 6*nhex + 3*npris; 
+    }
+    
+    if ( abs(mesh->info.imprim) > 5 )
+	fprintf(stdout,"  -- READING DATA for ff interface ");
+    
+    if ( !mesh->np || !mesh->ne ) {
+	fprintf(stdout,"  ** MISSING DATA yy\n");
+	goto L0; ;
+    }
+    if ( !MMG_zaldy(mesh) )  goto L0; 
+    
+    /* read mesh vertices */
+    mesh->npfixe = mesh->np;
+    
+    for (k=1; k<=mesh->np; k++) {
+	ppt = &mesh->point[k];
+	dataff->get_v3(dataff,k,ppt->c,&ppt->ref);
+	ppt->tag  = M_UNUSED;    
+    }
+    
+    /* read mesh triangles */
+    mesh->ntfixe = mesh->nt;
+
+    for (k=1; k<=mesh->nt; k++) {
+	pt1 = &mesh->tria[k]; 
+	dataff->get_elmt(dataff,ff_id_tria,k,pt1->v,&pt1->ref);
+	 
+	}  
+    
+
+
+    /* read mesh quads (option 10)*/ 
+    if(abs(mesh->info.option)==10) { 
+	fprintf(stdout,"     QUADS READING %d\n",nq);
+	mesh->ntfixe += 4*nq;
+        for (k=1; k<=nq; k++) {
+	    dataff->get_elmt(dataff, ff_id_quad ,k,pp,&ref);
+	
+	    pt1 = &mesh->tria[++mesh->nt]; 
+	    pt1->v[0] = pp[0];
+	    pt1->v[1] = pp[1];
+	    pt1->v[2] = pp[2];
+	    pt1->ref  = ref;
+	    pt1 = &mesh->tria[++mesh->nt]; 
+	    pt1->v[0] = pp[0];
+	    pt1->v[1] = pp[2];
+	    pt1->v[2] = pp[3];
+	    pt1->ref  = ref;
+	    pt1 = &mesh->tria[++mesh->nt]; 
+	    pt1->v[0] = pp[0];
+	    pt1->v[1] = pp[1];
+	    pt1->v[2] = pp[3];
+	    pt1->ref  = ref;
+	    pt1 = &mesh->tria[++mesh->nt]; 
+	    pt1->v[0] = pp[1];
+	    pt1->v[1] = pp[2];
+	    pt1->v[2] = pp[3];
+	    pt1->ref  = ref;
+	    
+	}
+    }
+    
+    /*read and store edges*/
+    if (ned) {         
+	if ( !MMG_zaldy4(&hed,ned) ) {
+	    if ( mesh->info.ddebug )  fprintf(stdout,"  ## MEMORY ALLOCATION PROBLEM : EDGES IGNORED\n"); 
+	    ned = 0;
+	}   
+	mesh->ned = ned;
+	
+	for (k=1; k<=ned; k++) { 
+	   dataff->get_elmt(dataff, ff_id_seg ,k,pp,&ref);
+	   
+	    if(MMG_edgePut(&hed,pp[0],pp[1],2)>1) {
+		fprintf(stdout,"  ## WARNING DOUBLE EDGE : %d %d\n",pp[0],pp[1]);
+	    }
+	}
+    }
+    
+    /* read mesh tetrahedra */
+    mesh->nefixe = mesh->ne;
+ 
+  
+    for (k=1; k<=netmp; k++) { 
+	pt = &mesh->tetra[k];
+	dataff->get_elmt(dataff,ff_id_tet,k,pt->v,&ref);
+	pt->ref  = ref;//0;//ref ;  
+	for(i=0 ; i<4 ; i++)
+	    pt->bdryref[i] = -1;  
+	
+	if (ned) { int nu1,nu2;
+	    for(i=0 ; i<6 ; i++) {                         
+		nu1 = pt->v[MMG_iare[i][0]];
+		nu2 = pt->v[MMG_iare[i][1]];
+		pt->bdryinfo[i] = MMG_edgePoint(&hed,nu1,nu2);
+	    }  			
+	    
+	} else {
+	    for(i=0 ; i<6 ; i++)
+		pt->bdryinfo[i] = 0;  			
+	}
+    }
+    if (ned) M_free(hed.item); 
+    
+    /*read corners*/ 
+    if (ncor) {
+	
+	mesh->ncor = ncor;
+	for (k=1; k<=ncor; k++) { 
+	    dataff->get_elmt(dataff,ff_id_corner,k,&ref,0);
+
+	    ppt = &mesh->point[ref];
+	    ppt->geom = M_CORNER; 
+	} 
+    }
+#ifdef XXXXXXXXXXXXXXX
+    if ( abs(mesh->info.option)==10 ) { 
+	if(bin) {
+	    printf("NOT SUPPORTED\n");
+	    exit(0);
+	} 
+	if ( !MMG_zaldy4(&hed2,3*npris+6*nhex) ) {
+	    if ( mesh->info.ddebug )  fprintf(stdout,"  ## MEMORY ALLOCATION PROBLEM : PRISM IGNORED\n"); 
+	    npris = 0;
+	    nhex  = 0;
+	}   
+	
+	/*read hexa and transform to tetra*/
+	rewind(inm);
+	fseek(inm,posnhex,SEEK_SET);
+	for (k=1; k<=nhex; k++) {   
+	    fscanf(inm,"%d %d %d %d %d %d %d %d %d",&p0,&p1,&p2,&p3,&p4,&p5,&p6,&p7,&ref); 
+	    //fscanf(inm,"%d %d %d %d %d %d %d %d %d",&p0,&p4,&p2,&p1,&p3,&p5,&p6,&p7,&ref); 
+	    //printf("hex %d : %d %d %d %d %d %d %d %d\n",k,p0,p1,p2,p3,p4,p5,p6,p7);   
+	    MMG_cuthex(mesh,&hed2,netmp+(k-1)*6,p0,p1,p2,p3,p4,p5,p6,p7,ref);
+	}  
+	
+	/*read prism and transform to tetra
+	 ---> compatibility pbs ==> hash edge and switch case*/  
+	rewind(inm);
+	fseek(inm,posnpris,SEEK_SET); 
+	nimp = 0; 
+	ne = netmp+6*nhex;
+	for (k=1; k<=npris; k++) {
+	    fscanf(inm,"%d %d %d %d %d %d %d",&p0,&p1,&p2,&p3,&p4,&p5,&ref); 
+	    if(!MMG_cutprism(mesh,&hed2,ne,p0,p1,p2,p3,p4,p5,ref))
+	      {
+		if(mesh->info.imprim < 0 ) fprintf(stdout,"DECOMPOSITION PRISM INVALID \n\n"); 
+		mesh->ne += 5;
+		ne += 8;
+		nimp++; 
+		continue;
+	      }
+	    ne += 3;
+	}
+	if(abs(mesh->info.imprim) > 3 )fprintf(stdout,"     %d INVALID DECOMPOSITION\n\n",nimp);
+    }
+#endif    
+    if ( abs(mesh->info.imprim) > 3 ) {
+	fprintf(stdout,"     NUMBER OF GIVEN VERTICES   %8d\n",mesh->npfixe);
+	if ( mesh->ntfixe )
+	    fprintf(stdout,"     NUMBER OF GIVEN TRIANGLES  %8d\n",mesh->ntfixe);
+	fprintf(stdout,"     NUMBER OF GIVEN TETRAHEDRA %8d\n",mesh->nefixe);
+	if ( ncor )
+	    fprintf(stdout,"     NUMBER OF GIVEN CORNERS    %8d\n",ncor);
+	if ( ned )
+	    fprintf(stdout,"     NUMBER OF GIVEN EDGES      %8d\n",ned);
+    }
+    //    MMG_saveMesh(mesh,"XXXXX.mesh",0);
+   dataff->mesh=0; // used 
+    return 1; 
+L0: 
+    dataff->mesh=0;// used 
+    return 1; 
+}
+
+int MMG_loadSolff(pSol sol,char *filename,int npmax,DataFF *dataff) { 
+   
+     double     tmp , *dsol ;       
+    int         binch,bdim,iswp;
+    int         k,i,isol,type,bin,dim,btyp,bpos;
+    long        posnp;
+    char        *ptr,data[128],chaine[128];
+    if( ! dataff->sol){
+	fprintf(stdout,"  ** MISSING DATA metrix ff \n");
+	return(1);
+    }
+    dsol = dataff->sol;
+    dataff->sol=0;// used 
+    
+
+    btyp = (dataff->typesol== 6)  ?  3: dataff->typesol ;
+    sol->np= dataff->np;
+    
+    if ( !sol->np ) {
+	fprintf(stdout,"  ** MISSING DATA zz\n");
+	return(1);
+    }
+    
+    if ( btyp!= 1 && btyp!=3 ) {
+      fprintf(stdout,"  ** DATA IGNORED (ff) btyp=%d\n",btyp);
+	sol->np = 0;
+	return(1);
+    }
+    
+    sol->offset = (btyp==1) ? 1 : 6;
+    
+    if ( abs(MMG_imprim) > 5 )
+	fprintf(stdout,"  -- READING DATA FILE(ff) %s\n",data);
+    
+    if ( !sol->np ) {
+	fprintf(stdout,"  ** MISSING DATA  no metrix  \n");
+	return(0);
+    }
+    sol->npfixe = sol->np;
+    sol->npmax  = npmax;
+    if ( !MMG_zaldy3(sol) )  return(0);
+    
+    /* read mesh solutions */
+    sol->npfixe = sol->np;
+ 
+    for (k=1; k<=sol->np; k++) {
+	isol = (k-1) * sol->offset + 1;
+	    for (i=0; i<sol->offset; i++) 		     
+		    sol->met[isol + i] = *dsol++;
+
+    }
+    
+    if ( abs(MMG_imprim) > 3 )
+	fprintf(stdout,"     NUMBER OF GIVEN DATA       %8d\n",sol->npfixe);
+    
+ 
+    return(1);  
+
+}
+/* load solution (metric) */
+int MMG_loadVectff(pMesh mesh,char *filename,int npmax,DataFF *dataff) {
+  
+      
+    pDispl       pd;
+    int         binch,bdim,iswp;
+    int         k,i,type,bin,dim,btyp,bpos,iadr;
+    long        posnp;
+    char        *ptr,data[128],chaine[128];
+    double *fsol = dataff->mov;
+    dataff->mov=0;// used 
+    
+    pd = mesh->disp;
+    pd->np =mesh->np ;
+ 
+       if ( !pd->np || !fsol  ) {
+	 fprintf(stdout,"  ** MISSING DATA dep ff %d %p\n",pd->np, fsol);
+	return(0);
+    }
+   
+    
+    if ( abs(mesh->info.imprim) > 5 )
+	fprintf(stdout,"  -- COPY DATA form ff interface  %s\n",data);
+    
+    /* read mesh solutions */
+    for (k=1; k<=pd->np; k++) {
+	iadr = (k - 1) * 3 + 1;
+	
+	    for (i=0; i<3; i++) {
+		    pd->mv[iadr + i] =  *fsol++;
+		}
+	    } 
+           
+    
+    
+    if ( abs(mesh->info.imprim) > 3 )
+	fprintf(stdout,"     NUMBER OF GIVEN DATA       %8d\n",pd->np);
+       return(1);
+  
+    
+}
+int MMG_saveMeshff(pMesh mesh,char *filename,DataFF *dataff) {  
+    
+    pPoint       	   ppt;
+    pTetra           pt;
+    pTria            pt1;
+    int j,k,np,nc,k0;
+    int data[10],ldata=10;
+    int kn[10];
+    np = 0; 
+    nc = 0;
+    // compress vertex ... fist case ... 
+    for (k=1; k<=mesh->np; k++) {
+      ppt = &mesh->point[k];
+      if ( ppt->tag & M_UNUSED )  continue;  
+      ppt->tmp = ++np;  
+      /*      if ( ppt->geom & M_CORNER )  cor[nc++] = ppt->tmp; */
+    }
+   
+    /*   seacrch vertex not in tet ???? */
+    {
+        int kk=0,npp=np;
+       for (k=1; k<=mesh->np; k++)
+       {
+            ppt = &mesh->point[k];
+           if ((ppt->tag & M_UNUSED )) ppt->tmp =-2;
+           else ppt->tmp =-1;
+
+       }
+       for ( k=1; k<=mesh->ne; k++)
+	{
+            pt = &mesh->tetra[k];
+            if ( !pt->v[0] )  continue;
+            k0++;
+            for(j=0;j<4;++j)
+              mesh->point[pt->v[j]].tmp=0;
+	}
+        np=0;
+        for (k=1; k<=mesh->np; k++)
+	{
+            ppt = &mesh->point[k];
+            
+            if ( ppt->tmp ==0) 
+               ppt->tmp = ++np; 
+            else
+            {
+                
+            if (ppt->tmp==-1)
+	    {
+                kk++;
+                ppt->tag  |= M_UNUSED;
+	    }
+                ppt->tmp=0;
+            }
+	}
+        if(kk) printf(" mmg3d: Strange nb of point %d not in tet is not zero (correct by FH)!\n" , kk);
+      
+    }
+    
+    mesh->nt=0;
+    if(! MMG_markBdry(mesh)) 
+      mesh->nt=0;
+    data[ff_id_vertex]=np ;
+    //data[ff_id_seg]=ned ;
+    data[ff_id_tria]=mesh->nt ;
+    int ne=0;
+    for ( k=1; k<=mesh->ne; k++) 
+      {
+	pt = &mesh->tetra[k];
+	if ( !pt->v[0] )  continue;  
+	ne++; 
+      }
+    
+    data[ff_id_tet]=ne  ;
+    printf(" mmg3d:  nbp = %d, nb tet %d\n",np,ne);
+    //data[ff_id_hex]=nhex;
+    //data[ff_id_prism]=npris; 
+    //data[ff_id_quad]=nq;
+    // data[ff_id_corner]=ncor;
+    
+    dataff->set_mesh(dataff,data,10);
+    
+    
+    for ( k=1; k<=mesh->np; k++) 
+      {
+	ppt = &mesh->point[k];
+	if ( ! ppt->tmp   )  continue;
+	dataff->set_v(dataff, ppt->tmp,ppt->c,ppt->ref);	    
+      }
+    
+    
+    for (k=1; k<=mesh->nt; k++) 
+      {
+	pt1 = &mesh->tria[k];
+	for(j=0;j<3;++j)
+	  kn[j] = mesh->point[pt1->v[j]].tmp;
+	dataff->set_elmt(dataff,ff_id_tria,k,kn,pt1->ref);
+	
+      }  
+    k0=0;
+    for ( k=1; k<=mesh->ne; k++) 
+      {
+	
+	pt = &mesh->tetra[k];
+	if ( !pt->v[0] )  continue;  
+	k0++;
+	for(j=0;j<4;++j)
+	  kn[j] = mesh->point[pt->v[j]].tmp;
+	dataff->set_elmt(dataff,ff_id_tet,k0,kn,pt->ref);
+	
+    }  
+    dataff->end_mesh(dataff);
+    return 1; 
+}
+int MMG_saveSolff (pMesh mesh,pSol sol,char *filename,DataFF *dataff) {
+  return 1; 
+}
+/*save the node speed : coornew-coorold/dt*/
+int MMG_saveVectff(pMesh mesh,char *filename,DataFF *dataff) {
+   return 1; 
+}
 /* read mesh data */
-int MMG_loadMesh(pMesh mesh,char *filename) {
+int MMG_loadMesh(pMesh mesh,char *filename,void *dataff) {  
   FILE*            inm;
   Hedge            hed,hed2;
   pPoint           ppt;
   pTetra           pt;
   pHexa            ph,listhexa;
   pTria            pt1;
-  int              k,dim,ref,bin,bpos,i,tmp;
-  int              *adjahex;
+  int              k,dim,ref,bin,bpos,i,tmp;  
+  int              *adjahex; 
   long             posnp,posnt,posne,posnhex,posnpris,posncor,posned,posnq;
   char            *ptr,data[128],chaine[128];
   int              nhex,npris,netmp,ncor,ned,nq;
-  int              p0,p1,p2,p3,p4,p5,p6,p7;
-  int              binch,bdim,iswp,nu1,nu2,nimp,ne,nbado;
-  float            fc;
-  double           volhex,volref;
+  int              p0,p1,p2,p3,p4,p5,p6,p7;  
+  int              binch,bdim,iswp,nu1,nu2,nimp,ne,nbado;       
+  float            fc; 
+  double           volhex,volref;  
   int              iadr,reorient;
-
+  if(dataff)
+    return MMG_loadMeshff( mesh,filename,(DataFF*) dataff);
+  
 
   posnp = posnt = posne = posnhex = posnpris = 0;
   netmp = ncor = ned = 0;
   bin = 0;
   iswp = 0;
-  mesh->np = mesh->nt = mesh->ne = mesh->ncor = 0;
+  mesh->np = mesh->nt = mesh->ne = mesh->ncor = 0; 
   npris = nhex = nq = 0;
-
+  
   strcpy(data,filename);
-  ptr = strstr(data,".mesh");
+  ptr = strstr(data,".mesh");  
   if ( !ptr ) {
     strcat(data,".meshb");
     if( !(inm = fopen(data,"rb")) ) {
@@ -136,8 +569,8 @@
       *ptr = '\0';
       strcat(data,".mesh");
       if( !(inm = fopen(data,"r")) ) {
-	fprintf(stderr,"  ** %s  NOT FOUND.\n",data);
-	return(0);
+        fprintf(stderr,"  ** %s  NOT FOUND.\n",data);
+        return(0);
       }
     } else {
       bin = 1;
@@ -147,194 +580,194 @@
     ptr = strstr(data,".meshb");
     if( !ptr ) {
       if( !(inm = fopen(data,"r")) ) {
-	fprintf(stderr,"  ** %s  NOT FOUND.\n",data);
-	return(0);
-      }
+        fprintf(stderr,"  ** %s  NOT FOUND.\n",data);
+        return(0);
+      }      
     } else {
       bin = 1;
       if( !(inm = fopen(data,"rb")) ) {
-	fprintf(stderr,"  ** %s  NOT FOUND.\n",data);
-	return(0);
+        fprintf(stderr,"  ** %s  NOT FOUND.\n",data);
+        return(0);
       }
-
-    }
+      
+    }  
   }
 
   fprintf(stdout,"  %%%% %s OPENED\n",data);
   if (!bin) {
-    strcpy(chaine,"D");
-    while(fscanf(inm,"%s",&chaine[0])!=EOF && strncmp(chaine,"End",strlen("End")) ) {
+    strcpy(chaine,"D");     
+    while(fscanf(inm,"%s",&chaine[0])!=EOF && strncmp(chaine,"End",strlen("End")) ) { 
       if(!strncmp(chaine,"MeshVersionFormatted",strlen("MeshVersionFormatted"))) {
-	fscanf(inm,"%d",&mesh->ver);
-	continue;
+          fscanf(inm,"%d",&mesh->ver);
+          continue;
       } else if(!strncmp(chaine,"Dimension",strlen("Dimension"))) {
-	fscanf(inm,"%d",&dim);
-	if(dim!=3) {
-	  fprintf(stdout,"BAD DIMENSION : %d\n",dim);
-	  return(0);
-	}
-	continue;
+          fscanf(inm,"%d",&dim);
+          if(dim!=3) {
+            fprintf(stdout,"BAD DIMENSION : %d\n",dim);
+            return(0);
+          }
+          continue;
       } else if(!strncmp(chaine,"Vertices",strlen("Vertices"))) {
-	fscanf(inm,"%d",&mesh->np);
-	posnp = ftell(inm);
-	continue;
+        fscanf(inm,"%d",&mesh->np); 
+        posnp = ftell(inm);
+        continue;
       } else if(!strncmp(chaine,"Triangles",strlen("Triangles"))) {
-	fscanf(inm,"%d",&mesh->nt);
-	posnt = ftell(inm);
-	continue;
+        fscanf(inm,"%d",&mesh->nt); 
+        posnt = ftell(inm);
+        continue;
       } else if(!strncmp(chaine,"Tetrahedra",strlen("Tetrahedra"))) {
-	fscanf(inm,"%d",&mesh->ne);
-	netmp = mesh->ne;
-	posne = ftell(inm);
-	continue;
-      } else if(!strncmp(chaine,"Hexahedra",strlen("Hexahedra"))) {
-	assert(abs(mesh->info.option)==10);
-	fscanf(inm,"%d",&nhex);
-	//nhex=0;
-	posnhex = ftell(inm);
-	continue;
-      } else if(!strncmp(chaine,"Pentahedra",strlen("Pentahedra"))) {
-	assert(abs(mesh->info.option)==10);
-	fscanf(inm,"%d",&npris);
-	//npris=0;
-	posnpris = ftell(inm);
-	continue;
-      } else if(!strncmp(chaine,"Corners",strlen("Corners"))) {
-	fscanf(inm,"%d",&ncor);
-	posncor = ftell(inm);
-	continue;
-      } else if(!strncmp(chaine,"Edges",strlen("Edges"))) {
-	fscanf(inm,"%d",&ned);
-	posned = ftell(inm);
-	continue;
-      } else if(abs(mesh->info.option)==10 && !strncmp(chaine,"Quadrilaterals",strlen("Quadrilaterals"))) {
-	fscanf(inm,"%d",&nq);
-	posnq = ftell(inm);
-	continue;
-      }
-    }
+        fscanf(inm,"%d",&mesh->ne); 
+        netmp = mesh->ne;
+        posne = ftell(inm);
+        continue;
+      } else if(!strncmp(chaine,"Hexahedra",strlen("Hexahedra"))) { 
+        assert(abs(mesh->info.option)==10);  
+        fscanf(inm,"%d",&nhex); 
+				//nhex=0;
+        posnhex = ftell(inm);
+        continue;
+      } else if(!strncmp(chaine,"Pentahedra",strlen("Pentahedra"))) { 
+        assert(abs(mesh->info.option)==10); 
+        fscanf(inm,"%d",&npris);
+				//npris=0;
+        posnpris = ftell(inm);
+        continue;
+      } else if(!strncmp(chaine,"Corners",strlen("Corners"))) { 
+        fscanf(inm,"%d",&ncor); 
+        posncor = ftell(inm);
+        continue;
+      } else if(!strncmp(chaine,"Edges",strlen("Edges"))) { 
+	      fscanf(inm,"%d",&ned); 
+	      posned = ftell(inm);
+	      continue;
+	    } else if(abs(mesh->info.option)==10 && !strncmp(chaine,"Quadrilaterals",strlen("Quadrilaterals"))) {
+		    fscanf(inm,"%d",&nq); 
+		    posnq = ftell(inm);
+		    continue;
+		  }
+    }  
   } else {
     bdim = 0;
     fread(&mesh->ver,sw,1,inm);
-    iswp=0;
-    if(mesh->ver==16777216)
-      iswp=1;
+    iswp=0;   
+    if(mesh->ver==16777216) 
+      iswp=1;    
     else if(mesh->ver!=1) {
       fprintf(stdout,"BAD FILE ENCODING\n");
-    }
-    fread(&mesh->ver,sw,1,inm);
-    if(iswp) mesh->ver = MMG_swapbin(mesh->ver);
-    while(fread(&binch,sw,1,inm)!=0 && binch!=54 ) {
-      if(iswp) binch=MMG_swapbin(binch);
-      if(binch==54) break;
+    } 
+    fread(&mesh->ver,sw,1,inm); 
+    if(iswp) mesh->ver = MMG_swapbin(mesh->ver); 
+    while(fread(&binch,sw,1,inm)!=0 && binch!=54 ) {  
+      if(iswp) binch=MMG_swapbin(binch);      
+      if(binch==54) break;  
       if(!bdim && binch==3) {  //Dimension
-	fread(&bdim,sw,1,inm);  //NulPos=>20
-	if(iswp) bdim=MMG_swapbin(bdim);
-	fread(&bdim,sw,1,inm);
-	if(iswp) bdim=MMG_swapbin(bdim);
-	if(bdim!=3) {
-	  fprintf(stdout,"BAD SOL DIMENSION : %d\n",dim);
-	  exit(0);
-	  return(1);
-	}
-	continue;
+        fread(&bdim,sw,1,inm);  //NulPos=>20
+        if(iswp) bdim=MMG_swapbin(bdim);
+        fread(&bdim,sw,1,inm);  
+        if(iswp) bdim=MMG_swapbin(bdim);
+        if(bdim!=3) {
+          fprintf(stdout,"BAD SOL DIMENSION : %d\n",dim);
+          exit(0);
+          return(1);
+        }
+        continue;
       } else if(!mesh->np && binch==4) {  //Vertices
-	fread(&bpos,sw,1,inm); //NulPos
-	if(iswp) bpos=MMG_swapbin(bpos);
-	fread(&mesh->np,sw,1,inm);
-	if(iswp) mesh->np=MMG_swapbin(mesh->np);
-	posnp = ftell(inm);
-	rewind(inm);
-	fseek(inm,bpos,SEEK_SET);
-	continue;
+        fread(&bpos,sw,1,inm); //NulPos 
+        if(iswp) bpos=MMG_swapbin(bpos);
+        fread(&mesh->np,sw,1,inm); 
+        if(iswp) mesh->np=MMG_swapbin(mesh->np);
+        posnp = ftell(inm);     
+        rewind(inm);
+        fseek(inm,bpos,SEEK_SET);        
+        continue;
       }  else if(!mesh->nt && binch==6) {//Triangles
-	fread(&bpos,sw,1,inm); //NulPos
-	if(iswp) bpos=MMG_swapbin(bpos);
-	fread(&mesh->nt,sw,1,inm);
-	if(iswp) mesh->nt=MMG_swapbin(mesh->nt);
-	posnt = ftell(inm);
-	rewind(inm);
-	fseek(inm,bpos,SEEK_SET);
-	continue;
-      } else if(!mesh->ne && binch==8) {
-	fread(&bpos,sw,1,inm); //NulPos
-	if(iswp) bpos=MMG_swapbin(bpos);
-	fread(&mesh->ne,sw,1,inm);
-	if(iswp) mesh->ne=MMG_swapbin(mesh->ne);
-	netmp = mesh->ne;
-	posne = ftell(inm);
-	rewind(inm);
-	fseek(inm,bpos,SEEK_SET);
-	continue;
-      } else if(!nhex && binch==10) {
-	assert(abs(mesh->info.option)==10);
-	fread(&bpos,sw,1,inm); //NulPos
-	if(iswp) bpos=MMG_swapbin(bpos);
-	fread(&nhex,sw,1,inm);
-	if(iswp) nhex=MMG_swapbin(nhex);
-	posnhex = ftell(inm);
-	rewind(inm);
-	fseek(inm,bpos,SEEK_SET);
-	continue;
-      } else if(!npris && binch==9) {
-	assert(abs(mesh->info.option)==10);
-	fread(&bpos,sw,1,inm); //NulPos
-	if(iswp) bpos=MMG_swapbin(bpos);
-	fread(&npris,sw,1,inm);
-	if(iswp) npris=MMG_swapbin(npris);
-	posnpris = ftell(inm);
-	rewind(inm);
-	fseek(inm,bpos,SEEK_SET);
-	continue;
-      } else if(!ncor && binch==13) {
-	fread(&bpos,sw,1,inm); //NulPos
-	if(iswp) bpos=MMG_swapbin(bpos);
-	fread(&ncor,sw,1,inm);
-	if(iswp) ncor=MMG_swapbin(ncor);
-	posncor = ftell(inm);
-	rewind(inm);
-	fseek(inm,bpos,SEEK_SET);
-	continue;
-      } else if(!ned && binch==5) { //Edges
-	fread(&bpos,sw,1,inm); //NulPos
-	if(iswp) bpos=MMG_swapbin(bpos);
-	fread(&ned,sw,1,inm);
-	if(iswp) ned=MMG_swapbin(ned);
-	posned = ftell(inm);
-	rewind(inm);
-	fseek(inm,bpos,SEEK_SET);
-	continue;
-      } else {
-	//printf("on traite ? %d\n",binch);
-	fread(&bpos,sw,1,inm); //NulPos
-	if(iswp) bpos=MMG_swapbin(bpos);
-	//printf("on avance... Nulpos %d\n",bpos);
-	rewind(inm);
-	fseek(inm,bpos,SEEK_SET);
-      }
-    }
-
+        fread(&bpos,sw,1,inm); //NulPos 
+        if(iswp) bpos=MMG_swapbin(bpos);
+        fread(&mesh->nt,sw,1,inm); 
+        if(iswp) mesh->nt=MMG_swapbin(mesh->nt);
+        posnt = ftell(inm); 
+        rewind(inm);
+        fseek(inm,bpos,SEEK_SET);        
+        continue;
+       } else if(!mesh->ne && binch==8) {  
+         fread(&bpos,sw,1,inm); //NulPos 
+         if(iswp) bpos=MMG_swapbin(bpos);
+         fread(&mesh->ne,sw,1,inm); 
+         if(iswp) mesh->ne=MMG_swapbin(mesh->ne);
+         netmp = mesh->ne;
+         posne = ftell(inm);
+         rewind(inm);
+         fseek(inm,bpos,SEEK_SET);        
+         continue;
+       } else if(!nhex && binch==10) { 
+         assert(abs(mesh->info.option)==10);
+         fread(&bpos,sw,1,inm); //NulPos 
+         if(iswp) bpos=MMG_swapbin(bpos);
+         fread(&nhex,sw,1,inm); 
+         if(iswp) nhex=MMG_swapbin(nhex);
+         posnhex = ftell(inm);
+         rewind(inm);
+         fseek(inm,bpos,SEEK_SET);        
+         continue;
+       } else if(!npris && binch==9) { 
+         assert(abs(mesh->info.option)==10);
+         fread(&bpos,sw,1,inm); //NulPos 
+         if(iswp) bpos=MMG_swapbin(bpos);
+         fread(&npris,sw,1,inm); 
+         if(iswp) npris=MMG_swapbin(npris);
+         posnpris = ftell(inm);
+         rewind(inm);
+         fseek(inm,bpos,SEEK_SET);        
+         continue;
+       } else if(!ncor && binch==13) { 
+         fread(&bpos,sw,1,inm); //NulPos 
+         if(iswp) bpos=MMG_swapbin(bpos);
+         fread(&ncor,sw,1,inm);          
+         if(iswp) ncor=MMG_swapbin(ncor);
+         posncor = ftell(inm);
+         rewind(inm);
+         fseek(inm,bpos,SEEK_SET);        
+         continue;
+        } else if(!ned && binch==5) { //Edges
+	       fread(&bpos,sw,1,inm); //NulPos 
+	       if(iswp) bpos=MMG_swapbin(bpos);
+	       fread(&ned,sw,1,inm); 
+	       if(iswp) ned=MMG_swapbin(ned);
+	       posned = ftell(inm);
+	       rewind(inm);
+	       fseek(inm,bpos,SEEK_SET);        
+	       continue;
+	      } else {
+         //printf("on traite ? %d\n",binch);
+         fread(&bpos,sw,1,inm); //NulPos 
+         if(iswp) bpos=MMG_swapbin(bpos);
+         //printf("on avance... Nulpos %d\n",bpos);         
+         rewind(inm);
+         fseek(inm,bpos,SEEK_SET);        
+       }     
+    }            
+    
   }
 
   if ( abs(mesh->info.option)==10 ) {
-    fprintf(stdout,"  -- READING %8d HEXA %8d PRISMS\n",nhex,npris);
-    if(!mesh->ne) netmp = 0;
-    mesh->ne += 6*nhex + 3*npris;
+    fprintf(stdout,"  -- READING %8d HEXA %8d PRISMS\n",nhex,npris);  
+    if(!mesh->ne) netmp = 0;  
+    mesh->ne += 6*nhex + 3*npris; 
   }
 
   if ( abs(mesh->info.imprim) > 5 )
     fprintf(stdout,"  -- READING DATA FILE %s\n",data);
 
   if ( !mesh->np || !mesh->ne ) {
-    fprintf(stdout,"  ** MISSING DATA\n");
+    fprintf(stdout,"  ** MISSING DAT qqA\n");
     return(0);
   }
-  if(abs(mesh->info.option)==10) { //allocation
+	if(abs(mesh->info.option)==10) { //allocation
     listhexa  = (pHexa)M_calloc(nhex+1,sizeof(Hexa),"allochexa");
-    assert(listhexa);
-    adjahex = (int*)M_calloc(6*nhex+7,sizeof(int),"allocadjhexa");
-    assert(adjahex);
-  }
+	  assert(listhexa);     
+	  adjahex = (int*)M_calloc(6*nhex+7,sizeof(int),"allocadjhexa");
+	  assert(adjahex);                             
+  }  
   if ( !MMG_zaldy(mesh) )  return(0);
   /* read mesh vertices */
   mesh->npfixe = mesh->np;
@@ -342,35 +775,35 @@
   fseek(inm,posnp,SEEK_SET);
   for (k=1; k<=mesh->np; k++) {
     ppt = &mesh->point[k];
-    if (mesh->ver < 2) { /*float*/
+    if (mesh->ver < 2) { /*float*/ 
       if (!bin) {
-	for (i=0 ; i<3 ; i++) {
-	  fscanf(inm,"%f",&fc);
-	  ppt->c[i] = (double) fc;
-	}
-	fscanf(inm,"%d",&ppt->ref);
+        for (i=0 ; i<3 ; i++) {
+          fscanf(inm,"%f",&fc);
+          ppt->c[i] = (double) fc;
+        } 
+        fscanf(inm,"%d",&ppt->ref);
       } else {
-	for (i=0 ; i<3 ; i++) {
-	  fread(&fc,sw,1,inm);
-	  if(iswp) fc=MMG_swapf(fc);
-	  ppt->c[i] = (double) fc;
-	}
-	fread(&ppt->ref,sw,1,inm);
-	if(iswp) ppt->ref=MMG_swapbin(ppt->ref);
+        for (i=0 ; i<3 ; i++) {
+          fread(&fc,sw,1,inm); 
+          if(iswp) fc=MMG_swapf(fc);    
+          ppt->c[i] = (double) fc;
+        }     
+        fread(&ppt->ref,sw,1,inm);         
+        if(iswp) ppt->ref=MMG_swapbin(ppt->ref);    
       }
     } else {
-      if (!bin)
-	fscanf(inm,"%lf %lf %lf %d",&ppt->c[0],&ppt->c[1],&ppt->c[2],&ppt->ref);
+      if (!bin) 
+        fscanf(inm,"%lf %lf %lf %d",&ppt->c[0],&ppt->c[1],&ppt->c[2],&ppt->ref); 
       else {
-	for (i=0 ; i<3 ; i++) {
-	  fread(&ppt->c[i],sd,1,inm);
-	  if(iswp) ppt->c[i]=MMG_swapd(ppt->c[i]);
-	}
-	fread(&ppt->ref,sw,1,inm);
-	if(iswp) ppt->ref=MMG_swapbin(ppt->ref);
-      }
-    }
-    ppt->tag  = M_UNUSED;
+        for (i=0 ; i<3 ; i++) { 
+          fread(&ppt->c[i],sd,1,inm);
+          if(iswp) ppt->c[i]=MMG_swapd(ppt->c[i]); 
+        }   
+        fread(&ppt->ref,sw,1,inm);         
+        if(iswp) ppt->ref=MMG_swapbin(ppt->ref);    
+      }  
+    }             
+    ppt->tag  = M_UNUSED;    
   }
 
   /* read mesh triangles */
@@ -378,227 +811,226 @@
   rewind(inm);
   fseek(inm,posnt,SEEK_SET);
   for (k=1; k<=mesh->nt; k++) {
-    pt1 = &mesh->tria[k];
+    pt1 = &mesh->tria[k]; 
     if (!bin)
       fscanf(inm,"%d %d %d %d",&pt1->v[0],&pt1->v[1],&pt1->v[2],&pt1->ref);
     else {
-      for (i=0 ; i<3 ; i++) {
-	fread(&pt1->v[i],sw,1,inm);
-	if(iswp) pt1->v[i]=MMG_swapbin(pt1->v[i]);
-      }
-      fread(&pt1->ref,sw,1,inm);
-      if(iswp) pt1->ref=MMG_swapbin(pt1->ref);
-    }
-  }
-  /* read mesh quads (option 10)*/
-  if(abs(mesh->info.option)==10) {
-    fprintf(stdout,"     QUADS READING %d\n",nq);
+      for (i=0 ; i<3 ; i++) { 
+        fread(&pt1->v[i],sw,1,inm); 
+        if(iswp) pt1->v[i]=MMG_swapbin(pt1->v[i]);    
+      }
+      fread(&pt1->ref,sw,1,inm); 
+      if(iswp) pt1->ref=MMG_swapbin(pt1->ref);           
+    }  
+  }
+  /* read mesh quads (option 10)*/ 
+	if(abs(mesh->info.option)==10) { 
+		fprintf(stdout,"     QUADS READING %d\n",nq);
     mesh->ntfixe += 4*nq;
 
     rewind(inm);
     fseek(inm,posnq,SEEK_SET);
     for (k=1; k<=nq; k++) {
       if (!bin)
-	fscanf(inm,"%d %d %d %d %d",&p0,&p1,&p2,&p3,&ref);
+        fscanf(inm,"%d %d %d %d %d",&p0,&p1,&p2,&p3,&ref);
       else {
-	fread(&p0,sw,1,inm);
-	if(iswp) p0=MMG_swapbin(p0);
-	fread(&p1,sw,1,inm);
-	if(iswp) p1=MMG_swapbin(p1);
-	fread(&p2,sw,1,inm);
-	if(iswp) p2=MMG_swapbin(p2);
-	fread(&p3,sw,1,inm);
-	if(iswp) p3=MMG_swapbin(p3);
-	fread(&pt1->ref,sw,1,inm);
-	if(iswp) ref=MMG_swapbin(ref);
-      }
+        fread(&p0,sw,1,inm); 
+        if(iswp) p0=MMG_swapbin(p0);    
+        fread(&p1,sw,1,inm); 
+        if(iswp) p1=MMG_swapbin(p1);    
+        fread(&p2,sw,1,inm); 
+        if(iswp) p2=MMG_swapbin(p2);    
+        fread(&p3,sw,1,inm); 
+        if(iswp) p3=MMG_swapbin(p3);    
+	      fread(&pt1->ref,sw,1,inm); 
+	      if(iswp) ref=MMG_swapbin(ref);           
+      } 
       /*creation of 4 triangles per quads because we don't know how hexa will be cut*/
-      pt1 = &mesh->tria[++mesh->nt];
-      pt1->v[0] = p0;
-      pt1->v[1] = p1;
-      pt1->v[2] = p2;
-      pt1->ref  = ref;
-      pt1 = &mesh->tria[++mesh->nt];
-      pt1->v[0] = p0;
-      pt1->v[1] = p2;
-      pt1->v[2] = p3;
-      pt1->ref  = ref;
-      pt1 = &mesh->tria[++mesh->nt];
-      pt1->v[0] = p0;
-      pt1->v[1] = p1;
-      pt1->v[2] = p3;
-      pt1->ref  = ref;
-      pt1 = &mesh->tria[++mesh->nt];
-      pt1->v[0] = p1;
-      pt1->v[1] = p2;
-      pt1->v[2] = p3;
-      pt1->ref  = ref;
-
-    }
-  }
-  /*read and store edges*/
-  if (ned) {
-    if ( !MMG_zaldy4(&hed,ned) ) {
-      if ( mesh->info.ddebug )  fprintf(stdout,"  ## MEMORY ALLOCATION PROBLEM : EDGES IGNORED\n");
-      ned = 0;
-    }
-    mesh->ned = ned;
+      pt1 = &mesh->tria[++mesh->nt]; 
+			pt1->v[0] = p0;
+			pt1->v[1] = p1;
+			pt1->v[2] = p2;
+			pt1->ref  = ref;
+      pt1 = &mesh->tria[++mesh->nt]; 
+			pt1->v[0] = p0;
+			pt1->v[1] = p2;
+			pt1->v[2] = p3;
+			pt1->ref  = ref;
+      pt1 = &mesh->tria[++mesh->nt]; 
+			pt1->v[0] = p0;
+			pt1->v[1] = p1;
+			pt1->v[2] = p3;
+			pt1->ref  = ref;
+      pt1 = &mesh->tria[++mesh->nt]; 
+			pt1->v[0] = p1;
+			pt1->v[1] = p2;
+			pt1->v[2] = p3;
+			pt1->ref  = ref;
+ 
+    }
+  }
+	/*read and store edges*/
+  if (ned) {         
+	  if ( !MMG_zaldy4(&hed,ned) ) {
+      if ( mesh->info.ddebug )  fprintf(stdout,"  ## MEMORY ALLOCATION PROBLEM : EDGES IGNORED\n"); 
+			ned = 0;
+    }   
+		mesh->ned = ned;
     rewind(inm);
-    fseek(inm,posned,SEEK_SET);
-    for (k=1; k<=ned; k++) {
+    fseek(inm,posned,SEEK_SET); 
+    for (k=1; k<=ned; k++) { 
       if (!bin)
-	fscanf(inm,"%d %d %d",&nu1,&nu2,&ref);
+        fscanf(inm,"%d %d %d",&nu1,&nu2,&ref);
       else {
-	fread(&nu1,sw,1,inm);
-	if(iswp) nu1=MMG_swapbin(nu1);
-	fread(&nu2,sw,1,inm);
-	if(iswp) nu2=MMG_swapbin(nu2);
-	fread(&ref,sw,1,inm);
-	if(iswp) ref=MMG_swapbin(ref);
-      }
-      if(MMG_edgePut(&hed,nu1,nu2,2)>1) {
-	fprintf(stdout,"  ## WARNING DOUBLE EDGE : %d %d\n",nu1,nu2);
-      }
-      mesh->point[nu1].geom = M_RIDGE_GEO;
-      mesh->point[nu2].geom = M_RIDGE_GEO;
+        fread(&nu1,sw,1,inm); 
+        if(iswp) nu1=MMG_swapbin(nu1);    
+        fread(&nu2,sw,1,inm); 
+        if(iswp) nu2=MMG_swapbin(nu2);    
+        fread(&ref,sw,1,inm); 
+        if(iswp) ref=MMG_swapbin(ref);    
+      }  
+			if(MMG_edgePut(&hed,nu1,nu2,2)>1) {
+				fprintf(stdout,"  ## WARNING DOUBLE EDGE : %d %d\n",nu1,nu2);
+			} 
+			mesh->point[nu1].geom = M_RIDGE_GEO;  
+			mesh->point[nu2].geom = M_RIDGE_GEO;  
     }
   }
 
   /* read mesh tetrahedra */
   mesh->nefixe = mesh->ne;
   rewind(inm);
-  fseek(inm,posne,SEEK_SET);
-  reorient = 0;
-  for (k=1; k<=netmp; k++) {
+  fseek(inm,posne,SEEK_SET); 
+	reorient = 0;
+  for (k=1; k<=netmp; k++) { 
     pt = &mesh->tetra[k];
-    if (!bin)
-      fscanf(inm,"%d %d %d %d %d",&pt->v[0],&pt->v[1],&pt->v[2],&pt->v[3],&ref);
-    else {
-
-      for (i=0 ; i<4 ; i++) {
-	fread(&pt->v[i],sw,1,inm);
-	if(iswp) pt->v[i]=MMG_swapbin(pt->v[i]);
-      }
-      fread(&ref,sw,1,inm);
-      if(iswp) ref=MMG_swapbin(ref);
-    }
+    if (!bin) 
+      fscanf(inm,"%d %d %d %d %d",&pt->v[0],&pt->v[1],&pt->v[2],&pt->v[3],&ref); 
+    else {                                                                        
+	
+      for (i=0 ; i<4 ; i++) { 
+        fread(&pt->v[i],sw,1,inm); 
+        if(iswp) pt->v[i]=MMG_swapbin(pt->v[i]);    
+      }
+      fread(&ref,sw,1,inm);         
+      if(iswp) ref=MMG_swapbin(ref);           
+    }  
     pt->ref  = ref;//0;//ref ;
 
     /*check orientation*/
-    volref = MMG_voltet(mesh,k);
-    if(volref < 0) {
-      reorient++;
-      tmp = pt->v[2];
-      pt->v[2] = pt->v[3];
-      pt->v[3] = tmp;
-    }
-
+		volref = MMG_voltet(mesh,k);
+		if(volref < 0) {
+		 if(!reorient) {
+		   fprintf(stdout,"\n     $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ \n");
+		   fprintf(stdout,"         BAD ORIENTATION : vol < 0 -- Some tetra will be reoriented\n");     
+		   fprintf(stdout,"     $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ \n\n");
+		   reorient = 1;        
+		 }
+		 tmp = pt->v[2];
+     pt->v[2] = pt->v[3];
+     pt->v[3] = tmp;
+		}
+	  
     for(i=0 ; i<4 ; i++)
-      pt->bdryref[i] = -1;
-
-    if (ned) {
-      for(i=0 ; i<6 ; i++) {
-	nu1 = pt->v[MMG_iare[i][0]];
-	nu2 = pt->v[MMG_iare[i][1]];
-	pt->bdryinfo[i] = MMG_edgePoint(&hed,nu1,nu2);
-      }
-
-    } else {
-      for(i=0 ; i<6 ; i++)
-	pt->bdryinfo[i] = 0;
-    }
+      pt->bdryref[i] = -1;  
+    
+		if (ned) {
+	    for(i=0 ; i<6 ; i++) {                         
+				nu1 = pt->v[MMG_iare[i][0]];
+				nu2 = pt->v[MMG_iare[i][1]];
+	      pt->bdryinfo[i] = MMG_edgePoint(&hed,nu1,nu2);
+			}  			
+			
+		} else {
+	    for(i=0 ; i<6 ; i++)
+	      pt->bdryinfo[i] = 0;  			
+		}
   }
-  if(reorient) {
-    fprintf(stdout,"\n     $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ \n");
-    fprintf(stdout,"         BAD ORIENTATION : vol < 0 -- %8d tetra reoriented\n",reorient);
-    fprintf(stdout,"     $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ \n\n");
-    reorient = 1;
-  }
-   if (ned) M_free(hed.item);
+  if (ned) M_free(hed.item); 
 
-  /*read corners*/
+  /*read corners*/ 
   if (ncor) {
     rewind(inm);
-    fseek(inm,posncor,SEEK_SET);
+    fseek(inm,posncor,SEEK_SET); 
     mesh->ncor = ncor;
-    for (k=1; k<=ncor; k++) {
+    for (k=1; k<=ncor; k++) { 
       if (!bin)
-	fscanf(inm,"%d",&ref);
+        fscanf(inm,"%d",&ref);
       else {
-	fread(&ref,sw,1,inm);
-	if(iswp) ref=MMG_swapbin(ref);
-      }
+        fread(&ref,sw,1,inm); 
+        if(iswp) ref=MMG_swapbin(ref);    
+      }  
       ppt = &mesh->point[ref];
-      ppt->geom = M_CORNER;
-    }
+      ppt->geom = M_CORNER; 
+    } 
   }
-
-
-  if ( abs(mesh->info.option)==10 ) {
+   
+	
+  if ( abs(mesh->info.option)==10 ) { 
     if(bin) {
       printf("NOT SUPPORTED\n");
       exit(0);
-    }
-    if ( !MMG_zaldy4(&hed2,3*npris+6*nhex) ) {
-      if ( mesh->info.ddebug )  fprintf(stdout,"  ## MEMORY ALLOCATION PROBLEM : PRISM IGNORED\n");
-      npris = 0;
-      nhex  = 0;
-    }
+    } 
+	  if ( !MMG_zaldy4(&hed2,3*npris+6*nhex) ) {
+      if ( mesh->info.ddebug )  fprintf(stdout,"  ## MEMORY ALLOCATION PROBLEM : PRISM IGNORED\n"); 
+			npris = 0;
+			nhex  = 0;
+    }   
 
     /*read hexa and transform to tetra*/
     rewind(inm);
-    fseek(inm,posnhex,SEEK_SET);
-    nbado = 0;
+    fseek(inm,posnhex,SEEK_SET);   
+		nbado = 0;
     for (k=1; k<=nhex; k++) {
-      ph = &listhexa[k];
-      fscanf(inm,"%d %d %d %d %d %d %d %d %d",&ph->v[0],&ph->v[1],&ph->v[2],&ph->v[3],&ph->v[4],&ph->v[5],&ph->v[6],&ph->v[7],&ph->ref);
-      //fscanf(inm,"%d %d %d %d %d %d %d %d %d",&p0,&p4,&p2,&p1,&p3,&p5,&p6,&p7,&ref);
-      //printf("hex %d : %d %d %d %d %d %d %d %d\n",k,p0,p1,p2,p3,p4,p5,p6,p7);
+			ph = &listhexa[k];   
+      fscanf(inm,"%d %d %d %d %d %d %d %d %d",&ph->v[0],&ph->v[1],&ph->v[2],&ph->v[3],&ph->v[4],&ph->v[5],&ph->v[6],&ph->v[7],&ph->ref); 
+      //fscanf(inm,"%d %d %d %d %d %d %d %d %d",&p0,&p4,&p2,&p1,&p3,&p5,&p6,&p7,&ref); 
+      //printf("hex %d : %d %d %d %d %d %d %d %d\n",k,p0,p1,p2,p3,p4,p5,p6,p7); 
       //check orientability of the hexahedra : vol of tet p0 p1 p3 p4
-      volhex = MMG_quickvol(mesh->point[ph->v[0]].c,mesh->point[ph->v[1]].c,mesh->point[ph->v[2]].c,mesh->point[ph->v[3]].c);
-      if(k==1) {
-	volref = volhex;
-	//printf("vol %e\n",volref);
-      }
-      else {
-	if(volref*volhex < 0) {
-	  fprintf(stdout,"BAD ORIENTATION OF HEXAHEDRON %d : %d %d %d %d %d %d %d %d\n",k,p0,p1,p2,p3,p4,p5,p6,p7);
-	  nbado++;
-	  tmp = ph->v[3];
-	  ph->v[3] = ph->v[1];
-	  ph->v[1] = tmp;
-	  tmp = ph->v[5];
-	  ph->v[5] = ph->v[7];
-	  ph->v[7] = tmp;
-	}
-      }
-      // MMG_cuthex(mesh,&hed2,netmp+(k-1)*6,ph->v[0],ph->v[1],ph->v[2],ph->v[3],ph->v[4],ph->v[5],ph->v[6],ph->v[7],ph->ref);
-    }
-    fprintf(stdout,"%8d HEXA REORIENTED\n",nbado);
+			volhex = MMG_quickvol(mesh->point[ph->v[0]].c,mesh->point[ph->v[1]].c,mesh->point[ph->v[2]].c,mesh->point[ph->v[3]].c);
+			if(k==1) {
+				volref = volhex; 
+				//printf("vol %e\n",volref);
+			}
+			else {
+				if(volref*volhex < 0) {
+					fprintf(stdout,"BAD ORIENTATION OF HEXAHEDRON %d : %d %d %d %d %d %d %d %d\n",k,p0,p1,p2,p3,p4,p5,p6,p7);
+					nbado++;
+					tmp = ph->v[3];
+					ph->v[3] = ph->v[1];
+					ph->v[1] = tmp;
+					tmp = ph->v[5];
+					ph->v[5] = ph->v[7];
+					ph->v[7] = tmp;
+				}
+			} 
+			// MMG_cuthex(mesh,&hed2,netmp+(k-1)*6,ph->v[0],ph->v[1],ph->v[2],ph->v[3],ph->v[4],ph->v[5],ph->v[6],ph->v[7],ph->ref);
+    }  
+		fprintf(stdout,"%8d HEXA REORIENTED\n",nbado);
 
-    if(!MMG_hashHexa(listhexa,adjahex,nhex)) return(0);
-    MMG_cuthex(mesh,&hed2,listhexa,adjahex,nhex,netmp);
+		if(!MMG_hashHexa(listhexa,adjahex,nhex)) return(0);  
+	  MMG_cuthex(mesh,&hed2,listhexa,adjahex,nhex,netmp); 
     /*read prism and transform to tetra
-      ---> compatibility pbs ==> hash edge and switch case*/
+		---> compatibility pbs ==> hash edge and switch case*/  
     rewind(inm);
-    fseek(inm,posnpris,SEEK_SET);
-    nimp = 0;
-    ne = netmp+6*nhex;
+    fseek(inm,posnpris,SEEK_SET); 
+		nimp = 0; 
+		ne = netmp+6*nhex;
     for (k=1; k<=npris; k++) {
-      fscanf(inm,"%d %d %d %d %d %d %d",&p0,&p1,&p2,&p3,&p4,&p5,&ref);
-      if(!MMG_cutprism(mesh,&hed2,ne,p0,p1,p2,p3,p4,p5,ref))
-	{
-	  if(mesh->info.imprim < 0 ) fprintf(stdout,"DECOMPOSITION PRISM INVALID \n\n");
-	  mesh->ne += 5;
-	  ne += 8;
-	  nimp++;
-	  continue;
-	}
-      ne += 3;
+      fscanf(inm,"%d %d %d %d %d %d %d",&p0,&p1,&p2,&p3,&p4,&p5,&ref); 
+			if(!MMG_cutprism(mesh,&hed2,ne,p0,p1,p2,p3,p4,p5,ref))
+			{
+				if(mesh->info.imprim < 0 ) fprintf(stdout,"DECOMPOSITION PRISM INVALID \n\n"); 
+				mesh->ne += 5;
+				ne += 8;
+				nimp++; 
+				continue;
+			}
+			ne += 3;
     }
-    if(abs(mesh->info.imprim) > 3 )fprintf(stdout,"     %d INVALID DECOMPOSITION\n\n",nimp);
+		if(abs(mesh->info.imprim) > 3 )fprintf(stdout,"     %d INVALID DECOMPOSITION\n\n",nimp);
   }
-
+  
   if ( abs(mesh->info.imprim) > 3 && abs(mesh->info.option)!=10 ) {
     fprintf(stdout,"     NUMBER OF GIVEN VERTICES   %8d\n",mesh->npfixe);
     if ( mesh->ntfixe )
@@ -609,24 +1041,26 @@
     if ( ned )
       fprintf(stdout,"     NUMBER OF GIVEN EDGES      %8d\n",ned);
   }
-  fclose(inm);
-  return(1);
+ fclose(inm);
+ return(1);
 }
 
 
 /* load solution (metric) */
-int MMG_loadSol(pSol sol,char *filename,int npmax) {
-  FILE       *inm;
+int MMG_loadSol(pSol sol,char *filename,int npmax,void *dataff) { 
+  FILE       *inm;   
   float       fsol;
-  double      tmp;
+  double      tmp;       
   int         binch,bdim,iswp;
   int         k,i,isol,type,bin,dim,btyp,bpos;
   long        posnp;
   char        *ptr,data[128],chaine[128];
-
-  posnp = 0;
+    if(dataff) 
+	return MMG_loadSolff( sol,filename,npmax,(DataFF*) dataff);
+  
+  posnp = 0; 
   bin   = 0;
-  iswp  = 0;
+  iswp  = 0; 
 
   strcpy(data,filename);
   ptr = strstr(data,".mesh");
@@ -645,94 +1079,94 @@
   }
   fprintf(stdout,"  %%%% %s OPENED\n",data);
 
-
-  if(!bin) {
+   
+  if(!bin) {   
     strcpy(chaine,"DDD");
-    while(fscanf(inm,"%s",&chaine[0])!=EOF && strncmp(chaine,"End",strlen("End")) ) {
+    while(fscanf(inm,"%s",&chaine[0])!=EOF && strncmp(chaine,"End",strlen("End")) ) { 
       if(!strncmp(chaine,"Dimension",strlen("Dimension"))) {
-	fscanf(inm,"%d",&dim);
-	if(dim!=3) {
-	  fprintf(stdout,"BAD SOL DIMENSION : %d\n",dim);
-	  return(1);
-	}
-	continue;
+          fscanf(inm,"%d",&dim);
+          if(dim!=3) {
+            fprintf(stdout,"BAD SOL DIMENSION : %d\n",dim); 
+            return(1);
+          }
+          continue;
       } else if(!strncmp(chaine,"SolAtVertices",strlen("SolAtVertices"))) {
-	fscanf(inm,"%d",&sol->np);
-	fscanf(inm,"%d",&type);
-	if(type!=1) {
-	  fprintf(stdout,"SEVERAL SOLUTION => IGNORED : %d\n",type);
-	  return(1);
-	}
-	fscanf(inm,"%d",&btyp);
-	posnp = ftell(inm);
-	break;
-      }
-    }
-  } else {
-    fread(&binch,sw,1,inm);
-    iswp=0;
-    if(binch==16777216) iswp=1;
+        fscanf(inm,"%d",&sol->np); 
+        fscanf(inm,"%d",&type); 
+        if(type!=1) {
+          fprintf(stdout,"SEVERAL SOLUTION => IGNORED : %d\n",type);
+          return(1);
+        }
+        fscanf(inm,"%d",&btyp);
+        posnp = ftell(inm);
+        break;
+      } 
+    }            
+  } else {     
+    fread(&binch,sw,1,inm); 
+    iswp=0;   
+    if(binch==16777216) iswp=1;    
     else if(binch!=1) {
       fprintf(stdout,"BAD FILE ENCODING\n");
-    }
-    fread(&sol->ver,sw,1,inm);
-    if(iswp) sol->ver = MMG_swapbin(sol->ver);
+    } 
+    fread(&sol->ver,sw,1,inm); 
+    if(iswp) sol->ver = MMG_swapbin(sol->ver); 
     while(fread(&binch,sw,1,inm)!=EOF && binch!=54 ) {
-      if(iswp) binch=MMG_swapbin(binch);
-      if(binch==54) break;
+      if(iswp) binch=MMG_swapbin(binch);      
+      if(binch==54) break;  
       if(binch==3) {  //Dimension
-	fread(&bdim,sw,1,inm);  //NulPos=>20
-	if(iswp) bdim=MMG_swapbin(bdim);
-	fread(&bdim,sw,1,inm);
-	if(iswp) bdim=MMG_swapbin(bdim);
-	if(bdim!=3) {
-	  fprintf(stdout,"BAD SOL DIMENSION : %d\n",dim);
-	  exit(0);
-	  return(1);
-	}
-	continue;
+        fread(&bdim,sw,1,inm);  //NulPos=>20
+        if(iswp) bdim=MMG_swapbin(bdim);
+        fread(&bdim,sw,1,inm);
+        if(iswp) bdim=MMG_swapbin(bdim);
+        if(bdim!=3) {
+          fprintf(stdout,"BAD SOL DIMENSION : %d\n",dim);
+          exit(0);
+          return(1);
+        }
+        continue;
       } else if(binch==62) {  //SolAtVertices
-	fread(&binch,sw,1,inm); //NulPos
-	if(iswp) binch=MMG_swapbin(binch);
-	fread(&sol->np,sw,1,inm);
-	if(iswp) sol->np=MMG_swapbin(sol->np);
-	fread(&binch,sw,1,inm); //nb sol
-	if(iswp) binch=MMG_swapbin(binch);
-	if(binch!=1) {
-	  fprintf(stdout,"SEVERAL SOLUTION => IGNORED : %d\n",type);
-	  return(1);
-	}
-	fread(&btyp,sw,1,inm); //typsol
-	if(iswp) btyp=MMG_swapbin(btyp);
-	posnp = ftell(inm);
-	break;
+        fread(&binch,sw,1,inm); //NulPos
+        if(iswp) binch=MMG_swapbin(binch);
+        fread(&sol->np,sw,1,inm); 
+        if(iswp) sol->np=MMG_swapbin(sol->np);
+        fread(&binch,sw,1,inm); //nb sol
+        if(iswp) binch=MMG_swapbin(binch);
+        if(binch!=1) {
+          fprintf(stdout,"SEVERAL SOLUTION => IGNORED : %d\n",type);
+          return(1);
+        }
+        fread(&btyp,sw,1,inm); //typsol
+        if(iswp) btyp=MMG_swapbin(btyp);
+        posnp = ftell(inm);
+        break;
       } else {
-	fread(&bpos,sw,1,inm); //Pos
-	if(iswp) bpos=MMG_swapbin(bpos);
-	rewind(inm);
-	fseek(inm,bpos,SEEK_SET);
-      }
-    }
-
-  }
+        fread(&bpos,sw,1,inm); //Pos 
+        if(iswp) bpos=MMG_swapbin(bpos);
+        rewind(inm);
+        fseek(inm,bpos,SEEK_SET);        
+      } 
+    }            
+    
+  }       
   if ( !sol->np ) {
-    fprintf(stdout,"  ** MISSING DATA\n");
+    fprintf(stdout,"  ** MISSING DATA ss\n");
     return(1);
   }
 
   if ( btyp!= 1 && btyp!=3 ) {
-    fprintf(stdout,"  ** DATA IGNORED\n");
+    fprintf(stdout,"  ** DATA IGNORED %d\n",btyp);
     sol->np = 0;
     return(1);
   }
-
+  
   sol->offset = (btyp==1) ? 1 : 6;
 
   if ( abs(MMG_imprim) > 5 )
     fprintf(stdout,"  -- READING DATA FILE %s\n",data);
 
   if ( !sol->np ) {
-    fprintf(stdout,"  ** MISSING DATA\n");
+    fprintf(stdout,"  ** MISSING DATA xx\n");
     return(0);
   }
   sol->npfixe = sol->np;
@@ -742,31 +1176,31 @@
   /* read mesh solutions */
   sol->npfixe = sol->np;
   rewind(inm);
-  fseek(inm,posnp,SEEK_SET);
+  fseek(inm,posnp,SEEK_SET);  
   for (k=1; k<=sol->np; k++) {
     isol = (k-1) * sol->offset + 1;
-    if (sol->ver == 1) {
+    if (sol->ver == 1) { 
       for (i=0; i<sol->offset; i++) {
-	if(!bin){
-	  fscanf(inm,"%f",&fsol);
-	  sol->met[isol + i] = (double) fsol;
-	} else {
-	  fread(&fsol,sw,1,inm);
-	  if(iswp) fsol=MMG_swapf(fsol);
-	  sol->met[isol + i] = (double) fsol;
-	}
-      }
+        if(!bin){
+          fscanf(inm,"%f",&fsol);    
+          sol->met[isol + i] = (double) fsol;
+        } else {
+          fread(&fsol,sw,1,inm);             
+          if(iswp) fsol=MMG_swapf(fsol);
+          sol->met[isol + i] = (double) fsol;
+        }
+      } 
     } else {
       for (i=0; i<sol->offset; i++) {
-	if(!bin){
-	  fscanf(inm,"%lf",&sol->met[isol + i]);
+        if(!bin){
+          fscanf(inm,"%lf",&sol->met[isol + i]); 
 
-	} else {
-	  fread(&sol->met[isol + i],sd,1,inm);
-	  if(iswp) sol->met[isol + i]=MMG_swapd(sol->met[isol + i]);
-	}
-      }
-    }
+        } else {
+          fread(&sol->met[isol + i],sd,1,inm);       
+          if(iswp) sol->met[isol + i]=MMG_swapd(sol->met[isol + i]);
+        } 
+      } 
+    }             
     /* MMG_swap data */
     if ( sol->offset == 6 ) {
       tmp                = sol->met[isol + 2];
@@ -778,13 +1212,13 @@
   if ( abs(MMG_imprim) > 3 )
     fprintf(stdout,"     NUMBER OF GIVEN DATA       %8d\n",sol->npfixe);
 
-  fclose(inm);
-  return(1);
+  fclose(inm);   
+  return(1);  
 }
 
 
-int MMG_loadVect(pMesh mesh,char *filename,int npmax) {
-  FILE       *inm;
+int MMG_loadVect(pMesh mesh,char *filename,int npmax,void *dataff) {
+  FILE       *inm;   
   pDispl       pd;
   float       fsol;
   int         binch,bdim,iswp;
@@ -792,10 +1226,13 @@
   long        posnp;
   char        *ptr,data[128],chaine[128];
 
-  pd = mesh->disp;
+  if(dataff) 
+      return MMG_loadVectff( mesh, filename,npmax,(DataFF*) dataff);
 
-  posnp = 0;
-  bin   = 0;
+  pd = mesh->disp;
+  
+  posnp = 0; 
+  bin   = 0; 
   iswp  = 0;
 
   strcpy(data,filename);
@@ -815,76 +1252,76 @@
   }
   fprintf(stdout,"  %%%% %s OPENED\n",data);
 
-
-  if(!bin) {
+   
+  if(!bin) {   
     strcpy(chaine,"DDD");
-    while(fscanf(inm,"%s",&chaine[0])!=EOF && strncmp(chaine,"End",strlen("End")) ) {
+    while(fscanf(inm,"%s",&chaine[0])!=EOF && strncmp(chaine,"End",strlen("End")) ) { 
       if(!strncmp(chaine,"Dimension",strlen("Dimension"))) {
-	fscanf(inm,"%d",&dim);
-	if(dim!=3) {
-	  fprintf(stdout,"BAD SOL DIMENSION : %d\n",dim);
-	  return(1);
-	}
-	continue;
+          fscanf(inm,"%d",&dim);
+          if(dim!=3) {
+            fprintf(stdout,"BAD SOL DIMENSION : %d\n",dim); 
+            return(1);
+          }
+          continue;
       } else if(!strncmp(chaine,"SolAtVertices",strlen("SolAtVertices"))) {
-	fscanf(inm,"%d",&pd->np);
-	fscanf(inm,"%d",&type);
-	if(type!=1) {
-	  fprintf(stdout,"SEVERAL SOLUTION => IGNORED : %d\n",type);
-	  return(1);
-	}
-	fscanf(inm,"%d",&btyp);
-	posnp = ftell(inm);
-	break;
-      }
-    }
-  } else {
-    fread(&pd->ver,sw,1,inm);
-    iswp=0;
-    if(pd->ver==16777216) iswp=1;
+        fscanf(inm,"%d",&pd->np); 
+        fscanf(inm,"%d",&type); 
+        if(type!=1) {
+          fprintf(stdout,"SEVERAL SOLUTION => IGNORED : %d\n",type);
+          return(1);
+        }
+        fscanf(inm,"%d",&btyp);
+        posnp = ftell(inm);
+        break;
+      } 
+    }            
+  } else {     
+    fread(&pd->ver,sw,1,inm); 
+    iswp=0;   
+    if(pd->ver==16777216) iswp=1;    
     else if(pd->ver!=1) {
       fprintf(stdout,"BAD FILE ENCODING\n");
-    }
-    fread(&pd->ver,sw,1,inm);
-    if(iswp) pd->ver = MMG_swapbin(pd->ver);
+    } 
+    fread(&pd->ver,sw,1,inm); 
+    if(iswp) pd->ver = MMG_swapbin(pd->ver); 
     while(fread(&binch,sw,1,inm)!=EOF && binch!=54 ) {
-      if(iswp) binch=MMG_swapbin(binch);
-      if(binch==54) break;
+      if(iswp) binch=MMG_swapbin(binch);      
+      if(binch==54) break;  
       if(binch==3) {  //Dimension
-	fread(&bdim,sw,1,inm);  //Pos=>20
-	if(iswp) bdim=MMG_swapbin(bdim);
-	fread(&bdim,sw,1,inm);
-	if(iswp) bdim=MMG_swapbin(bdim);
-	if(bdim!=3) {
-	  fprintf(stdout,"BAD SOL DIMENSION : %d\n",dim);
-	  exit(0);
-	  return(1);
-	}
-	continue;
+        fread(&bdim,sw,1,inm);  //Pos=>20
+        if(iswp) bdim=MMG_swapbin(bdim);      
+        fread(&bdim,sw,1,inm);
+        if(iswp) bdim=MMG_swapbin(bdim);      
+        if(bdim!=3) {
+          fprintf(stdout,"BAD SOL DIMENSION : %d\n",dim);
+          exit(0);
+          return(1);
+        }
+        continue;
       } else if(binch==62) {  //SolAtVertices
-	fread(&binch,sw,1,inm); //Pos
-	if(iswp) binch=MMG_swapbin(binch);
-	fread(&pd->np,sw,1,inm);
-	if(iswp) pd->np=MMG_swapbin(pd->np);
-	fread(&binch,sw,1,inm); //nb sol
-	if(iswp) binch=MMG_swapbin(binch);
-	if(binch!=1) {
-	  fprintf(stdout,"SEVERAL SOLUTION => IGNORED : %d\n",type);
-	  return(1);
-	}
-	fread(&btyp,sw,1,inm); //typsol
-	if(iswp) btyp=MMG_swapbin(btyp);
-	posnp = ftell(inm);
-	break;
+        fread(&binch,sw,1,inm); //Pos
+        if(iswp) binch=MMG_swapbin(binch);      
+        fread(&pd->np,sw,1,inm); 
+        if(iswp) pd->np=MMG_swapbin(pd->np);      
+        fread(&binch,sw,1,inm); //nb sol
+        if(iswp) binch=MMG_swapbin(binch);      
+        if(binch!=1) {
+          fprintf(stdout,"SEVERAL SOLUTION => IGNORED : %d\n",type);
+          return(1);
+        }
+        fread(&btyp,sw,1,inm); //typsol
+        if(iswp) btyp=MMG_swapbin(btyp);      
+        posnp = ftell(inm);
+        break;
       } else {
-	fread(&bpos,sw,1,inm); //Pos
-	if(iswp) bpos=MMG_swapbin(bpos);
-	rewind(inm);
-	fseek(inm,bpos,SEEK_SET);
-      }
-    }
-
-  }
+        fread(&bpos,sw,1,inm); //Pos 
+        if(iswp) bpos=MMG_swapbin(bpos);      
+        rewind(inm);
+        fseek(inm,bpos,SEEK_SET);        
+      } 
+    }            
+    
+  }       
   if ( !pd->np ) {
     fprintf(stdout,"  ** MISSING DATA\n");
     return(0);
@@ -895,7 +1332,7 @@
   }
 
   if ( btyp != 2 ) {
-    fprintf(stdout,"  ** DATA IGNORED\n");
+    fprintf(stdout,"  ** DATA IGNORED %d !=2\n",btyp);
     return(0);
   }
 
@@ -907,47 +1344,50 @@
   fseek(inm,posnp,SEEK_SET);
   for (k=1; k<=pd->np; k++) {
     iadr = (k - 1) * 3 + 1;
-    if (pd->ver < 2) {
+    if (pd->ver < 2) { 
       for (i=0; i<3; i++) {
-	if(!bin){
-	  fscanf(inm,"%f",&fsol);
-	  pd->mv[iadr + i] = (double) fsol;
-	} else {
-	  fread(&fsol,sw,1,inm);
-	  if(iswp) fsol=MMG_swapf(fsol);
-	  pd->mv[iadr + i] = (double) fsol;
-	}
-      }
+        if(!bin){
+          fscanf(inm,"%f",&fsol); 
+          pd->mv[iadr + i] = (double) fsol;
+        } else {
+          fread(&fsol,sw,1,inm);             
+          if(iswp) fsol=MMG_swapf(fsol);      
+          pd->mv[iadr + i] = (double) fsol;
+        }
+      } 
     } else {
       for (i=0; i<3; i++) {
-	if(!bin){
-	  fscanf(inm,"%lf",&pd->mv[iadr + i]);
-	} else {
-	  fread(&pd->mv[iadr + i],sd,1,inm);
-	  if(iswp) pd->mv[iadr + i]=MMG_swapd(pd->mv[iadr + i]);
-	}
-      }
-    }
+        if(!bin){
+          fscanf(inm,"%lf",&pd->mv[iadr + i]); 
+        } else {
+          fread(&pd->mv[iadr + i],sd,1,inm);
+          if(iswp) pd->mv[iadr + i]=MMG_swapd(pd->mv[iadr + i]);      
+        } 
+      } 
+    }             
   }
 
   if ( abs(mesh->info.imprim) > 3 )
     fprintf(stdout,"     NUMBER OF GIVEN DATA       %8d\n",pd->np);
 
-  fclose(inm);
+  fclose(inm); 
   return(1);
 }
 
 
 /* save mesh to disk */
-int MMG_saveMesh(pMesh mesh,char *filename) {
-  FILE*        inm;
-  Hedge                          hed;
+int MMG_saveMesh(pMesh mesh,char *filename,void *dataff) {  
+  FILE*        inm; 
+	Hedge				 hed;
   pPoint       ppt;
   pTria        pt1;
   pTetra       pt;
   int          i,k,np,ne,nc,ned,*cor,*ed,ref,bin,bpos;
-  char        *ptr,data[128],chaine[128];
+  char        *ptr,data[128],chaine[128]; 
   int          binch,nu1,nu2;
+  if(dataff) 
+      return MMG_saveMeshff( mesh, filename,(DataFF*)  dataff);
+
   mesh->ver = 2; //double precision
   bin = 0;
   strcpy(data,filename);
@@ -959,28 +1399,28 @@
       *ptr = '\0';
       strcat(data,".mesh");
       if( !(inm = fopen(data,"w")) ) {
-	fprintf(stderr,"  ** UNABLE TO OPEN %s.\n",data);
-	return(0);
+        fprintf(stderr,"  ** UNABLE TO OPEN %s.\n",data);
+        return(0);
       }
     } else {
-      bin = 1;
+      bin = 1;   
     }
   }
-  else {
+  else { 
     ptr = strstr(data,".meshb");
     if( ptr ) bin = 1;
     if( !(inm = fopen(data,"w")) ) {
       fprintf(stderr,"  ** UNABLE TO OPEN %s.\n",data);
       return(0);
-    }
+    } 
   }
   fprintf(stdout,"  %%%% %s OPENED\n",data);
 
   /*entete fichier*/
   if(!bin) {
-    strcpy(&chaine[0],"MeshVersionFormatted 2\n");
+    strcpy(&chaine[0],"MeshVersionFormatted 2\n"); 
     fprintf(inm,"%s",chaine);
-    strcpy(&chaine[0],"\n\nDimension 3\n");
+    strcpy(&chaine[0],"\n\nDimension 3\n"); 
     fprintf(inm,"%s ",chaine);
   } else {
     binch = 1; //MeshVersionFormatted
@@ -993,33 +1433,38 @@
     fwrite(&bpos,sw,1,inm);
     binch = 3;
     fwrite(&binch,sw,1,inm);
-
+    
   }
 
   /* compact vertices */
-  if(mesh->ncor) {
+  if(mesh->ncor) {   
     cor = (int*) M_calloc(mesh->ncor,sizeof(int),"MMG_savemesh");
-    assert(cor);
+    assert(cor);   
   }
-  if(mesh->ned) {
-    if ( !MMG_zaldy4(&hed,mesh->ned) ) {
-      if ( mesh->info.ddebug )  fprintf(stdout,"  ## MEMORY ALLOCATION PROBLEM : EXPORT EDGES IGNORED\n");
-      mesh->ned = 0;
-    }
+  if(mesh->ned) {   
+	  if ( !MMG_zaldy4(&hed,mesh->ned) ) {
+      if ( mesh->info.ddebug )  fprintf(stdout,"  ## MEMORY ALLOCATION PROBLEM : EXPORT EDGES IGNORED\n"); 
+			mesh->ned = 0;
+    }   
     ed = (int*)M_calloc(2*mesh->ned,sizeof(int),"MMG_savemesh");
-    assert(ed);
+    assert(ed);   
   }
-  np = 0;
+  np = 0; 
   nc = 0;
   for (k=1; k<=mesh->np; k++) {
     ppt = &mesh->point[k];
-    if ( ppt->tag & M_UNUSED )  continue;
-    ppt->tmp = ++np;
+    if ( ppt->tag & M_UNUSED )  continue;  
+		ppt->tmp = ++np;  
     if ( ppt->geom & M_CORNER )  cor[nc++] = ppt->tmp;
+  } 
+  //assert(mesh->ncor==nc);
+  if(mesh->ncor!=nc) {
+    fprintf(stdout,"WARNING: some corners have been added or deleted\n");
+    mesh->ncor = nc;
   }
-  assert(mesh->ncor==nc);
+
   if(!bin) {
-    strcpy(&chaine[0],"\n\nVertices\n");
+    strcpy(&chaine[0],"\n\nVertices\n"); 
     fprintf(inm,"%s",chaine);
     fprintf(inm,"%d\n",np);
   } else {
@@ -1027,27 +1472,27 @@
     fwrite(&binch,sw,1,inm);
     bpos += 12+(1+3*mesh->ver)*4*np; //NullPos
     fwrite(&bpos,sw,1,inm);
-    fwrite(&np,sw,1,inm);
+    fwrite(&np,sw,1,inm);    
   }
   for(k=1; k<=mesh->np; k++) {
     ppt = &mesh->point[k];
-    if ( ppt->tag & M_UNUSED )  continue;
-    //if(ppt->tmp==52453) printf("point %d --> %d\n",ppt->tmp,k);
+    if ( ppt->tag & M_UNUSED )  continue;  
+		//if(ppt->tmp==52453) printf("point %d --> %d\n",ppt->tmp,k);
     if(!bin) {
       fprintf(inm,"%.15lg %.15lg %.15lg %d\n",ppt->c[0],ppt->c[1],ppt->c[2],ppt->ref);
     } else {
-      fwrite((unsigned char*)&ppt->c[0],sd,1,inm);
-      fwrite((unsigned char*)&ppt->c[1],sd,1,inm);
-      fwrite((unsigned char*)&ppt->c[2],sd,1,inm);
-      fwrite((unsigned char*)&ppt->ref,sw,1,inm);
+      fwrite((unsigned char*)&ppt->c[0],sd,1,inm);    
+      fwrite((unsigned char*)&ppt->c[1],sd,1,inm);    
+      fwrite((unsigned char*)&ppt->c[2],sd,1,inm);    
+      fwrite((unsigned char*)&ppt->ref,sw,1,inm);    
     }
   }
 
-  /* rebuild triangles tabular and write triangles */
+  /* rebuild triangles tabular and write triangles */ 
   mesh->nt = 0;
   if(MMG_markBdry(mesh)) {
     if(!bin) {
-      strcpy(&chaine[0],"\n\nTriangles\n");
+      strcpy(&chaine[0],"\n\nTriangles\n"); 
       fprintf(inm,"%s",chaine);
       fprintf(inm,"%d \n",mesh->nt);
     } else {
@@ -1055,49 +1500,48 @@
       fwrite(&binch,sw,1,inm);
       bpos += 12+16*mesh->nt; //Pos
       fwrite(&bpos,sw,1,inm);
-      fwrite(&mesh->nt,sw,1,inm);
+      fwrite(&mesh->nt,sw,1,inm);    
     }
     for (k=1; k<=mesh->nt; k++) {
       pt1  = &mesh->tria[k];
-      ref  = pt1->ref;
+  	    ref  = pt1->ref;    
       if(!bin) {
-	//if(ref==0) printf("tr %d bad ref!!\n",k);
-	fprintf(inm,"%d %d %d %d\n",mesh->point[pt1->v[0]].tmp,mesh->point[pt1->v[1]].tmp
-		,mesh->point[pt1->v[2]].tmp,ref);
+        fprintf(inm,"%d %d %d %d\n",mesh->point[pt1->v[0]].tmp,mesh->point[pt1->v[1]].tmp
+    							  ,mesh->point[pt1->v[2]].tmp,ref);
       } else {
-	fwrite(&mesh->point[pt1->v[0]].tmp,sw,1,inm);
-	fwrite(&mesh->point[pt1->v[1]].tmp,sw,1,inm);
-	fwrite(&mesh->point[pt1->v[2]].tmp,sw,1,inm);
-	fwrite(&ref,sw,1,inm);
+        fwrite(&mesh->point[pt1->v[0]].tmp,sw,1,inm);    
+        fwrite(&mesh->point[pt1->v[1]].tmp,sw,1,inm);    
+        fwrite(&mesh->point[pt1->v[2]].tmp,sw,1,inm);    
+        fwrite(&ref,sw,1,inm);    
       }
     }
-  }
-
+  }   
+ 
   /* write tetrahedra */
-  ne = 0;
-  ned = 0;
-  //printf("avt %d\n",mesh->ned);
+  ne = 0; 
+	ned = 0;  
+	//printf("avt %d\n",mesh->ned);
   for (k=1; k<=mesh->ne; k++) {
     pt = &mesh->tetra[k];
-    if ( !pt->v[0] )  continue;
-    if(mesh->ned) {
-      for (i=0 ; i<6 ; i++) {
-	if (pt->bdryinfo[i]) {
-	  nu1 = pt->v[MMG_iare[i][0]];
-	  nu2 = pt->v[MMG_iare[i][1]];
-	  if (MMG_edgePut(&hed,nu1,nu2,2)<=1) {
-	    ed[2*ned] = (mesh->point[nu1]).tmp;
-	    ed[2*ned + 1] = (mesh->point[nu2]).tmp;
-	    ned++;
-	  }
-	}
-      }
-    }
-    ne++;
+    if ( !pt->v[0] )  continue;  
+		if(mesh->ned) {
+		  for (i=0 ; i<6 ; i++) {
+		  	if (pt->bdryinfo[i]) {
+		  		nu1 = pt->v[MMG_iare[i][0]];
+		  		nu2 = pt->v[MMG_iare[i][1]];
+		  		if (MMG_edgePut(&hed,nu1,nu2,2)<=1) {
+		  			ed[2*ned] = (mesh->point[nu1]).tmp;
+		  			ed[2*ned + 1] = (mesh->point[nu2]).tmp;
+		  			ned++;
+		  		} 
+		  	}
+		  } 
+		}
+	  ne++;  
   }
-  //printf("ned %d\n",ned);
+	//printf("ned %d\n",ned);
   if(!bin) {
-    strcpy(&chaine[0],"\n\nTetrahedra\n");
+    strcpy(&chaine[0],"\n\nTetrahedra\n"); 
     fprintf(inm,"%s",chaine);
     fprintf(inm,"%d\n",ne);
   } else {
@@ -1105,29 +1549,29 @@
     fwrite(&binch,sw,1,inm);
     bpos += 12 + 20*ne;//Pos
     fwrite(&bpos,sw,1,inm);
-    fwrite((unsigned char*)&ne,sw,1,inm);
-  }
-  ne=0;
+    fwrite((unsigned char*)&ne,sw,1,inm);    
+  } 
+	ne=0;
   for (k=1; k<=mesh->ne; k++) {
     pt = &mesh->tetra[k];
-    if ( !pt->v[0] )  continue;
-    ne++;
-    ref = pt->ref;
+    if ( !pt->v[0] )  continue;  
+		ne++; 
+    ref = pt->ref;    
     if(!bin) {
       fprintf(inm,"%d %d %d %d %d\n",mesh->point[pt->v[0]].tmp,mesh->point[pt->v[1]].tmp
-	      ,mesh->point[pt->v[2]].tmp,mesh->point[pt->v[3]].tmp,ref);
+  							   ,mesh->point[pt->v[2]].tmp,mesh->point[pt->v[3]].tmp,ref);
     } else {
-      fwrite(&mesh->point[pt->v[0]].tmp,sw,1,inm);
-      fwrite(&mesh->point[pt->v[1]].tmp,sw,1,inm);
-      fwrite(&mesh->point[pt->v[2]].tmp,sw,1,inm);
-      fwrite(&mesh->point[pt->v[3]].tmp,sw,1,inm);
-      fwrite(&ref,sw,1,inm);
+      fwrite(&mesh->point[pt->v[0]].tmp,sw,1,inm);    
+      fwrite(&mesh->point[pt->v[1]].tmp,sw,1,inm);    
+      fwrite(&mesh->point[pt->v[2]].tmp,sw,1,inm);    
+      fwrite(&mesh->point[pt->v[3]].tmp,sw,1,inm);    
+      fwrite(&ref,sw,1,inm);    
     }
-  }
-
+  }  
+     
   if(mesh->ned) {
     if(!bin) {
-      strcpy(&chaine[0],"\n\nEdges\n");
+      strcpy(&chaine[0],"\n\nEdges\n"); 
       fprintf(inm,"%s",chaine);
       fprintf(inm,"%d\n",ned);
     } else {
@@ -1135,50 +1579,50 @@
       fwrite(&binch,sw,1,inm);
       bpos += 12 + 3*4*ned;//Pos
       fwrite(&bpos,sw,1,inm);
-      fwrite((unsigned char*)&ned,sw,1,inm);
-    }
-    for (k=0; k<ned; k++) {
-      ref = 0;
-      if(!bin) {
-	fprintf(inm,"%d %d %d \n",ed[2*k],ed[2*k+1],ref);
-      } else {
-	fwrite(&ed[2*k],sw,1,inm);
-	fwrite(&ed[2*k+1],sw,1,inm);
-	fwrite(&ref,sw,1,inm);
-      }
-    }
-    M_free(hed.item);
-    M_free(ed);
+      fwrite((unsigned char*)&ned,sw,1,inm);    
+    } 
+  	  for (k=0; k<ned; k++) {
+   	    ref = 0;    
+  	    if(!bin) {
+  	      fprintf(inm,"%d %d %d \n",ed[2*k],ed[2*k+1],ref);
+  	    } else {
+  	      fwrite(&ed[2*k],sw,1,inm);    
+  	      fwrite(&ed[2*k+1],sw,1,inm);    
+  	      fwrite(&ref,sw,1,inm);    
+  	    }
+  	  }
+  	  M_free(hed.item);
+			M_free(ed);
   }
-
+  
   /* write corners */
   if(!bin) {
-    strcpy(&chaine[0],"\n\nCorners\n");
+    strcpy(&chaine[0],"\n\nCorners\n"); 
     fprintf(inm,"%s",chaine);
     fprintf(inm,"%d\n",mesh->ncor);
   } else {
     binch = 13; //Corners
     fwrite(&binch,sw,1,inm);
-    bpos += 12 + 4*mesh->ncor;//Pos
+    bpos += 12 + 4*mesh->ncor;//Pos  
     fwrite(&bpos,sw,1,inm);
-    fwrite((unsigned char*)&mesh->ncor,sw,1,inm);
+    fwrite((unsigned char*)&mesh->ncor,sw,1,inm);    
   }
   for (k=0; k<mesh->ncor; k++) {
     if(!bin) {
       fprintf(inm,"%d \n",cor[k]);
     } else {
-      fwrite(&cor[k],sw,1,inm);
+      fwrite(&cor[k],sw,1,inm);    
     }
-  }
+  }  
   /*fin fichier*/
   if(!bin) {
-    strcpy(&chaine[0],"\n\nEnd\n");
+    strcpy(&chaine[0],"\n\nEnd\n"); 
     fprintf(inm,"%s",chaine);
   } else {
     binch = 54; //End
     fwrite(&binch,sw,1,inm);
   }
-  fclose(inm);
+  fclose(inm); 
   if(mesh->ncor) M_free(cor);
   if ( mesh->info.imprim ) {
     fprintf(stdout,"     NUMBER OF GIVEN VERTICES   %8d\n",mesh->npfixe);
@@ -1193,20 +1637,22 @@
     if ( mesh->ned )
       fprintf(stdout,"     TOTAL NUMBER OF EDGES      %8d\n",ned);
   }
-  //if(ned!=mesh->ned) exit(0);
+	//if(ned!=mesh->ned) exit(0);
   return(1);
 
 }
 
 
-int MMG_saveSol(pMesh mesh,pSol sol,char *filename) {
+int MMG_saveSol(pMesh mesh,pSol sol,char *filename,void *dataff) {
   FILE*        inm;
   pPoint       ppt;
   float        fsol;
   double       tmp;
   int          i,k,nbl,isol,bin,bpos,typ;
-  char        *ptr,data[128],chaine[128];
+  char        *ptr,data[128],chaine[128]; 
   int          binch;
+  if(dataff) 
+      return MMG_saveSolff( mesh, sol, filename,(DataFF*) dataff);
 
   if ( !sol->np )  return(1);
   bin = 1;
@@ -1219,24 +1665,24 @@
       *ptr = '\0';
       bin  = 0;
     } else {
-      ptr = strstr(data,".solb");
-      if ( ptr ) {
-	*ptr = '\0';
-	bin  = 1;
+	    ptr = strstr(data,".solb");
+	    if ( ptr ) {
+	      *ptr = '\0';
+	      bin  = 1;	
       } else {
-	ptr = strstr(data,".sol");
-	if ( ptr ) {
-	  *ptr = '\0';
-	  bin  = 0;
-	}
-      }
-    }
+			  ptr = strstr(data,".sol");
+			  if ( ptr ) {
+			    *ptr = '\0';
+			    bin  = 0;	
+			  }
+			}
+    } 
   }
-  if ( bin )
+  if ( bin ) 
     strcat(data,".solb");
   else
     strcat(data,".sol");
-
+  
   sol->ver = 2;
   if( bin && !(inm = fopen(data,"wb")) ) {
     fprintf(stderr,"  ** UNABLE TO OPEN %s.\n",data);
@@ -1251,9 +1697,9 @@
 
   /*entete fichier*/
   if(!bin) {
-    strcpy(&chaine[0],"MeshVersionFormatted 2\n");
+    strcpy(&chaine[0],"MeshVersionFormatted 2\n"); 
     fprintf(inm,"%s",chaine);
-    strcpy(&chaine[0],"\n\nDimension 3\n");
+    strcpy(&chaine[0],"\n\nDimension 3\n"); 
     fprintf(inm,"%s ",chaine);
   } else {
     binch = 1; //MeshVersionFormatted
@@ -1266,19 +1712,19 @@
     fwrite(&bpos,sw,1,inm);
     binch = 3;
     fwrite(&binch,sw,1,inm);
-
+    
   }
 
 
   switch(sol->offset) {
   case 1:
-    typ = 1;
-    break;
+	 typ = 1;
+   break;
   case 6:
-    typ = 3;
+	  typ = 3;
     break;
   default:
-    fprintf(stdout,"  ** DATA IGNORED\n");
+    fprintf(stdout,"  ** DATA IGNORED not 1 ou 6 == %d\n",sol->offset);
     return(0);
   }
 
@@ -1287,11 +1733,11 @@
   for (k=1; k<=mesh->np; k++) {
     ppt = &mesh->point[k];
     if ( ppt->tag & M_UNUSED )  continue;
-    nbl++;
+	nbl++;
   }
-
+  
   if(!bin) {
-    strcpy(&chaine[0],"\n\nSolAtVertices\n");
+    strcpy(&chaine[0],"\n\nSolAtVertices\n"); 
     fprintf(inm,"%s",chaine);
     fprintf(inm,"%d\n",nbl);
     fprintf(inm,"%d %d\n",1,typ);
@@ -1300,7 +1746,7 @@
     fwrite(&binch,sw,1,inm);
     bpos += 20+(sol->offset*sol->ver)*4*nbl; //Pos
     fwrite(&bpos,sw,1,inm);
-    fwrite(&nbl,sw,1,inm);
+    fwrite(&nbl,sw,1,inm);    
     binch = 1; //nb sol
     fwrite(&binch,sw,1,inm);
     binch = typ; //typ sol
@@ -1317,34 +1763,34 @@
       sol->met[isol + 3] = tmp;
     }
     if (sol->ver < 2) {
-      if(!bin) {
-	for (i=0; i<sol->offset; i++) {
-	  fsol = (float) sol->met[isol + i];
-	  fprintf(inm,"%f ",fsol);
-	}
-	fprintf(inm,"\n");
+      if(!bin) { 
+        for (i=0; i<sol->offset; i++) {
+          fsol = (float) sol->met[isol + i];
+          fprintf(inm,"%f ",fsol);
+        } 
+        fprintf(inm,"\n");  
       } else {
-	for (i=0; i<sol->offset; i++) {
-	  fsol = (float) sol->met[isol + i];
-	  fwrite(&fsol,sw,1,inm);
-	}
+        for (i=0; i<sol->offset; i++) { 
+          fsol = (float) sol->met[isol + i];
+          fwrite(&fsol,sw,1,inm);
+        }    
       }
     } else {
-      if(!bin) {
-	for (i=0; i<sol->offset; i++)
-	  fprintf(inm,"%.15lg ",sol->met[isol + i]);
-	fprintf(inm,"\n");
+      if(!bin) { 
+        for (i=0; i<sol->offset; i++)
+          fprintf(inm,"%.15lg ",sol->met[isol + i]); 
+        fprintf(inm,"\n");  
       } else {
-	for (i=0; i<sol->offset; i++)
-	  fwrite(&sol->met[isol + i],sd,1,inm);
+        for (i=0; i<sol->offset; i++)
+          fwrite(&sol->met[isol + i],sd,1,inm);    
       }
-
+      
     }
   }
-
+  
   /*fin fichier*/
   if(!bin) {
-    strcpy(&chaine[0],"\n\nEnd\n");
+    strcpy(&chaine[0],"\n\nEnd\n"); 
     fprintf(inm,"%s",chaine);
   } else {
     binch = 54; //End
@@ -1355,14 +1801,16 @@
 }
 
 /*save the node speed : coornew-coorold/dt*/
-int MMG_saveVect(pMesh mesh,char *filename) {
-  FILE*        inm;
+int MMG_saveVect(pMesh mesh,char *filename,void *dataff) {
+  FILE*        inm;  
   pDispl        pd;
   pPoint       ppt;
   double       dsol,dd;
   int          i,k,nbl,bin,bpos,typ;
-  char        *ptr,data[128],chaine[128];
+  char        *ptr,data[128],chaine[128]; 
   unsigned char binch;
+  if(dataff) 
+      return MMG_saveVectff( mesh, filename,(DataFF*) dataff);
 
   pd      = mesh->disp;
   pd->ver = 2;
@@ -1378,7 +1826,7 @@
       bin  = 0;
     }
   }
-  if ( bin )
+  if ( bin ) 
     strcat(data,".o.solb");
   else
     strcat(data,".o.sol");
@@ -1395,9 +1843,9 @@
 
   /*entete fichier*/
   if(!bin) {
-    strcpy(&chaine[0],"MeshVersionFormatted 2\n");
+    strcpy(&chaine[0],"MeshVersionFormatted 2\n"); 
     fprintf(inm,"%s",chaine);
-    strcpy(&chaine[0],"\n\nDimension 3\n");
+    strcpy(&chaine[0],"\n\nDimension 3\n"); 
     fprintf(inm,"%s ",chaine);
   } else {
     binch = 1; //MeshVersionFormatted
@@ -1410,20 +1858,20 @@
     fwrite(&bpos,sw,1,inm);
     binch = 3;
     fwrite(&binch,sw,1,inm);
-
+    
   }
-  typ = 2;
+	typ = 2;
 
   /* write data */
   nbl = 0;
   for (k=1; k<=mesh->np; k++) {
     ppt = &mesh->point[k];
     if ( ppt->tag & M_UNUSED )  continue;
-    nbl++;
+	nbl++;
   }
-
+  
   if(!bin) {
-    strcpy(&chaine[0],"\n\nSolAtVertices\n");
+    strcpy(&chaine[0],"\n\nSolAtVertices\n"); 
     fprintf(inm,"%s",chaine);
     fprintf(inm,"%d\n",nbl);
     fprintf(inm,"%d %d\n",1,typ);
@@ -1432,34 +1880,34 @@
     fwrite(&binch,sw,1,inm);
     bpos += 20+(3*pd->ver)*4*nbl; //Pos
     fwrite(&bpos,sw,1,inm);
-    fwrite(&nbl,sw,1,inm);
+    fwrite(&nbl,sw,1,inm);    
     binch = 1; //nb sol
     fwrite(&binch,sw,1,inm);
     binch = typ; //typ sol
     fwrite(&binch,sw,1,inm);
-  }
-
-
-  dd = mesh->info.delta / (double)PRECI;
+  } 
+  
+  
+  dd = mesh->info.delta / (double)PRECI;  
   fprintf(stdout,"        DT %e\n",mesh->info.dt);
   for (k=1; k<=mesh->np; k++) {
     ppt = &mesh->point[k];
-    if ( ppt->tag & M_UNUSED )  continue;
+    if ( ppt->tag & M_UNUSED )  continue; 
     for (i=0 ; i<3 ; i++) {
-      dsol = (ppt->c[i] - mesh->disp->cold[3*(k-1) + 1 + i]* dd - mesh->info.min[i])/mesh->info.dt;
-      if(!bin) {
-	fprintf(inm,"%.15lg ",dsol);
+      dsol = (ppt->c[i] - mesh->disp->cold[3*(k-1) + 1 + i]* dd - mesh->info.min[i])/mesh->info.dt; 
+      if(!bin) { 
+        fprintf(inm,"%.15lg ",dsol); 
       } else {
-	fwrite(&dsol,sd,1,inm);
+        fwrite(&dsol,sd,1,inm);    
       }
     }
-    if (!bin) fprintf(inm,"\n");
+    if (!bin) fprintf(inm,"\n");  
   }
-
-
+  
+  
   /*fin fichier*/
   if(!bin) {
-    strcpy(&chaine[0],"\n\nEnd\n");
+    strcpy(&chaine[0],"\n\nEnd\n"); 
     fprintf(inm,"%s",chaine);
   } else {
     binch = 54; //End
--- mmg3d4/build/sources/mmg3d9.c	2012-12-19 16:05:33.000000000 +0100
+++ mmg3d4-nnew/build/sources/mmg3d9.c	2014-03-05 18:37:03.000000000 +0100
@@ -382,7 +382,7 @@
     fprintf(stdout,"  ** MOVING MESH\n");
 
   /*alloc et init metold*/
-  sol->metold = (double*)M_calloc(sol->npmax+1,sol->offset*sizeof(double),"MMG_mmg3d9");
+  if(!sol->metold) sol->metold = (double*)M_calloc(sol->npmax+1,sol->offset*sizeof(double),"MMG_mmg3d9");
   assert(sol->metold);
   mesh->disp->cold = (double*)M_calloc(3*(mesh->npmax + 1),sizeof(double),"MMG_mmg3d9");
   assert(mesh->disp->cold);

--- mmg3d4/build/sources/mmg3dmain/mmg3d.c	2012-12-19 16:05:53.000000000 +0100
+++ mmg3d4-new/build/sources/mmg3dmain/mmg3d.c	2014-04-22 16:37:41.000000000 +0200
@@ -46,7 +46,7 @@
 #include "compil.date"
 #include "mesh.h"
 #include "eigenv.h"
-
+#include "dataff.h"
 TIM_mytime         MMG_ctim[TIMEMAX];
 short	             MMG_imprim;
 
@@ -310,7 +310,8 @@
     strcpy(sol->name,mesh->name);
   }
   if ( mesh->outf == NULL ) {
-    mesh->outf = (char *)calloc(128,sizeof(char));
+    static char stbub [256]; 
+    mesh->outf =  stbub; /*(char *)calloc(128,sizeof(char)); */ 
     assert(mesh->outf);
     strcpy(mesh->outf,mesh->name);
     ptr = strstr(mesh->outf,".mesh");
@@ -397,6 +398,7 @@
 	    100.*ttot/ttim[0],call[0],ttot/(float)call[0]);
   }
   fprintf(stdout,"\n   ELAPSED TIME  %.2f SEC.  (%.2f)\n",ttim[0],ttot);
+  fflush(stdout);
 }
 
 
@@ -433,8 +435,7 @@
   return(1);
 }
 
-
-int main(int argc,char *argv[]) {
+int mainmmg3d(int argc,char *argv[],DataFF *dataff) { 
   pMesh      	mesh;
   pSol       	sol;
   Info     	*info;
@@ -442,7 +443,7 @@
   int k,iadr,i,jj,kk,ii;
   double	lambda[3],v[3][3],*mold,*m,declic,maxLES,calLES;
   fprintf(stdout,"  -- MMG3d, Release %s (%s) \n",M_VER,M_REL);
-  fprintf(stdout,"     Copyright (c) LJLL/IMB, 2010\n");
+  fprintf(stdout,"     Copyright (c) LJLL/IMB, 2014\n");
   fprintf(stdout,"    %s\n",COMPIL);
 
   signal(SIGABRT,excfun);
@@ -451,7 +452,7 @@
   signal(SIGSEGV,excfun);
   signal(SIGTERM,excfun);
   signal(SIGINT,excfun);
-  atexit(endcod);
+  if(dataff==0) atexit(endcod);
 
   TIM_tminit(MMG_ctim,TIMEMAX);
   TIM_chrono(ON,&MMG_ctim[0]);
@@ -479,15 +480,27 @@
   info->dt       = 1.;
   info->bdry     = 0;
   info->optles   = 0;
-
+   /* modif F. Hecht ..*/
+   if(dataff)
+     {
+       mesh->name=dataff->meshname;
+       mesh->move=dataff->movename;
+       sol->name=dataff->solname;
+       /*      printf(" #### %p %p %p --- \n",mesh->name,mesh->move,sol->name); */
+       info->imprim=dataff->imprim;
+       info->memory=dataff->memory;
+     }
+   /* end modf */ 
   if ( !parsar(argc,argv,mesh,sol) )  return(1);
   MMG_imprim = info->imprim;
   
   /* load data */
   if ( MMG_imprim )   fprintf(stdout,"\n  -- INPUT DATA\n");
   TIM_chrono(ON,&MMG_ctim[1]);
-  if ( !MMG_loadMesh(mesh,mesh->name) )  return(1); 
-  if ( !MMG_loadSol(sol,sol->name,mesh->npmax) )  return(1);
+  /* modif FH. for interface with ff++ add dataff param     */
+  if ( !MMG_loadMesh(mesh,mesh->name,dataff) )  return(1); 
+  if ( !MMG_loadSol(sol,sol->name,mesh->npmax,dataff ) )  return(1);
+
   if ( sol->np && sol->np != mesh->np ) {
     fprintf(stdout,"  ## WARNING: WRONG SOLUTION NUMBER. IGNORED\n");
     sol->np = 0;
@@ -495,7 +508,7 @@
 
   if ( !parsop(mesh) )  return(1);
 
-  if ( abs(info->option) == 9 && !MMG_loadVect(mesh,mesh->move,mesh->np) )  return(0);
+  if ( abs(info->option) == 9 && !MMG_loadVect(mesh,mesh->move,mesh->np,dataff) )  return(0);
 
   if ( !MMG_setfunc(sol->offset) ) return(1);
   if ( !MMG_scaleMesh(mesh,sol) )  return(1);   
@@ -527,7 +540,7 @@
   if ( !MMG_hashTetra(mesh) )    return(1);
   if ( !MMG_markBdry(mesh) )     return(1);
   if (abs(mesh->info.option)==10) {
-    MMG_saveMesh(mesh,"tetra.mesh");
+    MMG_saveMesh(mesh,"tetra.mesh",dataff);
     return(0);
   }           
 
@@ -571,8 +584,8 @@
     if ( abs(info->option) == 9 ) {
       if(!MMG_mmg3d9(mesh,sol,&alert)) {
         if ( !MMG_unscaleMesh(mesh,sol) )  return(1);
-        MMG_saveMesh(mesh,mesh->outf);
-	MMG_saveSol(mesh,sol,mesh->outf);
+        MMG_saveMesh(mesh,mesh->outf,dataff);
+	MMG_saveSol(mesh,sol,mesh->outf,dataff);
 	return(1);
       }
       /*puts("appel 1");
@@ -678,18 +691,18 @@
     fprintf(stdout,"\n  ## WARNING: INCOMPLETE MESH  %d , %d\n",
             mesh->np,mesh->ne);
 
-  if ( MMG_imprim )  fprintf(stdout,"\n  -- WRITING DATA FILE %s\n",mesh->outf);
+  if ( MMG_imprim && !dataff)  fprintf(stdout,"\n  -- WRITING DATA FILE %s\n",mesh->outf);
   TIM_chrono(ON,&MMG_ctim[1]);
   if ( !MMG_unscaleMesh(mesh,sol) )  return(1);
-  MMG_saveMesh(mesh,mesh->outf);
+  MMG_saveMesh(mesh,mesh->outf,dataff);
   if ( info->option == 9 ) {
-    MMG_saveSol(mesh,sol,mesh->outf);
-    MMG_saveVect(mesh,mesh->move);    
+    MMG_saveSol(mesh,sol,mesh->outf,dataff);
+    MMG_saveVect(mesh,mesh->move,dataff);    
   }
   else
-    MMG_saveSol(mesh,sol,mesh->outf);
+    MMG_saveSol(mesh,sol,mesh->outf,dataff);   
   TIM_chrono(OFF,&MMG_ctim[1]);
-  if ( MMG_imprim )  fprintf(stdout,"  -- WRITING COMPLETED\n");
+  if ( MMG_imprim && !dataff)  fprintf(stdout,"  -- WRITING COMPLETED\n");
 
   /* free mem */
   M_free(mesh->point);
@@ -697,14 +710,42 @@
   M_free(mesh->tetra);
   /*la desallocation de ce pointeur plante dans certains cas...*/
   M_free(mesh->adja);
+  /* free FH thank to Iztok Bajc */
+  /*    if( mesh->outf ) free( mesh->outf ); */
+    if(sol->metold  ) M_free(sol->metold );
+    if(mesh->disp->cold ) M_free(mesh->disp->cold);
+   /* ---- */
   M_free(mesh->disp->alpha);
   M_free(mesh->disp->mv);
   M_free(mesh->disp);
 
-  if ( sol->npfixe )  M_free(sol->met);
+  if ( sol->met )  M_free(sol->met);
   M_free(sol);
 
   if ( MMG_imprim < -4 || info->ddebug )  M_memDump();
   M_free(mesh);
+  if(MMG_imprim && dataff ) endcod();
+  if( M_memLeak() > 1000)
+    {
+        M_memDump();
+    }
   return(0);
 }
+
+int main(int argc,char *argv[])  {
+    return  mainmmg3d( argc,argv,0);
+}
+/*
+ def 
+ */
+ MMG_Swap MMG_swpptr;
+ double (*MMG_length)(double *,double *,double *,double *);
+ double (*MMG_caltet)(pMesh ,pSol ,int );
+ double (*MMG_calte1)(pMesh ,pSol ,int );
+ int    (*MMG_caltet2)(pMesh ,pSol ,int ,int ,double ,double *);
+ int    (*MMG_cavity)(pMesh ,pSol ,int ,int ,pList ,int );
+ int    (*MMG_buckin)(pMesh ,pSol ,pBucket ,int );
+ int    (*MMG_optlen)(pMesh ,pSol ,double ,int );
+ int    (*MMG_interp)(double *,double *,double *,double );
+ int    (*MMG_optlentet)(pMesh ,pSol ,pQueue ,double ,int ,int );
+ int    (*MMG_movevertex)(pMesh ,pSol ,int ,int );
--- mmg3d4/build/sources/eigenv.c	2012-12-19 16:05:32.000000000 +0100
+++ mmg3d4-new/build/sources/eigenv.c	2016-01-28 12:10:07.000000000 +0100
@@ -48,7 +48,7 @@
 #include <math.h>
 
 				    /* seeking 1.e-05 accuracy */
-#define  EPSD           1.e-15
+#define  EPSD           1.e-12
 #define  EPSD2          1.e-10
 #define  EPS6           5.e-06
 #define  EPS            1.e-06
