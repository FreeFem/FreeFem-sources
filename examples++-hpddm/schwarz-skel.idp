int overlap = getARGV("-overlap", 1); // level of overlap ⠶$\delta$⠶
string str = getARGV("-hpddm_schwarz_method", "XXX");
bool co = usedARGV("-hpddm_schwarz_coarse_correction") != -1;
if(str == "asm" && solver == 0)
    solver = 1;
else if(co) {
    if(str == "soras")
        solver = 8;
    else if(str == "oras")
        solver = 6;
    else
        solver = 3;
}

include "schwarz-additional_macro.idp"

mpiComm comm;
int p = getARGV("-hpddm_master_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_master_topology", 0), exclude = (usedARGV("-hpddm_master_exclude") != -1));

if(mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - " << txt << " - input parameters: global size = " << global << " - refinement factor = " << s << " - precision = " << getARGV("-eps", 1e-8) << " - overlap = " << overlap << " - with partitioner? = " << partitioner << endl;
}

meshN Th = minimalMesh;
fespace Wh(Th, Pk);
build(generateTh, Th, ThBorder, ThOverlap, s, D, numberIntersection, arrayIntersection, restrictionIntersection, Wh, Pk, comm, excluded)

coefficients //macro definie dans le fichier incluant

/*# localMatrix #*/
timing = mpiWtime();
assemble(Mat, rhs, Wh, Th, ThBorder, Varf)
stats[0] = mpiWtime() - timing;
ThBorder = minimalMesh;
/*# localMatrixEnd #*/

if(usedARGV("-without-hpddm") == - 1) {
    scalar(schwarz) A(Mat, arrayIntersection, restrictionIntersection, scaling = D/*, change = Q*/, communicator = comm); //Code C++ 

    /*# coarseSpace #*/
    timing = mpiWtime();

    matrix<K> Opt;
    if(solver == 6 || solver == 8) {
        optimizedMacro(OptimizedBC, Th, PhOpt);
        Opt = OptimizedBC(Wh, Wh, solver = CG);
    }
    scalar(pair) ret;
    if(mpisize > 1 && (solver == 3 || solver == 6 || solver == 36  || solver == 8 || solver == 100 || solver == 101)) {
        if(excluded)
            attachCoarseOperator(mpiCommWorld, A, /*A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam,*/ timing = stats);
        else if(solver != 100 && solver != 101) {
            EVproblem(vPbNoPen, Th, Ph)
            stats[2] = mpiWtime();
            matrix<K> noPen = vPbNoPen(Wh, Wh, solver = CG);
            if(solver == 36)
                Opt = noPen;
            stats[2] = mpiWtime() - stats[2];
            // fespace PhOverlap(overlap, P0);
            // PhOverlap h = hTriangle;
            if(solver == 3) // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                attachCoarseOperator(mpiCommWorld, A, A = noPen, /*B = overlapRestriction, threshold = 2. * h[].max / diam,*/ timing = stats, ret = ret);
            else if(solver == 36) // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                attachCoarseOperator(mpiCommWorld, A, A = noPen, pattern = Opt, /*B = overlapRestriction, threshold = 2. * h[].max / diam,*/ timing = stats, ret = ret);
            else if(solver == 8) {
                varf vMass(def(u), def(v)) = intN1(Th, 10)(u * v);
                matrix<K> massMatrix = vMass(Wh, Wh, solver = CG);
                attachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt, /*threshold = k,*/ timing = stats, ret = ret);
            }
            else // GenEO for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                attachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt, /*threshold = 2. * h[].max / diam,*/ timing = stats, ret = ret);
        }
        else
            attachCoarseOperator(mpiCommWorld, A, A = inter, /*threshold = 2. * h[].max / diam,*/ timing = stats, ret = ret, solver = solver);
    }

    Wh<K> def(u); // this will be the solution

    DDM(A, u[], rhs, dim = getARGV("-gmres_restart", -1), iter = getARGV("-iter", -1), eps = getARGV("-eps", -1.0), timing = stats, solver = solver, excluded = excluded, ret = ret, O = Opt);

    real[int] metrics(2), metricsReduce(2);
    if(!excluded) {
        Wh def(ones);
        ones[] = 1.;
        real[int] sum1(ones[].n);
        for(i = 0; i < ones[].n; ++i)
            sum1[i] = D[i] * ones[][i];
        metrics(0) = sum1' * ones[];
        metrics(1) = numberIntersection / real(mpiSize(comm));
        mpiReduce(metrics, metricsReduce, processor(0, comm), mpiSUM);
        cout.precision(1);
        if(mpiRank(comm) == 0) {
            fespace Ph(Th, P0);
            Ph hSize = hTriangle;
            cout.fixed << " --- number of dof: " << metricsReduce(0) << ", on average, number of neighbors: " << metricsReduce(1) << ", h: ";
            cout.scientific << hSize[].max << endl;
        }

        real[int, int] statsMaster(stats.n, mpiRank(comm) == 0 ? mpiSize(comm) : 0);
        mpiGather(stats, statsMaster, processor(0, comm));
        if(mpiRank(comm) == 0) {
            cout << "Assem. solver   Fact. solver" << (mpisize > 1 && (solver == 3 || solver == 6 || solver == 8) ? "  Assm. eigenval.  Sol. eigenval.  Coarse op." : "");
            if(mpisize != mpiSize(comm))
                cout << "   Waiting time";
            cout << endl;
            for(i = 0; i < mpiSize(comm); ++i) {
                cout.precision(4);
                cout.scientific << statsMaster(0, i) << "      " << statsMaster(1, i);
                if(mpisize > 1 && (solver == 3 || solver == 6 || solver == 8)) {
                    cout << "    " << statsMaster(2, i) << "       " << statsMaster(3, i) << "      " << statsMaster(4, i);
                    if(mpisize != mpiSize(comm))
                        cout << "   " << statsMaster(5, i);
                }
                cout << endl;
            }
        }
    }
    MoveAndPlot(Th, u, Pk, def, 3)
}
if(usedARGV("-with-petsc") != -1) {
    assembleUnsym(Mat, rhs, Wh, Th, ThBorder, Varf)
    Wh[int] def(Rb)(0);
    generateRbm(Rb)
    Wh def(b);
    if(!excluded) {
        dmatrix petsc(Mat, arrayIntersection, restrictionIntersection, D, communicator = comm);
        set(petsc, sparams = "-ksp_view -pc_type gamg -ksp_type gmres -ksp_max_it 200 -ksp_monitor");
        b[] = petsc^-1 * rhs;
        /*
        set(petsc, sparams = "-ksp_view -pc_type gamg -ksp_type gmres -ksp_max_it 200 -ksp_monitor -pc_gamg_threshold 0.01", nearnullspace = Rb);
        b[] = petsc^-1 * rhs;
        set(petsc, sparams = "-ksp_view -pc_type gamg -ksp_type gmres -ksp_max_it 200 -ksp_monitor -pc_gamg_threshold 0.1", nearnullspace = Rb);
        b[] = petsc^-1 * rhs;
        */
        set(petsc, sparams = "-ksp_view -pc_type gamg -ksp_type gmres -ksp_max_it 200 -ksp_monitor -pc_gamg_threshold 0.2", nearnullspace = Rb);
        b[] = petsc^-1 * rhs;
        set(petsc, sparams = "-ksp_view -pc_type gamg -ksp_type gmres -ksp_max_it 200 -ksp_monitor -pc_gamg_threshold 0.5", nearnullspace = Rb);
        b[] = petsc^-1 * rhs;
        real[int] res(Wh.ndof);
        res = petsc * b[];
        res -= rhs;
        real rhsNorm = dscalprod(D, rhs, rhs, communicator = comm);
        real resNorm = dscalprod(D, res, res, communicator = comm);
        if(mpiRank(comm) == 0)
            cout << " --- error = " << sqrt(resNorm) << " / " << sqrt(rhsNorm) << endl;
    }
    MoveAndPlot(Th, b, Pk, def, 2)
}
/*
load "iovtk"
int[int] fforder=[1];
Wh r;
r = real(u);
savevtk("helmholtz-r-" + mpirank + ".vtk", Th, r, dataname = "real", order = fforder);
r = imag(u);
savevtk("helmholtz-i-" + mpirank + ".vtk", Th, r, dataname = "imaginary", order = fforder);
for(int i = 0; i < r[].n; ++i)
    r[][i] = sqrt(real(u[][i])^2 + imag(u[][i])^2);
savevtk("helmholtz-n-" + mpirank + ".vtk", Th, r, dataname = "imaginary", order = fforder);
*/
