//  run with MPI:  ff-mpirun -np 1 script.edp
// NBPROC 1

load "hpddm"                        // HPDDM plugin
load "metis"                        // Metis partitioner
load "scotch"                       // SCOTCH partitioner
include "macro_ddm.idp"             // additional DDM functions
include "cube.idp"

macro meshN()mesh3// EOM            // three-dimensional problem
macro bbN()bb3// EOM                // three-dimensional bounding box
macro intN()int3d// EOM             // three-dimensional integral
macro intN1()int2d// EOM            // two-dimensional integral
macro def(i)[i, i#B, i#C]// EOM     // vector field definition
macro init(i)[i, i, i]// EOM        // vector field initialization
/*# DiffMacros #*/
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), dz(u#C), (dz(u#B) + dy(u#C)) / Sqrt, (dz(u) + dx(u#C)) / Sqrt, (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
/*# DiffMacrosEnd #*/
func Pk = [P1, P1, P1];             // finite element space

if(mpisize != 1)
    exit(1);

/*# DDMoptions #*/
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor
int partitioner = getARGV("-partitioner", 1);                   // partitioner (1: Metis, 2: SCOTCH)

int[int, int] LL = [[1,3], [2,2], [2,2]];
real[int, int] BB = [[0,10], [0,1], [0,1]];
int[int] NN = [10 * getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5)];
int[int] CC = [1, 1, 1];
meshN ThBorder, Th = Cube(CC, BB, LL);
fespace Wh(Th, Pk);                         // local finite element space
/*# SchwarzMethod #*/
int[int] arrayIntersection;                 // ranks of neighboring subdomains
int[int][int] restrictionIntersection(0);   // local-to-neighbors renumbering
real[int] D;                                // partition of unity
{
    meshN ThGlobal = Cube(NN, BB, LL);      // global mesh
    build(Th, ThBorder, ThGlobal, fakeInterface, s, overlap, D, arrayIntersection, restrictionIntersection, Wh, Pk, mpiCommWorld, false)
}

real f = -9000.0;
real strain = 100.0;
real Young = 2.0e11; // steel
real poisson = 0.35;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
varf vPb(def(u), def(v)) = intN(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
Mat = vPb(Wh, Wh, solver = CG);

dschwarz A(Mat, arrayIntersection, restrictionIntersection, scaling = D);

real alpha = 5.0e3;
Wh def(u), def(d);
real[int] uBlock(u[].n * 2);
real[int] rhsBlock(u[].n * 2);

varf vPbC(def(u), def(v)) = intN(Th)(f * vC) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
rhsBlock(0 * u[].n:1 * u[].n - 1) = vPbC(0, Wh);

varf vPbB(def(u), def(v)) = intN(Th)(f * vB) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
rhsBlock(1 * u[].n:2 * u[].n - 1) = vPbB(0, Wh);

uBlock = A^-1 * rhsBlock;

u[] = uBlock(0 * u[].n:1 * u[].n - 1);
d[] = uBlock(1 * u[].n:2 * u[].n - 1);
meshN ThMoved1 = movemesh3(Th, transfo = [x + alpha * u, y + alpha * uB, z + alpha * uC]);
meshN ThMoved2 = movemesh3(Th, transfo = [x + alpha * d, y + alpha * dB, z + alpha * dC]);
medit("Global moved solutions", ThMoved1, [u, uB, uC], ThMoved2, [d, dB, dC]);
