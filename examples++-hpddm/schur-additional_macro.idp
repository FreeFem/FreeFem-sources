macro partition(meshName, s, VhName, ndofSkeleton, comm)
        /* DEBUG   
        if(mpirank == 0)
            plot(ThGlobal, part, wait = 1, cmm = "Partition", fill = 1, value = 1, dim = 2);
            DEBUG */
        meshName = trunc(ThGlobal, abs(part - mpiRank(comm)) < 0.1, label = 10);
        {
            /*
            PhGlobal overshoot = hTriangle;
            */
            fespace PhLocal(meshName, P0);
            PhLocal overshoot = hTriangle;
            real max = 2.0 * overshoot[].max;
            bbN(meshName, max, ThGlobal)
        }
        fespace VhGlobal(ThGlobal, P1);
        PhGlobal supp = abs(part - mpiRank(comm)) < 0.1;
        VhGlobal suppSmooth;
        AddLayers(ThGlobal, supp[], 2, suppSmooth[]);
        {
            meshN neighbors = trunc(ThGlobal, suppSmooth > 0.001 && suppSmooth < 0.999);
            fespace Oh(neighbors, P0);
            Oh partOverlap = part;
            Unique(partOverlap[], arrayIntersection);
        }

        VhGlobal[int] partitionIntersection(arrayIntersection.n);

        if(s > 1) {
            ThGlobal = trunc(ThGlobal, suppSmooth > 0.001, split = s, label = 10);
            supp = abs(part - mpiRank(comm)) < 0.1;
            suppSmooth = 0;
            AddLayers(ThGlobal, supp[], 2, suppSmooth[]);
            meshName = trunc(meshName, 1, split = s);
        }
        ThGlobal = trunc(ThGlobal, suppSmooth > 0.501, label = 10);
        part = part;

        VhGlobal phi = 0;
        real eps = intN(ThGlobal)(1.0);
        for(i = 0; i < arrayIntersection.n; ++i) {
            PhGlobal suppPartition = abs(arrayIntersection[i] - part) < 0.1;
            AddLayers(ThGlobal, suppPartition[], 1, phi[]);
            real intersection = intN(ThGlobal)(phi) / eps;
            if(intersection > 1.0e-6) {
                partitionIntersection[numberIntersection] = phi;
                arrayIntersection[numberIntersection++] = arrayIntersection[i];
            }
        }
        if(numberIntersection != arrayIntersection.n)
            arrayIntersection.resize(numberIntersection);
        Wh def(interface);
        varf vPbInterface(def(u), def(v)) = on(10, BC(u, 1.0)) + on(1, BC(u, 0.0));
        interface[] = vPbInterface(0, Wh, tgv = 1);
        matrix[int] R(arrayIntersection.n);

        for(i = 0; i < arrayIntersection.n; ++i) {
            meshN meshIntersection = trunc(ThGlobal, (part == mpiRank(comm) || part == arrayIntersection[i]) && partitionIntersection[i] > 1e-6, label = 10);
            fespace WhIntersection(meshIntersection, Pk);
            R[i] = interpolate(WhIntersection, Wh, inside = 1);
            /* DEBUG   
                WhIntersection def(d);
                d[] = R[i] * interface[];
                int k = i;
                plotAll(meshIntersection, d[], "Intersection of " + mpirank + " with " + arrayIntersection[k], Pk, def, 2);
                i = k;
               DEBUG */
            /* DEBUG   
            k = i;
            WhIntersection def(intersection);
            intersection[] = R[i] * interface[];
            if(k < 2) {
                WhIntersection def(debug);
                for(int j = 0; j < WhIntersection.ndof; ++j)
                    debug[][j] = j + 1;
                plotAll(meshIntersection, debug[], "intersection", Pk, def, 2)
                mpiBarrier(mpiCommWorld);
            }
            i = k;
               DEBUG */
        }
        buildSkeleton(interface[], arrayIntersection, R, ndofSkeleton, interface = interfaceNb, redundancy = getARGV("-redundancy", 1), communicator = comm);
// EOM

macro build(ThGlobal, globalTh, Th, s, numberIntersection, arrayIntersection, restrictionIntersection, Wh, P)
/*# partition #*/
int[int] arrayIntersection;
fespace Vh(Th, P1);
fespace Wh(Th, P);
int[int] interfaceNb(0);
int[int][int] restrictionIntersection(0);

int numberIntersection = 0;
real timing;
{
    timing = mpiWtime();
    if(mpisize > 1 && !excluded) {
        meshN globalTh(ThGlobal);
        fespace PhGlobal(ThGlobal, P0);
        PhGlobal part;
        if(partitioner != 0) {
            if(mpiRank(comm) == 0) {
                cout.scientific << " --- global mesh of " << ThGlobal.nt << " elements (prior to refinement) generated (in " << mpiWtime() - timing << ") and partitioned with ";
                timing = mpiWtime();
                if(partitioner == 2) {
                    scotch(part[], ThGlobal, mpiSize(comm));
                    cout << "SCOTCH";
                }
                else {
                    metisdual(part[], ThGlobal, mpiSize(comm));
                    cout << "Metis";
                }
                cout.scientific << " (in " << mpiWtime() - timing << ")" << endl;
            }
            timing = mpiWtime();
            broadcast(processor(0, comm), part[]);
        }
        else {
            simple(PhGlobal, part, comm)
        }
        partition(Th, s, Vh, restrictionIntersection, comm)
    }
    else if(mpisize == 1) {
        globalTh(Th);
        Wh def(interface);
        varf vPbInterface(def(u), def(v)) = on(2, BC(u, 1.0)) + on(1, BC(u, 0.0));
        interface[] = vPbInterface(0, Wh, tgv = 1);
        interfaceNb.resize(Wh.ndof);
        j = 0;
        for(i = 0; i < Wh.ndof; ++i) {
            if(interface[][i] > 0.9)
                interfaceNb[j++] = i;
        }
        interfaceNb.resize(j);
    }
    mpiBarrier(mpiCommWorld);
    if(mpirank == 0) cout.scientific << " --- partition of unity built (in " << mpiWtime() - timing << ")" << endl;
}
/*# partitionEnd #*/
// EOM
