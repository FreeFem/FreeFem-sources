//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm_substructuring"         // HPDDM plugin
load "metis"                        // Metis partitioner
load "scotch"                       // SCOTCH partitioner
include "macro_ddm_substructuring.idp" // additional DDM functions

macro meshN()mesh// EOM             // two-dimensional problem
macro bbN()bb2// EOM                // two-dimensional bounding box
macro intN()int2d// EOM             // two-dimensional integral
macro intN1()int1d// EOM            // one-dimensional integral
macro def(i)[i, i#B]// EOM          // vector field definition
macro init(i)[i, i]// EOM           // vector field initialization
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM
macro BC(u, val)u = val, u#B = val// EOM // Dirichlet boundary conditions
func Pk = [P2, P2];                 // finite element space

int labNeumann = getARGV("-labNeumann", 2);                     // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor
int partitioner = getARGV("-partitioner", 1);                   // partitioner (1: Metis, 2: SCOTCH)

mpiComm comm;
int p = getARGV("-hpddm_master_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_master_topology", 0), exclude = (usedARGV("-hpddm_master_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - elasticity-2d-substructuring.edp - input parameters: refinement factor = " << s << " - with partitioner? = " << partitioner << endl;
}

meshN Th = square(1, 1);
fespace Wh(Th, Pk);                         // local finite element space
int[int] arrayIntersection;                 // ranks of neighboring subdomains
int[int][int] restrictionIntersection(0);   // local-to-neighbors renumbering
int[int] interfaceNb;                       //
{
    int[int] l = [2, 1, 2, 2];
    meshN ThGlobal = square(2 * getARGV("-global", 10), getARGV("-global", 10), [2 * x, y], label = l);    // global mesh
    buildSubstructuring(Th, interfaceNb, ThGlobal, labNeumann, s, arrayIntersection, restrictionIntersection, Wh, Pk, BC, comm, excluded)
}

real f = -90000.0;
real strain = 100.0;
real Young = 1.0e8;
real poisson = 0.45;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
varf vPb(def(u), def(v)) = intN(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + intN(Th)(f * vB) + on(1, u = 0.0, uB = 0.0);
matrix<real> Mat = vPb(Wh, Wh, solver = CG); // local operator
real[int] rhs = vPb(0, Wh);                  // local right-hand side

dbdd A(Mat, arrayIntersection, restrictionIntersection, communicator = comm);
// this can be replaced by dfeti
bool adaptive = isSetOption("geneo_nu") || isSetOption("geneo_threshold");

dpair ret;
if(mpisize == 1)
    renumber(A, Mat, interfaceNb, effort = rhs);
else {
    if(excluded)
        attachCoarseOperator(mpiCommWorld, A);
    else {
        Wh[int] def(Rb)(0);
        real[int] float(Wh.ndof);
        varf floatingPb(def(u), def(v)) = on(1, BC(u, 1.0));
        float = floatingPb(0, Wh);
        if(float.max < 0.9 && !adaptive) {
            Rb.resize(3);
            [Rb[0], RbB[0]] = [1, 0];
            [Rb[1], RbB[1]] = [0, 1];
            [Rb[2], RbB[2]] = [x, -y];
        }
        if(getARGV("-hpddm_substructuring_scaling", 0) != 2)
            renumber(A, Mat, interfaceNb, R = Rb, effort = rhs);
        else {
            real strain = 100.0;
            real Young = 1.0e8;
            real poisson = 0.45;
            real tmp = 1.0 + poisson;
            real mu = Young  / (2.0 * tmp);
            real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
            Wh def(muFunc) = mu;
            renumber(A, Mat, interfaceNb, R = Rb, effort = rhs, rho = muFunc[]);
        }
        attachCoarseOperator(mpiCommWorld, A, R = Rb, ret = ret);
    }
}

Wh<real> def(u);          // local solution

if(mpisize == mpiSize(comm))
    u[] = A^-1 * rhs;
else
    DDM(A, u[], rhs, excluded = excluded);

if(!excluded)
    originalNumbering(A, u[], interfaceNb);
plotMPI(Th, u[], "Global solution", Pk, def, real, 3, 1)
