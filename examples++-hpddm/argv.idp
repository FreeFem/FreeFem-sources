load "metis"
load "scotch"
load "Element_P3"
load "Element_P4"
load "hpddm"
include "macro.idp"

macro def1(i)i// EOM
macro def2(i)[i, i#B]// EOM
macro def3(i)[i, i#B, i#C]// EOM
macro def4(i)[i, i#B, i#C, i#D]// EOM
macro init1(i)i// EOM
macro init2(i)[i, i]// EOM
macro init3(i)[i, i, i]// EOM
macro init4(i)[i, i, i, i]// EOM
macro BC1(i, val)i = val// EOM
macro BC2(i, val)i = val, i#B = val// EOM
macro BC3(i, val)i = val, i#B = val, i#C = val// EOM
macro BC4(i, val)i = val, i#B = val, i#C = val, i#D = val// EOM

searchMethod = 1;

/*# initialization #*/
verbosity = getARGV("-v", 0); // the higher this value, the more verbose ⠶\tt FreeFem++⠶ is
int s = getARGV("-split", 1); // refinement factor of each local meshes
int global = getARGV("-global", 20); // global number of discretization points in one direction
int solver = getARGV("-solver", 0); // 1: Additive Schwarz+CG, 2: RAS+GMRES, 3:RGENEO+GMRES, 4: in progress
int partitioner = getARGV("-partitioner", 1); // usage of a partitioner 0: regular , 1: Metis, 2: Scotch
int i, j;
real diam;
real[int] stats(6);
/*# initializationEnd #*/
macro rectangle(A, l, L, lab1, lab2, lab3, lab4, N, M)
border A#1(t=0, l) { x=t; y=0; label=lab1; }
border A#2(t=0., L) { x=l.; y=t; label=lab2; }
border A#3(t=l,0) { x=t; y=L; label=lab3; }
border A#4(t=L,0) { x=0; y=t; label=lab4; }
func A = A#1(N) + A#2(M) + A#3(N)+A#4(M);// EOM
