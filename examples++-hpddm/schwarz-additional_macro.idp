macro partition(meshName, borderName, overlapName, PhGlobal, part, s, D, Wh, P, numberIntersection, arrayIntersection, restrictionIntersection, comm, fakeInterface)
        meshName = trunc(renum=false,overlapName, abs(part - mpiRank(comm)) < 0.1, label = fakeInterface);
        /*
        savemesh(meshName, "Th-0-" + mpirank + ".msh");
        coefficients
        fespace Ph(meshName, P0);
        Ph poisson = skyscraper(x, y);
        load "iovtk"
        int[int] fforder=[1];
        savevtk("SC-" + mpirank + ".vtk", meshName, poisson, dataname = "kappa", order = fforder);
        */
        mpiBarrier(comm);
        real timerPartition = mpiWtime();
        {
            fespace PhLocal(meshName, P0);
            PhLocal overshoot = hTriangle;
            real max = 2.0 * overlap * overshoot[].max;
            bbN(meshName, max, overlapName)
        }
        /*
        mpiBarrier(comm);
        if(mpiRank(comm) == 0)
            cout << "Bounding box: " << mpiWtime() - timerPartition << endl;
        timerPartition = mpiWtime();
        */
        fespace VhGlobal(overlapName, P1);
        PhGlobal supp = abs(part - mpiRank(comm)) < 0.1;
        VhGlobal suppSmooth;
        AddLayers(overlapName, supp[], 2 * overlap, suppSmooth[]);
        /*
        mpiBarrier(comm);
        if(mpiRank(comm) == 0)
            cout << "AddLayers: " << mpiWtime() - timerPartition << endl;
        timerPartition = mpiWtime();
        */
        {
            meshN neighbors = trunc(renum=false,overlapName, suppSmooth > 0.001 && suppSmooth < 0.999);
            fespace Oh(neighbors, P0);
            Oh partOverlap = part;
            Unique(partOverlap[], arrayIntersection);
        }
        /*
        mpiBarrier(comm);
        if(mpiRank(comm) == 0)
            cout << "findDiff: " << mpiWtime() - timerPartition << endl;
        timerPartition = mpiWtime();
        */
        fespace VhLocal(meshName, P1);
        VhLocal[int] partitionIntersection(arrayIntersection.n);
        /*
        plotAll(overlapName, suppSmooth, "khi", P1, def1, 3)
        mpiBarrier(comm);
        if(mpiRank(comm) == 0)
            cout << "Initialization: " << mpiWtime() - timerPartition << endl;
        timerPartition = mpiWtime();
        */
        if(s > 1) {
            overlapName = trunc(renum=false,overlapName, suppSmooth > 0.001, split = s);
            supp = abs(part - mpiRank(comm)) < 0.1;
            suppSmooth = 0;
            AddLayers(overlapName, supp[], 2 * overlap, suppSmooth[]);
        }
        overlapName = trunc(renum=false,overlapName, suppSmooth > 0.001);
        supp = supp;
        suppSmooth = suppSmooth;
        meshName = trunc(renum=false,overlapName, suppSmooth > 0.501, label = fakeInterface);
        borderName = trunc(renum=false,overlapName, (suppSmooth > (overlap - 0.999) / (2 * overlap)) && (suppSmooth < 0.501), label = (abs(fakeInterface) + 1) * 100);
        VhLocal khi = max(2 * suppSmooth - 1.0, 0.0);
        if(usedARGV("-steep") != -1)
            khi = khi > 0.001 ? 1.0 : 0.0;
        VhLocal sum = khi;
        VhGlobal phi = 0;
        /*
        mpiBarrier(comm);
        if(mpiRank(comm) == 0)
            cout << "Localization: " << mpiWtime() - timerPartition << endl;
        timerPartition = mpiWtime();
        */
        real eps = intN(overlapName)(1.0);
        for(i = 0; i < arrayIntersection.n; ++i) {
            PhGlobal suppPartition = abs(arrayIntersection[i] - part) < 0.1;
            AddLayers(overlapName, suppPartition[], overlap, phi[]);
            if(usedARGV("-steep") != -1)
                phi = phi > 0.001 ? 1.0 : 0.0;
            real intersection = intN(overlapName)(phi) / eps;
            if(intersection > 1.0e-6) {
                partitionIntersection[numberIntersection] = phi;
                sum[] += partitionIntersection[numberIntersection][];
                arrayIntersection[numberIntersection++] = arrayIntersection[i];
            }
        }
        khi[] = khi[] ./= sum[];
        if(solver != 3 && solver != 5)
            overlapName = minimalMesh;
        else
            overlapName = trunc(renum=false,meshName, khi < 0.99);
        if(numberIntersection != arrayIntersection.n)
            arrayIntersection.resize(numberIntersection);
        Wh def(func2vec) = init(khi);
        D.resize(Wh.ndof);
        D = func2vec[];
        /* DEBUG   
        sum[] = khi[];
        for(j = 0; j < numberIntersection; ++j)
            sum[] += partitionIntersection[j][];
        assert(sum[].min > 1. - 1e-6 && sum[].max < 1. + 1e-6);
        mpiBarrier(comm);
        if(mpiRank(comm) == 0)
            cout << "Neighbors: " << mpiWtime() - timerPartition << endl;
        timerPartition = mpiWtime();
           DEBUG */

        /* savemesh(meshName, "Th-" + overlap + "-" + mpirank + ".msh"); */
        restrictionIntersection.resize(numberIntersection);
        for(i = 0; i < numberIntersection; ++i) {
            meshN meshIntersection = trunc(renum=false,meshName, partitionIntersection[i] > 1.0e-6);
            fespace WhIntersection(meshIntersection, P);
            matrix R = interpolate(WhIntersection, Wh);
            real[int] C;
            int[int] I;
            [I, restrictionIntersection[i], C] = R;
            restrictionIntersection[i].resize(R.nbcoef);
            /*
            int[int] n2o;
            meshN meshIntersection  = trunc(renum=false,meshName, partitionIntersection[i] > 1e-6, new2old = n2o);
            fespace WhIntersection(meshIntersection, P);
            restrictionIntersection[i] = restrict(WhIntersection, Wh, n2o);
            */
        }
        /*
        mpiBarrier(comm);
        if(mpiRank(comm) == 0)
            cout << "Construction: " << mpiWtime() - timerPartition << endl;
        timerPartition = mpiWtime();
        */
// EOM

macro build(globalTh, Th, ThBorder, ThOverlap, s, D, numberIntersection, arrayIntersection, restrictionIntersection, Wh, P, comm, excluded)
meshN ThOverlap, ThBorder;

/*# partition #*/
int[int] arrayIntersection;
int[int][int] restrictionIntersection(0);
real[int] D;

int numberIntersection = 0;
real timing;
{
    timing = mpiWtime();
    if(mpisize > 1 && !excluded) {
        globalTh(ThOverlap);
        fespace PhGlobal(ThOverlap, P0);
        PhGlobal part;
        if(partitioner != 0) {
            if(mpiRank(comm) == 0) {
                cout.scientific << " --- global mesh of " << ThOverlap.nt << " elements (prior to refinement) generated (in " << mpiWtime() - timing << ") and partitioned with ";
                timing = mpiWtime();
                if(partitioner == 2) {
                    scotch(part[], ThOverlap, mpiSize(comm));
                    cout << "SCOTCH";
                }
                else {
                    metisdual(part[], ThOverlap, mpiSize(comm));
                    cout << "Metis";
                }
                cout.scientific << " (in " << mpiWtime() - timing << ")" << endl;
            }
            timing = mpiWtime();
            broadcast(processor(0, comm), part[]);
        }
        else {
            simple(PhGlobal, part, comm)
        }
        partition(Th, ThBorder, ThOverlap, PhGlobal, part, s, D, Wh, P, numberIntersection, arrayIntersection, restrictionIntersection, comm, 10)
    }
    else if(mpisize == 1) {
        globalTh(Th);
        D.resize(Wh.ndof);
        D = 1.;
        /*
        coefficients
        fespace Ph(Th, P0);
        Ph poisson = skyscraper(x, y);
        load "iovtk"
        int[int] fforder=[1];
        savevtk("SC.vtk", Th, poisson, dataname = "kappa", order = fforder);
        exit(1);
        */
    }
    mpiBarrier(mpiCommWorld);
    if(mpirank == 0) cout.scientific << " --- partition of unity built (in " << mpiWtime() - timing << ")" << endl;
}
/*# partitionEnd #*/
// EOM

macro assemble(mat, rhs, Wh, Th, ThBorder, Varf)
K[int] rhs;
matrix<K> mat;
matrix<K> inter;
{ /* all memory of objects defined between this set of curly brackets
     will be freed when the closing bracket is reached */
    meshN ThAugmented = Th + ThBorder; /* ⠶$\Omega^{\delta + 1}_k = \Omega^\delta_k \cup \left(\Omega^{\delta + 1}_k \setminus \Omega^{\delta}_k\right)$⠶ */
    Varf(vPb, ThAugmented, PhAugmented)
    fespace WhAugmented(ThAugmented, Pk);
    mat = vPb(WhAugmented, WhAugmented, solver = CG);
    K[int] rhsFull = vPb(0, WhAugmented);
    matrix R = interpolate(Wh, WhAugmented);

    if(mpisize > 1 && solver == 101)
        removeInteraction(mat, R, rhsFull, rhs, interaction = inter);
    else
        renumbering(mat, R, rhsFull, rhs);

    /*
    ofstream filer("r-" + mpirank + ".mtx");
    filer << inter << endl;
    ofstream fileg("dump.m");
    fileg.scientific;
    fileg.precision(16);
    int[int] I(0), J(0);
    K[int] C(0);
    [I, J, C] = mat;
    I += 1; J += 1;
    for(int i = 0; i < I.n; ++i)
        fileg << I[i] << " " << J[i] << " " << real(C[i]) << "+1i*" << imag(C[i]) << endl;
    */
}
// EOM

macro assembleUnsym(mat, rhs, Wh, Th, ThBorder, Varf)
{
    Varf(vPb, Th, Ph)
    mat = vPb(Wh, Wh, tgv = -1);
    rhs = vPb(0, Wh, tgv = -1);
}
// EOM

macro assembleNonlinear(mat, rhs, Wh, Th, ThBorder, Varf)
real[int] rhs;
matrix mat;
meshN ThAugmented = Th + ThBorder; /* ⠶$\Omega^{\delta + 1}_k = \Omega^\delta_k \cup \left(\Omega^{\delta + 1}_k \setminus \Omega^{\delta}_k\right)$⠶ */
ThBorder = minimalMesh;
Varf(vPb, ThAugmented, PhAugmented,u)
fespace WhAugmented(ThAugmented, Pk);
matrix R = interpolate(Wh, WhAugmented);
{ /* all memory of objects defined between this set of curly brackets
     will be freed when the closing bracket is reached */
    /* mat = vPb(WhAugmented, WhAugmented, solver = CG); */
    mat = vPbNonlinear(WhAugmented, WhAugmented, solver = CG);
    real[int] rhsFull = vPbLinear(0, WhAugmented);

    renumbering(mat, R, rhsFull, rhs);
}
// EOM
