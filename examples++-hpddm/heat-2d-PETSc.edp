//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
load "metis"                        // Metis partitioner
load "scotch"                       // SCOTCH partitioner
include "macro_ddm.idp"             // additional DDM functions

macro meshN()mesh// EOM                     // two-dimensional problem
macro bbN()bb2// EOM                        // two-dimensional bounding box
macro intN()int2d// EOM                     // two-dimensional integral
macro intN1()int1d// EOM                    // one-dimensional integral
macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM           // two-dimensional gradient
func Pk = P2;                               // finite element space

int s = getARGV("-split", 1);                                   // refinement factor
int partitioner = getARGV("-partitioner", 1);                   // partitioner (1: Metis, 2: SCOTCH)
real dt = getARGV("-dt", 0.1);                                 // time step
real mu = 0.01;
int iMax = getARGV("-iMax", 10);                                // number of iterations

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - heat-2d-PETSc.edp - input parameters: refinement factor = " << s << " - with partitioner? = " << partitioner << endl;
}

meshN Th = square(1, 1);
fespace Wh(Th, Pk);                         // local finite element space
int[int] arrayIntersection;                 // ranks of neighboring subdomains
int[int][int] restrictionIntersection(0);   // local-to-neighbors renumbering
real[int] D;                                // partition of unity
{
    int[int] l = [1, 1, 1, 1];
    meshN ThBorder, ThGlobal = square(getARGV("-global", 40), getARGV("-global", 40), label = l);    // global mesh
    build(Th, ThBorder, ThGlobal, 10, s, 1, D, arrayIntersection, restrictionIntersection, Wh, Pk, mpiCommWorld, false)
}

real[int] rhs(Wh.ndof);                     // local right-hand side
matrix<real> Mat;                           // local operator
matrix<real> M;                             // local mass matrix
{                                           // local weak form
    fespace Ph(Th, P0);
    Ph f = x < 0.25 ? 1.0e+3 : 1.0e-3;
    varf vPb(u, v) = intN(Th)(u * v + dt * (grad(u)' * grad(v))) + intN(Th)(dt * f *  v) + on(1, u = 0.0);
    Mat = vPb(Wh, Wh, tgv = -1);
    rhs = vPb(0, Wh, tgv = -1);
    varf vPbM(u, v) = intN(Th)(u * v);
    M = vPbM(Wh, Wh);
}

dmatrix A(Mat, arrayIntersection, restrictionIntersection, D);
set(A, sparams = "-ksp_view");

Wh<real> def(u) = init(0.0);    // local solution
for(int i = 0; i < iMax; ++i) {
    real[int] newRhs(rhs.n);
    newRhs = M * u[];
    newRhs += rhs;

    u[] = A^-1 * newRhs;

    plotMPI(Th, u[], "Global solution", Pk, def, real, 3, 0)
}
