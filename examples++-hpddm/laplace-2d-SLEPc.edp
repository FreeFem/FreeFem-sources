// This codes shows how to calculate the eigenvalue spectrum of
// the Laplace operator on a 2d square domain, using SLEPc.
//
// Usage:
// mpirun -np 4 FreeFem++-mpi laplace-2d-SLEPc.edp \
//        -split 1 -global 400 -sigma 0.0
//
// Authors: Julien Garaud <julien.garaud@gmail.com>
//          Pierre Jolivet <pierre.jolivet@enseeiht.fr>

/**************************************/
/*          Load PETSc macros         */
/**************************************/
load "PETSc"                              // PETSc plugin
load "SLEPc"
macro partitioner()metis// End Of Macro   // metis, scotch, or parmetis
macro dimension(      )2// End Of Macro   // 2D or 3D
include "macro_ddm.idp"                   // Additional DDM functions

/**************************************/
/*    Macros for distributed solver   */
/**************************************/
macro def(i)i  // End Of Macro   // Definition of scalar fields
macro init(i)i // End Of Macro   // Initialization of scalar fields
func Pk = P1;                    // Finite-element space

/***************************************/
/*    Options for distributed solver   */
/***************************************/
int s      = getARGV("-split", 1);   // Refinement factor
//
int global = getARGV("-global", 200);// Number of points on the perimeter  
real Lx    = getARGV("-lx"   , pi);  // Dimension of the domain  
real Ly    = getARGV("-ly"   , pi);  // Dimension of the domain  
//
real sigma = getARGV("-sigma", 0.0); // Shift
/***************************************/
/*     Verbosity and passed options    */
/***************************************/
if(verbosity > 0 && mpirank == 0) {
    cout << "********************************************"  << endl
	 << " --- " << mpirank << "/" << mpisize 
	 << "- laplace-2d-SLEPc.edp "     << endl
	 << "********************************************"  << endl
	 << "- input parameters: "                          << endl
	 << "  refinement factor  = " << s                  << endl
	 << "********************************************"  << endl
	 << "  nb of pts on perimeter = " << global
	 << "  Domain size [Lx,Ly]    = ["<<Lx<<","<<Ly<<"]"<< endl
	 << "********************************************"  << endl
	 << endl;
}
/***************************************/
/*   ###############################   */
/***************************************/
meshN Th = square(1, 1);                    // Local mesh
int[int] arrayIntersection;                 // Rank of neighborings subdomains
int[int][int] restrictionIntersection(0);   // Local-to-neighbors renumbering
real[int] D;                                // Partition of unity

/***************************************/
/*         Finite Element space        */
/***************************************/
// Definition of the finite element space on the domain Th
// P1 are the first order Lagrange elements 
fespace Vh(Th, Pk);      // local finite element space

/***************************************/
/*         Geometry parameters         */
/***************************************/
int[int] Labels=[1,2,3,4]; // labels : bottom, right, top, left sides

/***************************************/
/*            ##############           */
/***************************************/
{ // Construction of the rectangular domain
  int Xpts= int(0.5*global*Lx/(Lx+Ly)); // pts on the x-axis sides
  int Ypts= int(0.5*global*Ly/(Lx+Ly)); // pts on the y-axis sides

  meshN ThBorder, ThGlobal ;
  ThGlobal = square(Xpts,Ypts,[Lx*(x-0.5),Ly*(y-0.5)],label=Labels);
  // .....
  build(Th,   // The local mesh
	ThBorder, // The interface mesh
	ThGlobal, // The global mesh
	10,       //
	s,        // Refinement factor
	1,        //
	D,        // partition of unity
	arrayIntersection,       // ranks of neighboring subdomains
	restrictionIntersection, // local-to-neighbors renumbering
	Vh,           // The local Finite Element space
	Pk,           // FE-space
	mpiCommWorld, // Communicator
	false
	);
}
/***************************************/
/*          Problem parameters         */
/***************************************/

/***************************************/
/*          Problem definition         */
/***************************************/
varf vA(uh,vh)= intN(Th)        //  Definion of  the problem
  ( dx(uh)*dx(vh)+dy(uh)*dy(vh)
    -sigma*uh*vh               )//  Bilinear form
  +on(Labels[3], uh = 0.0)      //  Boundary Conditions
  +on(Labels[2], uh = 0.0)      //  Boundary Conditions
  +on(Labels[1], uh = 0.0)      //  Boundary Conditions
  +on(Labels[0], uh = 0.0)      //  Boundary Conditions
  ;

varf vB(uh,vh)= intN(Th)  //  Definion of  the problem
  ( uh*vh )               //  Bilinear form
  ;

matrix<real> A = vA(Vh,Vh);
matrix<real> B = vB(Vh,Vh);
/***************************************/
/*      Build distributed matrices     */
/***************************************/
dmatrix DistA(A, arrayIntersection, restrictionIntersection, D, clean = true);
dmatrix DistB(DistA, B, clean = true);

/***************************************/
/*          Problem resolution         */
/***************************************/
real[int]     EigenVAL(0);       // array to store eigenvalues
Vh<real>[int] def(EigenVEC)(1);  // array to store eigenvectors
EigenVEC[0][] = 0.0;

int k = deigensolver
  (DistA,
   DistB,
   vectors = EigenVEC,
   values = EigenVAL,
   sparams = "-eps_nev 20 -eps_type krylovschur -eps_target 0.0 -st_type sinvert -st_pc_type lu -st_pc_factor_mat_solver_package mumps -eps_view -eps_gen_hermitian"
   );
/***************************************/
/*           View the solution         */
/***************************************/
Vh<real> Temp;

for(int i=0;i<k;i++){
  if(!mpirank) cout << " Eigenvalue #"+i+" = "+EigenVAL[i]<<endl;
  Temp = EigenVEC[i];
  plotMPI(Th, // Local mesh
      Temp[], // Local solution
      "Psi("+i+")  EV = "+EigenVAL[i], // Comment
      Pk,     // Local FE-space
      def,    // Macro for field definition
      real,   // Type
      3,      // 2d/3d view
      1       // Wait
      )
 }
