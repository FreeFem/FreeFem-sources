if(solver != 3 && usedARGV("-hpddm_master_exclude") == -1)
    stats.resize(5);
else if(solver == 3 && usedARGV("-hpddm_master_exclude") != -1)
    stats.resize(7);
include "schur-additional_macro.idp"

mpiComm comm;
int p = getARGV("-p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-topology", 0), exclude = (usedARGV("-hpddm_master_exclude") != -1));

if(mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - " << txt << " - input parameters: global size = " << global << " - refinement factor = " << s << " - precision = " << getARGV("-eps", 1e-8) << " - with partitioner? = " << partitioner << endl;
}

meshN Th = minimalMesh;
build(ThGlobal, generateTh, Th, s, numberIntersection, arrayIntersection, restrictionIntersection, Wh, Pk)

coefficients

/*# localMatrix #*/
timing = mpiWtime();
matrix Mat;
real[int] rhs(Wh.ndof);
{
    Varf(vPb, Th, Ph)
    Mat = vPb(Wh, Wh, solver = CG);
    rhs = vPb(0, Wh);
}
stats[0] = mpiWtime() - timing;
/*# localMatrixEnd #*/

dbdd A(Mat, arrayIntersection, restrictionIntersection, communicator = comm);

/*# coarseSpace #*/
timing = mpiWtime();

if(mpisize == 1)
    renumber(A, Mat, interfaceNb, effort = rhs, timing = stats);
else {
    if(excluded)
        attachCoarseOperator(mpiCommWorld, A, /*R = Rb,*/ timing = stats, threshold = getARGV("-threshold", 0.0));
    else {
        Wh[int] def(Rb)(0);
        real[int] float(Wh.ndof);
        floating(Th, Wh, float);
        if(float.max < 0.9 && solver != 3) {
            generateRbm(Rb)
        }
        if(getARGV("-hpddm_substructuring_scaling", 0) != 2)
            renumber(A, Mat, interfaceNb, R = Rb, effort = rhs, timing = stats);
        else {
            Wh def(Young) = init(stripes(y, x, 2e11, 1e7));
            Wh def(poisson) = init(stripes(y, x, 0.25, 0.45));
            Wh def(tmp) = init(1. + poisson);
            Wh def(mu) = init(Young  / (2. * tmp));
            renumber(A, Mat, interfaceNb, R = Rb, effort = rhs, timing = stats, rho = mu[]);
        }
        scalar(pair) ret;
        attachCoarseOperator(mpiCommWorld, A, R = Rb, timing = stats, threshold = getARGV("-threshold", 0.0), ret = ret);
    }
}

Wh def(u) = init(0); // this will be the solution

DDM(A, u[], rhs, iter = getARGV("-iter", -1), eps = getARGV("-eps", -1.0), timing = stats, excluded = excluded);

if(!excluded) {
    real[int] metrics(3), metricsReduce(3);
    metrics(0) = nbDof(A);
    metrics(1) = numberIntersection / real(mpiSize(comm));
    metrics(2) = nbMult(A) / 2.;
    mpiReduce(metrics, metricsReduce, processor(0, comm), mpiSUM);
    cout.precision(1);
    if(mpiRank(comm) == 0) {
        fespace Ph(Th, P0);
        Ph hSize = hTriangle;
        cout.fixed << " --- number of Lagrange multipliers: " << metricsReduce(2) << ", number of dof: " << metricsReduce(0) << ", on average, number of neighbors: " << metricsReduce(1) << ", h: ";
        cout.scientific << hSize[].max << endl;
    }

    real[int, int] statsMaster(stats.n, mpiRank(comm) == 0 ? mpiSize(comm) : 0);
    mpiGather(stats, statsMaster, processor(0, comm));
    if(mpiRank(comm) == 0) {
        cout << "Assem. solver   Renumbering   Fact. pinv.  Fact. prec.  ";
        if(mpiSize(comm) > 1) {
            cout << "Coarse op.";
            if(solver == 3)
                cout << "   GenEO" << (mpisize != mpiSize(comm) ? "        " : "");
            else
                cout << "   ";
            if(mpisize != mpiSize(comm))
                cout << "Waiting time";
        }
        cout << endl;
        for(i = 0; i < mpiSize(comm); ++i) {
            cout.precision(4);
            cout.scientific << statsMaster(0, i) << "      " << statsMaster(1, i) << "    " << statsMaster(2, i) << "   " << statsMaster(3, i);
            if(mpiSize(comm) > 1) {
                cout << "   " << statsMaster(4, i);
                if(solver == 3)
                    cout.scientific << "   " << statsMaster(5, i) << "";
                if(mpisize != mpiSize(comm))
                    cout.scientific << "   " << statsMaster(stats.n - 1, i);
            }
            cout << endl;
        }
    }

    originalNumbering(A, u[], interfaceNb);
}
MoveAndPlot(Th, u, Pk, def, 3)
