if(mpirank==0) { int i; cin >> i;}
macro K()real// EOM
macro scalar(name)d#name// EOM
include "macro_3d.idp"
macro def()def3// EOM
macro init()init3// EOM
macro BC()BC3// EOM
macro meshN()mesh3// EOM
macro intN()int3d// EOM
macro intN1()int2d// EOM
macro measureN()volume// EOM
macro bbN()bb3// EOM
macro simple(Ph, function, comm)simple3d(Ph, function, comm, 1., 1., 1.)// EOM
macro MoveAndPlot(Th, u, Pk, def, dim)
/*
load "iovtk"
{
    fespace Ph(Th, P0);
    Ph poisson = stripes(x, y, z, 0.25, 0.45);
    int[int] order = [1, 1];
    if(mpisize > 1)
        savevtk("kappa_"+mpirank+".vtk", Th, poisson, [u, uB, uC], dataname="kappa solution", order = order);
    else
        savevtk("kappa.vtk", Th, poisson, [u, uB, uC], dataname="kappa solution", order = order);
}
*/
plotMPI(Th, u, "Global solution", Pk, def, dim, 1)
meshN ThMoved = movemesh3(Th, transfo = [x + u, y + u#B, z + u#C]);
plotAll(ThMoved, u, "Global solution", Pk, def, dim)
// EOM
include "argv.idp"

macro minimalMesh()Cube(CC, BB, LL)// EOM
// macro generateTh()("tripod.mesh");// EOM
macro generateTh(name)name = Cube(NN, BB, LL);// EOM
// int[int, int] LL = [[1,1], [1,1], [1,1]];
int[int, int] LL = [[1,3], [2,2], [2,2]];
int[int] NN = [8 * global, global, global];
// real[int, int] BB = [[0,1], [0,1], [0,1]];
real[int, int] BB = [[0,8], [0,1], [0,1]];
int[int] CC = [1, 1, 1];

string txt = "elasticity 3D, $\\mathbb{P}_2$ FE";
func Pk = [P2, P2, P2];

real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), dz(u#C), (dz(u#B) + dy(u#C)) / Sqrt, (dz(u) + dx(u#C)) / Sqrt, (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM

macro coefficients()
    /*
func real stripes(real a, real b, real c, real paramA, real paramB) {
    if(b < 5e-2 && b > -5e-2) {
        int x = int(20 * a);
        if(x % 2)
            kappa = 5e4;
        else
            kappa = 1e5;
    }
    if(sqrt(a^2 + c^2) < 0.12) {
        int z = int(40 * b);
        if(z % 2)
            kappa = 1e6;
        else
            kappa = 5e5;
    }
    if(sqrt(a^2 + c^2) < 0.15) {
        int z = int(20 * b);
        if(z % 2)
            return paramA;
        else
            return paramB;
    }
    if(b < 10e-2 && b > -5e-2) {
        int x = int(20 * a);
        if(x % 2)
            return paramA;
        else
            return paramB;
    }
    return paramA;
}
    */
func real stripes(real a, real b, real paramA, real paramB) {
    int da = int(a * 8);
    return (da == (int(da / 2) * 2) ?  paramB : paramA);
}
real f = -9000.0;
real strain = -1000.0;
// EOM

macro Varf(varfName, meshName, PhName)
    fespace PhName(meshName, P0);
    /*
    PhName Young = stripes(y, x, 1e7, 1e7);
    PhName poisson = stripes(y, x, 0.3, 0.3);
    */
    /*
    PhName Young = stripes(x, y, z, 2e11, 1e7);
    PhName poisson = stripes(x, y, z, 0.25, 0.45);
    */
    PhName Young = stripes(y, x, 1e7, 1e7);
    PhName poisson = stripes(y, x, 0.45, 0.45);
    PhName tmp = 1.0 + poisson;
    PhName mu = Young  / (2.0 * tmp);
    PhName lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
    /*
    varf varfName([u1, u2, u3], [v1, v2, v3]) = intN(meshName)(lambda * div(u) * div(v) + 2. * mu * (epsilon(u)' * epsilon(v))) + intN(meshName)(f * v2) + intN(meshName, 411)(strain * v2) + on(409, u1 = 0, u2 = 0, u3 = 0);
    */
    varf varfName(def(u), def(v)) = intN(meshName)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + intN(meshName)(f * vC) + int2d(meshName, 3)(strain * vB) + on(1, BC(u, 0));
// EOM

macro EVproblem(varfName, meshName, PhName)
    fespace PhName(meshName, P0);
    /*
    PhName Young = stripes(y, x, 1e7, 1e7);
    PhName poisson = stripes(y, x, 0.3, 0.3);
    */
    /*
    PhName Young = stripes(x, y, z, 2e11, 1e7);
    PhName poisson = stripes(x, y, z, 0.25, 0.45);
    */
    PhName Young = stripes(y, x, 2e11, 1e7);
    PhName poisson = stripes(y, x, 0.25, 0.45);
    PhName tmp = 1.0 + poisson;
    PhName mu = Young  / (2.0 * tmp);
    PhName lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
    /*
    varf varfName([u1, u2, u3], [v1, v2, v3]) = intN(meshName)(lambda * div(u) * div(v) + 2. * mu * (epsilon(u)' * epsilon(v))) + on(409, u1 = 0, u2 = 0, u3 = 0);
    */
    varf varfName(def(u), def(v)) = intN(meshName)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + on(1, BC(u, 0));
// EOM

macro optimizedMacro(varfName, meshName, PhName)
    fespace PhName(meshName, P0);
    /*
    PhName Young = stripes(y, x, 1e7, 1e7);
    PhName poisson = stripes(y, x, 0.3, 0.3);
    */
    /*
    PhName Young = stripes(x, y, z, 2e11, 1e7);
    PhName poisson = stripes(x, y, z, 0.25, 0.45);
    */
    PhName Young = stripes(y, x, 2e11, 1e7);
    PhName poisson = stripes(y, x, 0.25, 0.45);
    PhName tmp = 1.0 + poisson;
    PhName mu = Young  / (2.0 * tmp);
    PhName lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
    /*
    varf varfName([u1, u2, u3], [v1, v2, v3]) = intN(meshName)(lambda * div(u) * div(v) + 2. * mu * (epsilon(u)' * epsilon(v))) + on(409, u1 = 0, u2 = 0, u3 = 0);
    */
    real kZero = getARGV("-kZero", 10);
    PhName transmission = 2 * kZero * mu * (2 * mu + lambda) / (lambda + 3 * mu);
    varf varfName(def(u), def(v)) = intN(meshName)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + intN1(meshName, 10)(transmission * (def(u)' * def(v))) + on(1, BC(u, 0));// EOM

macro generateRbm(RbName)
    RbName.resize(6);
    [RbName[0], RbName#B[0], RbName#C[0]] = [ 1,  0,  0];
    [RbName[1], RbName#B[1], RbName#C[1]] = [ 0,  1,  0];
    [RbName[2], RbName#B[2], RbName#C[2]] = [ 0,  0,  1];
    [RbName[3], RbName#B[3], RbName#C[3]] = [ y, -x,  0];
    [RbName[4], RbName#B[4], RbName#C[4]] = [-z,  0,  x];
    [RbName[5], RbName#B[5], RbName#C[5]] = [ 0,  z, -y];// EOM

// include "Schwarz/skel.edp"
include "schur-skel.idp"
